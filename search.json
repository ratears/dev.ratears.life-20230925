[{"title":"Mybatis Study Notes（1）：Mybatis Introduction","url":"/Mybatis-Study-Notes%EF%BC%881%EF%BC%89%EF%BC%9AMybatis-Introduction/","content":"framework\nJava常⽤框架\nSSM三⼤框架：Spring + SpringMVC + MyBatis\nSpringBoot\nSpringCloud\n……\n\n\n框架其实就是对通⽤代码的封装，提前写好了⼀堆接⼝和类，我们可以在做项⽬的时候直接引⼊这些接⼝和类（引⼊框架），基于这些现有的接⼝和类进⾏开发，可以⼤⼤提⾼开发效率。\n框架⼀般都以jar包的形式存在。(jar包中有class⽂件以及各种配置⽂件等。)\n\n\n\n\n\n\n\n三层架构\n表现层（UI）：直接跟前端打交互（⼀是接收前端ajax请求，⼆是返回json数据给前端）\n业务逻辑层（BLL）：⼀是处理表现层转发过来的前端请求（也就是具体业务），⼆是将从持久层获取的数据返回到表现层。\n数据访问层（DAL）：直接操作数据库完成CRUD，并将获得的数据返回到上⼀层（也就是业务逻辑层）。\n\n\n\n\n\n\n\nJDBC的不⾜\n示例代码1：\n\n// ......// sql语句写死在java程序中String sql = &quot;insert into t_user(id,idCard,username,password,birth,gender,email,city,street,zipcode,phone,grade) values(?,?,?,?,?,?,?,?,?,?,?,?)&quot;;PreparedStatement ps = conn.prepareStatement(sql);// 繁琐的赋值：思考⼀下，这种有规律的代码能不能通过反射机制来做⾃动化。ps.setString(1, &quot;1&quot;);ps.setString(2, &quot;123456789&quot;);ps.setString(3, &quot;zhangsan&quot;);ps.setString(4, &quot;123456&quot;);ps.setString(5, &quot;1980-10-11&quot;);ps.setString(6, &quot;男&quot;);ps.setString(7, &quot;zhangsan@126.com&quot;);ps.setString(8, &quot;北京&quot;);ps.setString(9, &quot;⼤兴区凉⽔河⼆街&quot;);ps.setString(10, &quot;1000000&quot;);ps.setString(11, &quot;16398574152&quot;);ps.setString(12, &quot;A&quot;);// 执⾏SQLint count = ps.executeUpdate();// ......\n\n\n\n\n示例代码2：\n\n// ......// sql语句写死在java程序中String sql = &quot;select id,idCard,username,password,birth,gender,email,city,street,zipcode,phone,grade from t_user&quot;;PreparedStatement ps = conn.prepareStatement(sql);ResultSet rs = ps.executeQuery();List&lt;User&gt; userList = new ArrayList&lt;&gt;();// 思考以下循环中的所有代码是否可以使⽤反射进⾏⾃动化封装。while(rs.next())&#123;// 获取数据String id = rs.getString(&quot;id&quot;);String idCard = rs.getString(&quot;idCard&quot;);String username = rs.getString(&quot;username&quot;);String password = rs.getString(&quot;password&quot;);String birth = rs.getString(&quot;birth&quot;);String gender = rs.getString(&quot;gender&quot;);String email = rs.getString(&quot;email&quot;);String city = rs.getString(&quot;city&quot;);String street = rs.getString(&quot;street&quot;);String zipcode = rs.getString(&quot;zipcode&quot;);String phone = rs.getString(&quot;phone&quot;);String grade = rs.getString(&quot;grade&quot;);// 创建对象User user = new User();// 给对象属性赋值user.setId(id);user.setIdCard(idCard);user.setUsername(username);user.setPassword(password);user.setBirth(birth);user.setGender(gender);user.setEmail(email);user.setCity(city);user.setStreet(street);user.setZipcode(zipcode);user.setPhone(phone);user.setGrade(grade);// 添加到集合userList.add(user);&#125;// ......\n\n\n\n\nJDBC的不足\nSQL语句写死在Java程序中，不灵活。改SQL的话就要改Java代码。违背开闭原则OCP。\n给?传值是繁琐的。能不能⾃动化？？？\n将结果集封装成Java对象是繁琐的。能不能⾃动化？？？\n\n\n\n\n\n\n\n\n\n了解MyBatis简介\nMyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\n\nMyBatis本质上就是对JDBC的封装，通过MyBatis完成CRUD。\n\n\n\n\nMyBatis历史\nMyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下， iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github。\niBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。 iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO）。\n\n\n\nORM：对象关系映射\nO（Object）：Java虚拟机中的Java对象\nR（Relational）：关系型数据库\nM（Mapping）：将Java虚拟机中的Java对象映射到数据库表中⼀⾏记录，或是将数据库表中⼀⾏记录映射成Java虚拟机中的⼀个Java对象。\n\n\n\nMyBatis框架特点\nMyBatis 是一个 半自动的ORM（Object Relation Mapping）框架\n\n⽀持定制化 SQL、存储过程、基本映射以及⾼级映射\n\n避免了⼏乎所有的 JDBC 代码中⼿动设置参数以及获取结果集\n\n⽀持XML开发，也⽀持注解式开发。【为了保证sql语句的灵活，所以mybatis⼤部分是采⽤XML⽅式开发。】\n\n将接⼝和 Java 的 POJOs(Plain Ordinary Java Object，简单普通的Java对象)映射成数据库中的记录\n\n体积⼩好学：两个jar包，两个XML配置⽂件。\n\n完全做到sql解耦合。\n\n提供了基本映射标签。\n\n提供了⾼级映射标签。\n\n提供了XML标签，⽀持动态SQL的编写。\n\n……\n\n\n\n\n和其它持久化层技术对比JDBC\nSQL 夹杂在Java代码中耦合度高，导致硬编码内伤\n维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见\n代码冗长，开发效率低\n\n\n\nHibernate 和 JPA\n操作简便，开发效率高\n程序中的长难复杂 SQL 需要绕过框架\n内部自动生产的 SQL，不容易做特殊优化\n基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。\n反射操作太多，导致数据库性能下降\nHibernate属于全⾃动化的ORM框架。（使用Hibernate框架的时候，不需要程序员手动编写SQL语句，SQL语句可以自动生成。所以Hibernate是一个完全的全自动化的ORM框架）\n\n\n\nMyBatis\n轻量级，性能出色\nSQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据\n开发效率稍逊于HIbernate，但是完全能够接受\n\n\n\n\n\n\n\n学习备注\n1\n\n&lt;font color=red&gt;&lt;/font&gt;&amp;emsp;&amp;emsp;\n\n\n\n","categories":["framework","mybatis"],"tags":["mybatis","ORM","framework"]},{"title":"Linux 常用基础操作","url":"/Linux-%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/","content":"前言SELinux\nSELinux是Linux2.6以上版本捆绑的一个安全模块\nSELinux配置复杂，容易跟其他程序冲突，所以建议关闭\n\n\n关闭SELinux\n\nvim /etc/selinux/config# 设置SELINUX=disabled，重启系统\n\n\n\n\n\n\n\nyum\n替换yum源\n\ncurl -o /etc/yum.repos.d/CentOS-Base.repo mirrors.163.com/.help/CentOS7-Base-163.repo# 更新缓存yum clean allyum makecache\n\n\n\n\n\n\n\nLinux防火墙\n\n\n\n\n\n学习备注\n1\n\n&lt;font color=red&gt;&lt;/font&gt;&amp;emsp;&amp;emsp;\n\n\n\n","categories":["Linux"],"tags":["Linux"]},{"title":"Redis Study Notes（4）：Redis Persistence","url":"/Redis-Study-Notes%EF%BC%884%EF%BC%89%EF%BC%9ARedis-Persistence/","content":"概述\nRedis 具有持久化功能，其会按照设置以快照（RDB）或操作日志（AOF）的形式将数据持久化到磁盘。\n\n\n\n\n\n\n\nRedis 持久化基本原理\n\n\n\n\nRedis 持久化也称为钝化，是指将内存中数据库的状态描述信息保存到磁盘中。只不过是不同的持久化技术，对数据的状态描述信息是不同的，生成的持久化文件也是不同的。但它们的作用都是相同的：避免数据意外丢失。\n通过手动方式，或自动定时方式，或自动条件触发方式，将内存中数据库的状态描述信息写入到指定的持久化文件中。当系统重新启动时，自动加载持久化文件，并根据文件中数据库状态描述信息将数据恢复到内存中，这个数据恢复过程也称为激活。这个钝化与激活的过程就是 Redis 持久化的基本原理。\n对于 Redis 单机状态下，无论是手动方式，还是定时方式或条件触发方式，都存在数据丢失问题：在尚未手动/自动保存时发生了 Redis 宕机状况，那么从上次保存到宕机期间产生的数据就会丢失。不同的持久化方式，其数据的丢失率也是不同的。\nRDB 是默认持久化方式，但 Redis 允许 RDB 与 AOF 两种持久化技术同时开启，此时系统会使用 AOF 方式做持久化，即 AOF 持久化技术的优先级要更高。同样的道理，两种技术同时开启状态下，系统启动时若两种持久化文件同时存在，则优先加载 AOF持久化文件。\n\n\n\n\n\n\n\nRDB 持久化概述\nRDB，Redis DataBase，是指将内存中某一时刻的数据快照全量写入到指定的 rdb 文件的持久化技术。\nRDB 持久化默认是开启的。当 Redis 启动时会自动读取 RDB 快照文件，将数据从硬盘载入到内存，以恢复 Redis 关机前的数据库状态。\n\n\n\n持久化的执行\nRDB 持久化的执行有三种方式：手动 save 命令、手动 bgsave 命令，与自动条件触发。\n\n\n\n手动 save  命令\n通过在 redis-cli 客户端中执行 save 命令可立即进行一次持久化保存。\nsave 命令在执行期间会阻塞 redis-server 进程，直至持久化过程完毕。而在 redis-server 进程阻塞期间，Redis不能处理任何读写请求，无法对外提供服务。\n\n\n\n手动 bgsave  命令\n通过在 redis-cli 客户端中执行 bgsave 命令可立即进行一次持久化保存。\nbgsave 命令会使服务器进程 redis-server 生成一个子进程，由该子进程负责完成保存过程。在子进程进行保存过程中，不会阻塞 redis-server 进程对客户端读写请求的处理。\n\n\n\n自动条件触发\n自动条件触发的本质仍是 bgsave 命令的执行。只不过是用户通过在配置文件中做相应的设置后，Redis 会根据设置信息自动调用 bgsave 命令执行。具体配置方式，参考 RDB 优化配置 - save\n\n\n\n查看持久化时间\n通过 lastsave 命令可以查看最近一次执行持久化的时间，其返回的是一个 Unix 时间戳。\n\n127.0.0.1:6379&gt; lastsave(integer) 1677689127127.0.0.1:6379&gt; exit[root@localhost ~]# date -d @1677689127Thu Mar  2 00:45:27 CST 2023\n\n\n\nRDB 优化配置\nDB 相关的配置在 redis.conf 文件的 SNAPSHOTTING 部分\n\n\n\nsavesave 3600 1 300 100 60 10000# 该配置用于设置快照的自动保存触发条件，即 save point，保存点。该触发条件是在指定时间段内发生了指定次数的写操作。除非另有规定，默认情况下持久化条件为 save 3600 1 300 100 60 10000。（跟redis6的默认值比，条件更宽松）其等价于以下三条：save 3600 1 # 在 3600 秒(1 小时)内发生 1 次写操作save 300 100 # 在 300 秒(5 分钟)内发生 100 次写操作save 60 10000 # 在 60 秒(1 分钟)内发生 1 万次写操作# 如果不启用 RDB 持久化，只需设置 save 的参数为空串即可：save “”。\n\n\n\nstop-write-on-bgsave-errorstop-writes-on-bgsave-error yes# 默认情况下，如果 RDB 快照已启用（至少一个保存点），且最近的 bgsave 命令失败，Redis将停止接受写入。这样设置是为了让用户意识到数据没有正确地保存到磁盘上，否则很可能没有人会注意到，并会发生一些灾难。当然，如果 bgsave 命令后来可以正常工作了，Redis将自动允许再次写入。\n\n\n\nrdbcompressionrdbcompression yes# 当进行持久化时启用 LZF 压缩字符串对象。虽然压缩 RDB 文件会消耗系统资源，降低性能，但可大幅降低文件的大小，方便保存到磁盘，加速主从集群中从节点的数据同步。\n\n\n\nrdbchecksumrdbchecksum yes# 从 RDB5 开始，RDB 文件的 CRC64 校验和就被放置在了文件末尾。这使格式更能抵抗 RDB文件的损坏，但在保存和加载 RDB 文件时，性能会受到影响（约 10%），因此可以设置为 no禁用校验和以获得最大性能。在禁用校验和的情况下创建的 RDB 文件的校验和为零，这将告诉加载代码跳过校验检查。默认为 yes，开启了校验功能。\n\n\n\nsanitize-dump-payloadsanitize-dump-payload no# 该配置用于设置在加载 RDB 文件或进行持久化时是否开启对 zipList、listPack 等数据的全面安全检测。该检测可以降低命令处理时发生系统崩溃的可能。其可设置的值有三种选择：# no：不检测# yes：总是检测# clients：只有当客户端连接时检测。排除了加载 RDB 文件与进行持久化时的检测。# 默认值本应该是 clients，但其会影响 Redis 集群的工作，所以默认值为 no，不检测\n\n\n\ndbfilenamedbfilename dump.rdb# 指定 RDB 文件的默认名称，默认为 dump.rdb。\n\n\n\nrdb-del-sync-filesrdb-del-sync-files no# 主从复制时，是否删除用于同步的从机上的 RDB 文件。默认是 no，不删除。不过需要注意，只有当从机的 RDB 和 AOF 持久化功能都未开启时才生效。\n\n\n\ndirdir ./# 指定 RDB 与 AOF 文件的生成目录。默认为 Redis 安装根目录。\n\n\n\nRDB 文件结构\nRDB 持久化文件 dump.rdb 整体上有五部分构成：\n\n\n\n\n\nSOF\nSOF 是一个常量，一个字符串 REDIS，仅包含这五个字符，其长度为 5。于标识 RDB文件的开始，以便在加载 RDB 文件时可以迅速判断出文件是否是 RDB 文件。\n\n\n\nrdb_version\n一个整数，长度为 4 字节，表示 RDB 文件的版本号。\n\n\n\nEOF\nEOF 是一个常量，占 1 个字节，用于标识 RDB 数据的结束，校验和的开始\n\n\n\ncheck_sum\n校验和 check_sum 用于判断 RDB 文件中的内容是否出现数据异常。其采用的是 CRC 校验算法。\n\n\nCRC 校验算法：\n\n在持久化时，先将 SOF、rdb_version 及内存数据库中的数据快照这三者的二进制数据拼接起来，形成一个二进制数（假设称为数 a），然后再使用这个 a 除以校验和 check_sum，此时可获取到一个余数 b，然后再将这个 b 拼接到 a 的后面，形成 databases。\n在加载时，需要先使用 check_sum 对 RDB 文件进行数据损坏验证。验证过程：只需将RDB 文件中除 EOF 与 check_sum 外的数据除以 check_sum。只要除得的余数不是 0，就说明文件发生损坏。当然，如果余数是 0，也不能肯定文件没有损坏。\n这种验证算法，是数据损坏校验，而不是数据没有损坏的校验。\n\n\n\n\ndatabases\n\n\n\n\ndatabases 部分是 RDB 文件中最重要的数据部分，其可以包含任意多个非空数据库。而每个 database 又是由三部分构成：\nSODB：是一个常量，占 1 个字节，用于标识一个数据库的开始。\ndb_number：数据库编号\nkey_value_pairs：当前数据库中的键值对数据。每个 key_value_pairs 又由很多个用于描述键值对的数据构成。\nVALUE_TYPE：是一个常量，占 1 个字节，用于标识该键值对中 value 的类型。\nEXPIRETIME_UNIT：是一个常量，占 1 个字节，用于标识过期时间的单位是秒还是毫秒。\ntime：当前 key-value 的过期时间\n\n\n\n\n\n\n\n\n\n*RDB 持久化过程\n\n\n\n\n对于 Redis 默认的 RDB 持久化，在进行 bgsave 持久化时，redis-server 进程会 fork 出一个 bgsave 子进程，由该子进程以异步方式负责完成持久化。而在持久化过程中，redis-server进程不会阻塞，其会继续接收并处理用户的读写请求。\nbgsave 子进程的详细工作原理如下：\n由于子进程可以继承父进程的所有资源，且父进程不能拒绝子进程的继承权。所以，bgsave 子进程有权读取到 redis-server 进程写入到内存中的用户数据，使得将内存数据持久化到 dump.rdb 成为可能。\nbgsave 子进程在持久化时首先会将内存中的全量数据 copy 到磁盘中的一个 RDB 临时文件，copy 结束后，再将该文件 rename 为 dump.rdb，替换掉原来的同名文件。\n不过，在进行持久化过程中，如果 redis-server 进程接收到了用户写请求，则系统会将\n内存中发生数据修改的物理块 copy 出一个副本。等内存中的全量数据 copy 结束后，会再将副本中的数据 copy 到 RDB 临时文件。这个副本的生成是由于 Linux 系统的写时复制技术（Copy-On-Write）实现的。\n\n\n\n\n\n\n\n*写时复制技术（Copy-On-Write）\n原本在 Unix 系统中，当一个主进程通过 fork()系统调用创建子进程后，内核进程会复制主进程的整个内存空间中的数据，然后分配给子进程。这种方式存在的问题有以下几点：\n这个过程非常耗时\n这个过程降低了系统性能\n如果主进程修改了其内存数据，子进程副本中的数据是没有修改的。即出现了数据冗余，而冗余数据最大的问题是数据一致性无法保证。\n\n\n\n\n现代的 Linux 则采用了更为有效的方式：\n写时复制。子进程会继承父进程的所有资源，其中就包括主进程的内存空间。即子进程与父进程共享内存。只要内存被共享，那么该内存就是只读的（写保护的）。而写时复制则是在任何一方需要写入数据到共享内存时都会出现异常，此时内核进程就会将需要写入的数据 copy 出一个副本写入到另外一块非共享内存区域。\n\n\n\n\n\n\n\n\n\nAOF 持久化概述\nAOF，Append Only File，是指 Redis 将每一次的写操作都以日志的形式记录到一个 AOF文件中的持久化技术。当需要恢复内存数据时，将这些写操作重新执行一次，便会恢复到之前的内存数据状态。\n\n\n\nAOF 基础配置AOF 的开启appendonly yes# 默认情况下 AOF 持久化是没有开启的，通过修改配置文件中的 appendonly 属性为 yes可以开启。\n\n\n\n文件名配置appendfilename &quot;appendonly.aof&quot;\n\n\nRedis 7 在这里发生了重大变化。原来只有一个 appendonly.aof 文件，现在具有了三类多个文件：\n基本文件：可以是 RDF 格式也可以是 AOF 格式。其存放的内容是由 RDB 转为 AOF 当时内存的快照数据。该文件可以有多个。\n增量文件：以操作日志形式记录转为 AOF 后的写入操作。该文件可以有多个。\n清单文件：用于维护 AOF 文件的创建顺序，保障激活时的应用顺序。该文件只有一个。\n\n\n\n\n\n混合式持久化开启aof-use-rdb-preamble yes# 对于基本文件可以是 RDF 格式也可以是 AOF 格式。通过 aof-use-rdb-preamble 属性可以选择。其默认值为 yes，即默认 AOF 持久化的基本文件为 rdb 格式文件，也就是默认采用混合式持久化。\n\n\n\nAOF 文件目录配置appenddirname &quot;appendonlydir&quot;# 为了方便管理，可以专门为 AOF 持久化文件指定存放目录。目录名由 appenddirname属性指定，存放在 redis.conf 配置文件的 dir 属性指定的目录，默认为 Redis 安装目录。\n\n\n\nAOF 文件格式\nAOF 文件包含三类文件：基本文件、增量文件与清单文件。其中基本文件一般为 rdb 格式\n\n\n\nRedis 协议\n增量文件扩展名为.aof，采用 AOF 格式。AOF 格式其实就是 Redis 通讯协议格式，AOF持久化文件的本质就是基于 Redis 通讯协议的文本，将命令以纯文本的方式写入到文件中。\nRedis 协议规定，Redis 文本是以行来划分，每行以\\r\\n 行结束。每一行都有一个消息头，以表示消息类型。消息头由六种不同的符号表示，其意义如下：\n(+) 表示一个正确的状态信息\n(-) 表示一个错误信息\n(*) 表示消息体总共有多少行，不包括当前行\n($) 表示下一行消息数据的长度，不包括换行符长度\\r\\n\n(空) 表示一个消息数据\n(:) 表示返回一个数值\n\n\n\n\n\n查看 AOF 文件\n\n\n\n\n\nRDB 与 AOF 的取舍和选择RDB 与 AOF 的对比\n\n\n-\n优势\n不足\n\n\n\nRDB\nRDB 文件较小数据恢复较快\n数据安全性较差写时复制会降低性能RDB 文件可读性较差\n\n\nAOF\n数据安全性高AOF 文件可读性强\nAOF 文件较大写操作会影响性能数据恢复较慢\n\n\n\n\nRedis 持久化的取舍和选择\n官方推荐使用 RDB 与 AOF 混合式持久化。\n若对数据安全性要求不高，则推荐使用纯 RDB 持久化方式。\n不推荐使用纯 AOF 持久化方式。\n若 Redis 仅用于缓存，则无需使用任何持久化技术。\n\n\n\n\n\n\n\n学习备注\n\nRDB文件格式这块还有点模糊\n后续再参考其它教程看看情况\n\n\n&lt;font color=red&gt;&lt;/font&gt;&amp;emsp;&amp;emsp;\n\n\n\n","categories":["Database","Redis"],"tags":["Redis","Cache","Database"]},{"title":"Redis study notes","url":"/Redis-study-notes/","content":"NoSQL 简介\nNoSQL（“non-relational”， “Not Only SQL”），泛指非关系型的数据库。随着互联网 web2.0网站的兴起，传统的关系数据库在处理 web2.0 网站，特别是超大规模和高并发的 SNS 类型的 web2.0 纯动态网站已经显得力不从心，出现了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL 数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，特别是大数据应用难题。\n\n\n\n键值存储数据库\n就像 Map 一样的 key-value 对。典型代表就是 Redis。\n\n\n\n列存储数据库\n关系型数据库是典型的行存储数据库。其存在的问题是，按行存储的数据在物理层面占用的是连续存储空间，不适合海量数据存储。而按列存储则可实现分布式存储，适合海量存储。典型代表是 HBase。\n\n\n\n文档型数据库\n NoSQL 与关系型数据的结合，最像关系型数据库的 NoSQL。典型代表是 MongoDB。\n\n\n\n图形(Graph) 数据库\n用于存放一个节点关系的数据库，例如描述不同人间的关系。典型代表是 Neo4J。\n\n\n\n\n\n\n\nNoSQL VS 关系型数据库\n\n\n\n\n\n\n\n\nRedis 概述Redis 简介\nRedis，Remote Dictionary Server，远程字典服务，由意大利人 Salvatore Sanfilippo（又名 Antirez）开发，是一个使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、NoSQL 开源内存数据库，其提供多种语言的 API。从 2010 年 3 月 15 日起，Redis 的开发工作由 VMware 主持。从2013 年 5 月开始，Redis 的开发由 Pivotal 赞助。\n2008 年时 Salvatore Sanfilippo 自己开发一个叫 LLOOGG 的网站。\nRedis之所以称之为字典服务，是因为 Redis 是一个 key-value存储系统。支持存储的 value类型很多，包括 String(字符串)、List(链表)、Set(集合)、Zset(sorted set –有序集合)和 Hash（哈希类型）等。\nRedis 的国际知名用户有，Twitter、GitHub、Facebook 等，国内知名用户有，阿里巴巴、腾讯、百度、搜狐、优酷、美团、小米等。熟练使用和运维 Redis 已经成为开发运维人员的一个必备技能。\n\n\n\nRedis 的用途数据缓存\n客户端从 DBMS（Database Management System） 中查询出的数据首先写入到 Redis 中，后续无论哪个客户端再需要访问该数据，直接读取 Redis 中的即可，不仅减小了 RT（response time 简称RT，响应时间：从系统接收请求开始到返回响应之间的时间跨度），而且降低了 DBMS 的压力。\n\n\n\n\n\n\n根据 Redis 缓存的数据与 DBMS 中数据的同步性划分，缓存一般可划分为两类：实时同步缓存，与阶段性同步缓存。\n实时同步缓存是指，DBMS 中数据更新后，Redis 缓存中的存放的相关数据会被立即清除，以促使再有对该数据的访问请求到来时，必须先从 DBMS 中查询获取到最新数据，然后再写入到 Redis。\n阶段性同步缓存是指，Redis 缓存中的数据允许在一段时间内与 DBMS 中的数据不完全一致。而这个时间段就是这个缓存数据的过期时间。\n\n\n\nRedis 的特性\n能够做缓存的技术、中间件很多，例如，MyBatis 自带的二级缓存、Memched 等。之所以在生产中做缓存的产品几乎无一例外的会选择 Redis，是因为它有很多其它产品所不具备的特性。\n\n\n性能极高：Redis 读的速度可以达到 11w 次/s，写的速度可以达到 8w 次/s。\n\n\n之所以具有这么高的性能，因为以下几点原因：\n（1）Redis 的所有操作都是在内存中发生的。\n（2）Redis 是用 C 语言开发的。\n（3）Redis 源码非常精细（集性能与优雅于一身）。\n\n\n简单稳定：Redis 源码很少。早期版本只有 2w 行左右。从 3.0 版本开始，增加了集群功能，代码变为了 5w 行左右。\n持久化：Redis 内存中的数据可以进行持久化，其有两种方式：RDB 与 AOF。\n高可用集群：Redis 提供了高可用的主从集群功能，可以确保系统的安全性。\n丰富的数据类型：Redis 是一个 key-value 存储系统。支持存储的 value 类型很多，包括String(字符串)、List(链表)、Set(集合)、Zset(sorted set –有序集合)和 Hash（哈希类型）等，还有 BitMap、HyperLogLog、Geospatial 类型。\nBitMap：一般用于大数据量的二值性统计\nHyperLogLog：其是 Hyperlog Log，用于对数据量超级庞大的日志做去重统计\nGeospatial：地理空间，其主要用于地理位置相关的计算\n\n\n强大的功能：Redis 提供了数据过期功能、发布/订阅功能、简单事务功能，还支持 Lua脚本扩展功能。\n客户端语言广泛：Redis提供了简单的TCP通信协议，编程语言可以方便地的接入Redis。所以，有很多的开源社区、大公司等开发出了很多语言的 Redis 客户端。\n支持 ACL 权限控制：之前的权限控制非常笨拙。从 Redis6 开始引入了 ACL 模块，可以为不同用户定制不同的用户权限。\n\n\n\nACL，Access Control List，访问控制列表，是一种细粒度的权限管理策略，可以针对任意用户与组进行权限控制。目前大多数 Unix 系统与 Linux 2.6 版本已经支持 ACL 了。\nZookeeper 早已支持 ACL 了。\nUnix 与 Linux 系统默认使用是 UGO（User、Group、Other）权限控制策略，其是一种粗粒度的权限管理策略。\n\n\n\n支持多线程 IO 模型：Redis 之前版本采用的是单线程模型，从 6.0 版本开始支持了多线程模型。\n\n\n\n\nRedis 的IO模型\nRedis 客户端提交的各种请求是如何最终被 Redis 处理的？Redis 处理客户端请求所采用的处理架构，称为 Redis 的 IO 模型。不同版本的 Redis 采用的 IO 模型是不同的\n\n单线程模型\n对于 Redis 3.0 及其以前版本，Redis 的 IO 模型采用的是纯粹的单线程模型。即所有客户端的请求全部由一个线程处理。\n\n\n\n\n\n\nRedis 的单线程模型采用了多路复用技术。\n\n\n\n对于多路复用器的多路选择算法常见的有三种：select 模型、poll 模型、epoll 模型。\npoll 模型的选择算法：采用的是轮询算法。该模型对客户端的就绪处理是有延迟的\nepoll 模型的选择算法：采用的是回调方式。根据就绪事件发生后的处理方式的不同，又可分为 LT 模型与 ET 模型。\n\n\n\n\n\n每个客户端若要向 Redis 提交请求，都需要与 Redis 建立一个 socket 连接，并向事件分发器注册一个事件。一旦该事件发生就表明该连接已经就绪。而一旦连接就绪，事件分发器就会感知到，然后获取客户端通过该连接发送的请求，并将由该事件分发器所绑定的这个唯一的线程来处理。如果该线程还在处理多个任务，则将该任务写入到任务队列等待线程处理。\n\n之所以称为事件分发器，是因为它会根据不同的就绪事件，将任务交由不同的事件处理器去处理。\n\n\n混合线程模型\n从 Redis 4.0 版本开始，Redis 中就开始加入了多线程元素。处理客户端请求的仍是单线程模型，但对于一些比较耗时但又不影响对客户端的响应的操作，就由后台其它线程来处理。例如，持久化、对 AOF 的 rewrite、对失效连接的清理等。\n\n多线程模型\nRedis 6.0 版本，才是真正意义上的多线程模型。因为其对于客户端请求的处理采用的是多线程模型。\n\n\n\n\n\n\n多线程 IO 模型中的“多线程”仅用于接受、解析客户端的请求，然后将解析出的请求写入到任务队列。而对具体任务（命令）的处理，仍是由主线程处理。这样做使得用户无需考虑线程安全问题，无需考虑事务控制，无需考虑像 LPUSH/LPOP 等命令的执行顺序问题。\n\nRedis 的 IO 模型优缺点总结\n\n\n\n优点\n缺点\n\n\n\n单线程模型\n可维护性高，性能高。不存在并发读写情况，所以也就不存在执行顺序的不确定性，不存在线程切换开销，不存在死锁问题，不存在为了数据安全而进行的加锁/解锁开销。\n性能会受到影响，且由于单线程只能使用一个处理器，所以会形成处理器浪费。\n\n\n多线程模型\n其结合了多线程与单线程的优点，避开了它们的所有不足\n该模型没有显示不足。如果非要找其不足的话就是，其并非是一个真正意义上的“多线程”，因为真正处理“任务”的线程仍是单线程。所以，其对性能也是有些影响的。\n\n\n\n\n\n\n\n\nRedis 的安装与配置Redis 的安装安装前的准备工作\n服务器选择CentOS 7.x，需要安装 gcc、gcc-c++\n\n\n由于 Redis 是由 C/C++语言编写的，而从官网下载的 Redis 安装包是需要编译后才可安装的，所以对其进行编译就必须要使用相关编译器。对于 C/C++语言的编译器，使用最多的是gcc与gcc-c++，而这两款编译器在CentOS7中是没有安装的，所以首先要安装这两款编译器。\nGCC，GNU Compiler Collection，GNU 编译器集合。\n\nyum -y install gcc gcc-c++\n\n\n\n下载/上传 Redis 安装包cd /opt/wget https://github.com/redis/redis/archive/7.0.8.tar.gztar -zxvf 7.0.8.tar.gz[root@localhost opt]# ls7.0.8.tar.gz  redis-7.0.8\n\n\n\n编译\n编译过程是根据 Makefile 文件进行的，而 Redis 解压包中已经存在该文件了。所以可以直接进行编译了。\n\n[root@localhost /]# cd /opt/redis-7.0.8/[root@localhost redis-7.0.8]# lltotal 264-rw-rw-r--  1 root root  40942 Jan 17 00:40 00-RELEASENOTES-rw-rw-r--  1 root root     51 Jan 17 00:40 BUGS-rw-rw-r--  1 root root   5027 Jan 17 00:40 CODE_OF_CONDUCT.md-rw-rw-r--  1 root root   2634 Jan 17 00:40 CONTRIBUTING.md-rw-rw-r--  1 root root   1487 Jan 17 00:40 COPYINGdrwxrwxr-x  7 root root    119 Jan 17 00:40 deps-rw-rw-r--  1 root root     11 Jan 17 00:40 INSTALL-rw-rw-r--  1 root root    151 Jan 17 00:40 Makefile-rw-rw-r--  1 root root   6888 Jan 17 00:40 MANIFESTO-rw-rw-r--  1 root root  22441 Jan 17 00:40 README.md-rw-rw-r--  1 root root 106545 Jan 17 00:40 redis.conf-rwxrwxr-x  1 root root    279 Jan 17 00:40 runtest-rwxrwxr-x  1 root root    283 Jan 17 00:40 runtest-cluster-rwxrwxr-x  1 root root   1613 Jan 17 00:40 runtest-moduleapi-rwxrwxr-x  1 root root    285 Jan 17 00:40 runtest-sentinel-rw-rw-r--  1 root root   1695 Jan 17 00:40 SECURITY.md-rw-rw-r--  1 root root  14005 Jan 17 00:40 sentinel.confdrwxrwxr-x  4 root root   8192 Jan 17 00:40 srcdrwxrwxr-x 11 root root    199 Jan 17 00:40 tests-rw-rw-r--  1 root root   3055 Jan 17 00:40 TLS.mddrwxrwxr-x  8 root root   4096 Jan 17 00:40 utils\n\n[root@localhost redis-7.0.8]# make......    LINK redis-server    INSTALL redis-sentinel    CC redis-cli.o    CC redisassert.o    CC cli_common.o    LINK redis-cli    CC redis-benchmark.o    LINK redis-benchmark    INSTALL redis-check-rdb    INSTALL redis-check-aofHint: It&#x27;s a good idea to run &#x27;make test&#x27; ;)make[1]: Leaving directory `/opt/redis-7.0.8/src&#x27;[root@localhost redis-7.0.8]#\n\n\n\n安装\n在 Linux 中对于编译过的安装包执行 make install 进行安装\n\n[root@localhost redis-7.0.8]# make installcd src &amp;&amp; make installwhich: no python3 in (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin)make[1]: Entering directory `/opt/redis-7.0.8/src&#x27;    CC Makefile.depmake[1]: Leaving directory `/opt/redis-7.0.8/src&#x27;which: no python3 in (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin)make[1]: Entering directory `/opt/redis-7.0.8/src&#x27;Hint: It&#x27;s a good idea to run &#x27;make test&#x27; ;)    INSTALL redis-server    INSTALL redis-benchmark    INSTALL redis-climake[1]: Leaving directory `/opt/redis-7.0.8/src&#x27;[root@localhost redis-7.0.8]#\n\n\n至此，Redis安装完成。可以看到，共安装了三个组件：redis 服务器、客户端与一个性能测试工具 benchmark。\n\n查看 bin 目录\n安装完成后，打开/usr/local/bin 目录，可以看到出现了很多的文件。\n\n[root@localhost bin]# cd /usr/local/bin/[root@localhost bin]# lltotal 21560-rwxr-xr-x 1 root root    32592 Mar 26  2021 earlyoom-rwxr-xr-x 1 root root  5198152 Feb 24 07:07 redis-benchmarklrwxrwxrwx 1 root root       12 Feb 24 07:07 redis-check-aof -&gt; redis-serverlrwxrwxrwx 1 root root       12 Feb 24 07:07 redis-check-rdb -&gt; redis-server-rwxr-xr-x 1 root root  5411488 Feb 24 07:07 redis-clilrwxrwxrwx 1 root root       12 Feb 24 07:07 redis-sentinel -&gt; redis-server-rwxr-xr-x 1 root root 11427160 Feb 24 07:07 redis-server\n\n\n通过 echo $PATH 可以看到，/usr/local/bin 目录是存在于该系统变量中的，这样这些命令就可以在任意目录中执行了。\n\n[root@localhost bin]# echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\n\n\n\nRedis 启动与停止前台启动\n在任意目录执行redis-server命令即可启动Redis。这种启动方式会占用当前命令行窗口。\n\n[root@localhost bin]# redis-server6717:C 24 Feb 2023 07:13:54.221 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo6717:C 24 Feb 2023 07:13:54.221 # Redis version=7.0.8, bits=64, commit=00000000, modified=0, pid=6717, just started6717:C 24 Feb 2023 07:13:54.221 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf6717:M 24 Feb 2023 07:13:54.221 * monotonic clock: POSIX clock_gettime                _._           _.-``__ &#x27;&#x27;-._      _.-``    `.  `_.  &#x27;&#x27;-._           Redis 7.0.8 (00000000/0) 64 bit  .-`` .-```.  ```\\/    _.,_ &#x27;&#x27;-._ (    &#x27;      ,       .-`  | `,    )     Running in standalone mode |`-._`-...-` __...-.``-._|&#x27;` _.-&#x27;|     Port: 6379 |    `-._   `._    /     _.-&#x27;    |     PID: 6717  `-._    `-._  `-./  _.-&#x27;    _.-&#x27; |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;| |    `-._`-._        _.-&#x27;_.-&#x27;    |           https://redis.io  `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27; |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;| |    `-._`-._        _.-&#x27;_.-&#x27;    |  `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;      `-._    `-.__.-&#x27;    _.-&#x27;          `-._        _.-&#x27;              `-.__.-&#x27;6717:M 24 Feb 2023 07:13:54.221 # Server initialized6717:M 24 Feb 2023 07:13:54.221 # WARNING Memory overcommit must be enabled! Without it, a background save or replication may fail under low memory condition. Being disabled, it can can also cause failures without low memory condition, see https://github.com/jemalloc/jemalloc/issues/1328. To fix this issue add &#x27;vm.overcommit_memory = 1&#x27; to /etc/sysctl.conf and then reboot or run the command &#x27;sysctl vm.overcommit_memory=1&#x27; for this to take effect.6717:M 24 Feb 2023 07:13:54.222 * Ready to accept connections\n\n\n再开启一个会话窗口，可以查看到当前的 Redis 进程，默认端口号为 6379。\n\n[root@localhost ~]# ps -ef |grep redisroot      6717  2057  0 07:13 pts/2    00:00:00 redis-server *:6379root      6755  6726  0 07:14 pts/3    00:00:00 grep --color=auto redis\n\n\n\n命令式后台启动\n使用 nohub 命令，最后再添加一个&amp;符，可以使要启动的程序在后台以守护进程方式运行。这样的好处是，进程启动后不会占用一个会话窗口，且其还会在当前目录，即运行启动命令的当前目录中创建一个 nohup.out 文件用于记录 Redis 的操作日志。\n\nnohup redis-server &amp;\n\n\n\n配置式后台启动\n使用 nohup 命令可以使 Redis 后台启动，但每次都要键入 nohup 与&amp;符，比较麻烦。可以通过修改 Linux 中 Redis 的核心配置文件 redis.conf 达到后台启动的目的。redis.conf 文件在Redis 的安装目录根下。\n\nRedis 连接前配置绑定客户端 IP\nRedis 可以通过修改配置文件来限定可以访问自己的客户端 IP\n\n# bind 127.0.0.1 -::1# 以上设置（默认设置,未注释），只允许当前主机访问当前的 Redis，其它主机均不可访问。所以，如果不想限定访问的客户端，只需要将该行注释掉即可。\n\n\n\n关闭保护模式\n默认保护模式是开启的。其只允许本机的客户端访问，即只允许自己访问自己。但生产中应该关闭，以确保其它客户端可以连接 Redis。\n\nprotected-mode no\n\n\n\n设置访问密码\n为 Redis 设置访问密码，可以对要读/写 Redis 的用户进行身份验证。没有密码的用户可以登录 Redis，但无法访问。\n\nrequirepass redis\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n学习备注\n\n用途写的太单薄了，需要重构\n缓存划分\n\n\n&lt;font color=red&gt;&lt;/font&gt;&amp;emsp;&amp;emsp;\n\n\n\n","categories":["DataBase","NoSQL","Redis"],"tags":["Redis","NoSQL","DataBase"]},{"title":"《Java分布式架构设计与开发实战》study notes","url":"/%E3%80%8AJava%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E3%80%8Bstudy-notes/","content":"课程导学与学习指南\n课程内容设计（结合实际应用场景）\n\n\n\n\n\n\n内容兼具深度、广度\n\n\n\n\n\n\n\n\n\n\n\n\n\n硅步千里，分布式理论加强内功修炼本章节目标\n了解大型互联网系统演进\n掌握架构设计思想\n掌握CAP理论\n掌握BASE理论\n\n\n\n\n中国互联网发展历程\n1994 - 2000年:从四大门户到搜索\n2001-2009年:从搜索到社交化网络\n2010- 至今:移动互联网和自媒体\n\n\n\n\n\n单体应用架构到分布式架构的演进\n单体应用架构\nLinux+Apache+MySQL+PHP\n网站刚起步的时候，流量少。用一台服务器就可以满足\n\n\n应用服务与数据服务分离\n访问增加，带来更大压力\n增加配置解决临时问题\n从横向进行扩展，一分为多\n\n\n不同服务器配置要求不同\n\n\n\n\n服务器类型\n不同配置要求\n\n\n\n应用服务器\nCPU配置高\n\n\n数据库服务器\n磁盘IO快和稳，内存足够大\n\n\n文件服务器\n磁盘足够大\n\n\n\n开始引入缓存\n\n大量交易访问数据库压力增大，响应延迟\n给数据库减负，把请求在前面就处理完\n在数据库前面加入缓存\n\n\n应用服务器集群部署\n\n所有的请求直接打到负载均衡组件\n单台服务器 &gt;多台服务器\n软件: Apache / Nginx / HaProxy / LVS\n硬件:F5\n\n\n数据库的读写分离\n\n并非所有请求都操作缓存，且存在缓存失效场景，对数据库访问造成压力\n利用数据库主从复制机制，将读和写操作分开，进一步提升性能\n\n\n数据库访问模块\n\n对接多个数据源、处理读写分离、甚至分库分表等\n独立于应用程序存在的\nApache ShardingSphere\n\n\n内容分发网络 - CDN\n\nCDN服务进行资源加速\n\n把静态资源提前缓存到各地的边缘服务器\n可以有效地降低DDoS攻击\n\n\n全面分布式化\n\n随着规模不断发展产生数据越来越多，单文件件服务器、单数据库服务器也渐渐地达到瓶颈。利用集群化横向扩展解决问题\nHDFS、TFS、FastDFS\nNoSQL &amp; 搜索引擎\nLucene是一个搜索引擎的开发工具包:全文检索\nSolr和Elasticsearch它们是基于Lucene开发的\n常见的NoSQL有Mongodb和ELasticsearch\n\n\n\n\n单体应用面临诸多问题和挑战\n\n单体应用的代码膨胀，研发成本变高，难实现敏捷交付\n代码维护成本变高，开发人员交接困难\n测试成本变高，回归的工作量变大，给测试带来巨大工作量\n可扩展性差，技术升级时需考虑整体，无法单独调整\n\n\n“大而全的单体”拆分为多个“独立的应用”\n\n应用拆分和解耦\n\n对应用模块进行拆分之后，通过消息中间件进行交互\n此外还有异步处理应用解耦、流量削峰等作用\n\n\n常见的消息中间件\n\n\n\n\n\n消息中间件特性\n\n\n\n\nActiveMQ\n历史悠久，使用Java语言编写的，功能全面，基本上MQ的功能它都有，因此也比较复杂。\n\n\nRabbitMQ\n目前主流之一，跟Spring框架师出同门，因此Spring对RabbitMQ的支持最好\n\n\nKafka\n高性能方面比较有优势。但一开始是基于大吞吐量数据场景设计，在消息可靠性方面比较弱\n\n\nRocketMQ\n它相对前面几个，有后发优势，结合了各方优点综合能力比较好。\n\n\n\n模块拆分引发的问题\n代码冗余，多处相同的代码维护起来困难\n复杂度扩散\n共用一套数据库资源\n\n\n\n\n\n引入服务化架构SOA与微服务对比\n\n\n\n\n\n\n\nSOA\n微服务\n\n\n\n共同点\n都是在分布式环境下，以服务为中心的松耦合应用架构模式服务之间是通过定义明确的接口和协议来进行相互通信\n都是在分布式环境下，以服务为中心的松耦合应用架构模式服务之间是通过定义明确的接口和协议来进行相互通信\n\n\n目标\n解决的是异构系统的服务化\n解决互联网系统快速交付\n\n\n规模\n相对粗粒度\n细粒度\n\n\n适用性\n跨企业、大企业跨部门的复杂应用系统建设\n适合小型团队的持续化发布\n\n\n为快不破，分布式缓存提升系统性能\n\n\n\n\n\n学习备注\n1\n\n&lt;font color=red&gt;&lt;/font&gt;&amp;emsp;&amp;emsp;\n\n\n\n","categories":["distributed"],"tags":["distributed"]},{"title":"《Java设计模式精讲 Debug方式+内存分析》study notes","url":"/%E3%80%8AJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B2%BE%E8%AE%B2-Debug%E6%96%B9%E5%BC%8F-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E3%80%8Bstudy-notes/","content":"简单工厂类型与定义\n定义:由一个工厂对象决定创建出哪一种产品类的实例\n类型:创建型，但不属于GOF23种设计模式\n\n\n\n适用场景\n工厂类负责创建的对象比较少\n客户端(应用层)只知道传入工厂类的参数，对于如何创建对象(逻辑)不关心\n\n\n\n优点\n只需要传入一个正确的参数，就可以获取你所需要的对象而无须知道其创建细节\n\n\n\n缺点\n工厂类的职责相对过重，如果增加新的产品需要修改工厂类的判断逻辑，违背开闭原则\n\n\n\nCodingpublic abstract class Coder &#123;    public abstract void coding();&#125;public class Javaer extends Coder&#123;    @Override    public void coding() &#123;        System.out.println(&quot;I&#x27;m a Java programmer，I can use Java programming .&quot;);    &#125;&#125;public class Gopher extends Coder&#123;    @Override    public void coding() &#123;        System.out.println(&quot;I&#x27;m a Go programmer，I can use Go programming .&quot;);    &#125;&#125;public class CoderFactory &#123;    public static Coder createCoder(Class clazz) &#123;        Coder coder = null;        try &#123;            coder = (Coder) Class.forName(clazz.getName()).newInstance();        &#125; catch (InstantiationException e) &#123;            throw new RuntimeException(e);        &#125; catch (IllegalAccessException e) &#123;            throw new RuntimeException(e);        &#125; catch (ClassNotFoundException e) &#123;            throw new RuntimeException(e);        &#125;        return coder;    &#125;&#125;public class Tests &#123;    public static void main(String[] args) &#123;        Coder coder = CoderFactory.createCoder(Javaer.class);        coder.coding();        Coder coder1= CoderFactory.createCoder(Gopher.class);        coder1.coding();    &#125;&#125;\n\n\n\n源码分析java.util.Calendar\n\n\n\nch.qos.logback.classic.LoggerContext\n其中，既使用到了简单工厂又使用到了工厂方法模式\n\n\n\n\n\n\n\n工厂方法模式定义与类型\n定义:定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行\n类型:创建型\n\n\n\n适用场景\n创建对象需要大量重复的代码\n客户端(应用层)不依赖于产品类实例如何被创建、实现等细节\n一个类通过其子类来指定创建哪个对象\n\n\n\n优点\n用户只需要关心所需产品对应的工厂，无须关心创建细节\n加入新产品符合开闭原则，提高可扩展性\n\n\n\n缺点\n类的个数容易过多，增加复杂度\n增加了系统的抽象性和理解难度\n\n\n\nCodingpublic abstract class Coder &#123;    public abstract void coding();&#125;public class Gopher extends Coder &#123;    @Override    public void coding() &#123;        System.out.println(&quot;I&#x27;m a Go programmer，I can use Go programming .&quot;);    &#125;&#125;public class Javaer extends Coder &#123;    @Override    public void coding() &#123;        System.out.println(&quot;I&#x27;m a Java programmer，I can use Java programming .&quot;);    &#125;&#125;public abstract class CoderFactory &#123;    public abstract Coder createCoder();&#125;public class GopherFactory extends CoderFactory&#123;    @Override    public Coder createCoder() &#123;        return new Gopher();    &#125;&#125;public class JavaerFactory extends CoderFactory&#123;    @Override    public Coder createCoder() &#123;        return new Javaer();    &#125;&#125;public class Tests &#123;    public static void main(String[] args) &#123;        CoderFactory coderFactory = new JavaerFactory();        Coder coder = coderFactory.createCoder();        coder.coding();        CoderFactory coderFactory2 = new GopherFactory();        Coder coder2 = coderFactory2.createCoder();        coder2.coding();    &#125;&#125;\n\n\n\n源码分析\njdk源码中的 Collection类 Iterator&lt;E&gt; iterator();，就使用了工厂方法，Iterator是抽象产品。ArrayList中有具体实现。\n\npublic Iterator&lt;E&gt; iterator() &#123;    return new Itr();&#125;\n\n\njdk源码Luncher类中\n\nprivate static class Factory implements URLStreamHandlerFactory &#123;    private static String PREFIX = &quot;sun.net.www.protocol&quot;;    private Factory() &#123;    &#125;    public URLStreamHandler createURLStreamHandler(String var1) &#123;        String var2 = PREFIX + &quot;.&quot; + var1 + &quot;.Handler&quot;;        try &#123;            Class var3 = Class.forName(var2);            return (URLStreamHandler)var3.newInstance();        &#125; catch (ReflectiveOperationException var4) &#123;            throw new InternalError(&quot;could not load &quot; + var1 + &quot;system protocol handler&quot;, var4);        &#125;    &#125;&#125;\n\n\n\n\n\n\n\n抽象工厂模式定义与类型\n定义: 抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口\n无须指定它们具体的类\n类型:创建型\n\n\n\n适用场景\n客户端(应用层)不依赖于产品类实例如何被创建、实现等细节\n强调一系列相关的产品对象(属于同一产品族)一起使用创建对象需要大量重复的代码\n提供一个产品类的库，所有的产品以同样的接口出现从而使客户端不依赖于具体实现\n\n\n\n优点\n具体产品在应用层代码隔离，无须关心创建细节\n将一个系列的产品族统一到一起创建\n\n\n\n缺点\n规定了所有可能被创建的产品集合，产品族中扩展新的产品困难需要修改抽象工厂的接口\n增加了系统的抽象性和理解难度\n\n\n\n扩展产品等级结构与产品族\n\n\n\n\n\n\n\nCoding\n\n\n\n源码分析\njava.sql.connection\n\n\n\n\n\n\n\n建造者模式定义与类型\n定义: 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\n用户只需指定需要建造的类型就可以得到它们，建造过程及细节不需要知道\n类型:创建型\n\n\n\n适用场景\n如果一个对象有非常复杂的内部结构(很多属性)\n想把复杂对象的创建和使用分离\n\n\n\n优点\n封装性好，创建和使用分离\n扩展性好、建造类之间独立、一定程度上解耦\n\n\n\n缺点\n产生多余的Builder对象\n产品内部发生变化，建造者都要修改，成本较大\n\n\n\nCodingpublic class Computer &#123;    private String cpu;    private String ram;    private String usbCount;    private String keyboard;    private String display;    public Computer(ComputerBuilder computerBuilder) &#123;        this.cpu = computerBuilder.cpu;        this.ram = computerBuilder.ram;        this.usbCount = computerBuilder.usbCount;        this.keyboard = computerBuilder.keyboard;        this.display = computerBuilder.display;    &#125;    @Override    public String toString() &#123;        return &quot;Computer&#123;&quot; +                &quot;cpu=&#x27;&quot; + cpu + &#x27;\\&#x27;&#x27; +                &quot;, ram=&#x27;&quot; + ram + &#x27;\\&#x27;&#x27; +                &quot;, usbCount=&#x27;&quot; + usbCount + &#x27;\\&#x27;&#x27; +                &quot;, keyboard=&#x27;&quot; + keyboard + &#x27;\\&#x27;&#x27; +                &quot;, display=&#x27;&quot; + display + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;    public static class ComputerBuilder&#123;        private String cpu;        private String ram;        private String usbCount;        private String keyboard;        private String display;        public ComputerBuilder buildCpu(String cpu) &#123;            this.cpu=cpu;            return this;        &#125;        public ComputerBuilder buildRam(String ram) &#123;            this.ram=ram;            return this;        &#125;        public ComputerBuilder buildUsbCount(String usbCount) &#123;            this.usbCount=usbCount;            return this;        &#125;        public ComputerBuilder buildKeyboard(String keyboard) &#123;            this.keyboard=keyboard;            return this;        &#125;        public ComputerBuilder buildDisplay(String display) &#123;            this.display=display;            return this;        &#125;        public Computer build()&#123;            return new Computer(this);        &#125;    &#125;&#125;\n\npublic static void main(String[] args) &#123;    Computer computer = new Computer.ComputerBuilder().buildCpu(&quot;I7处理器&quot;).buildCpu(&quot;三星125&quot;).build();    System.out.println(computer);&#125;\n\n\n\n源码分析\njava.lang.StringBuilder\njava.lang.StringBuffer\norg.apache.ibatis.session.SqlSessionFactoryBuilder\n\n\n\n\n\n\n\n原型模式定义与类型\n定义: 指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象\n不需要知道任何创建的细节，不调用构造函数\n类型:创建型\n\n\n\n适用场景\n\n\n\n\n优点\n\n\n\n\n缺点\n\n\n\n\nCoding\n\n源码分析\n\n\n\n\n\n\n\n\n单例模式定义与类型\n\n\n\n\n适用场景\n\n\n\n\n优点\n\n\n\n\n缺点\n\n\n\n\nCoding\n\n源码分析\n\n\n\n\n\n\n\n\n外观模式\n\n\n\n\n\n学习备注\n\n源码分析这块是不是需要加强一下 ？\n建造者模式这块还是要好好熟悉手写一下，是否面向对象的知识需要好好补充\n\n\n&lt;font color=red&gt;&lt;/font&gt;&amp;emsp;&amp;emsp;\n\n\n\n","categories":["Design Pattern"],"tags":["Design Pattern"]},{"title":"《MySQL 必知必会》study notes","url":"/%E3%80%8AMySQL-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8Bstudy-notes/","content":"课前准备 (2讲)开篇词 | 在实战中学习，是解锁MySQL技能的最佳方法\n\n\n\n\n\n环境准备 | 带你安装MySQL和图形化管理工具Workbench\n\n\n\n\n\n学习备注\n1\n\n&lt;font color=red&gt;&lt;/font&gt;&amp;emsp;&amp;emsp;\n\n\n\n","categories":["DataBase","MySQL"],"tags":["DataBase","MySQL"]},{"title":"《Java分布式系统解决方案 掌握企业级分布式项目方案》study notes","url":"/%E3%80%8AJava%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E6%8E%8C%E6%8F%A1%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E9%A1%B9%E7%9B%AE%E6%96%B9%E6%A1%88%E3%80%8Bstudy-notes/","content":"玩转N种企业级解决方案，笑傲分布式开发\n分布式场景下解决方案和技术选型\n\n\n\n\n\n\n\n\n\n\nSpringCloud和分布式解决方案\nSpringCloud是分布式架构，一定需要分布式解决方案\n\n\n\n\n目标：掌握常见分布式场景中的解决方案\n\n\n\n\n\n\n\n分布式ID\n\n\n\n\n\n学习备注\n1\n\n&lt;font color=red&gt;&lt;/font&gt;&amp;emsp;&amp;emsp;\n\n\n\n","categories":["distributed"],"tags":["distributed"]},{"title":"《Redis 核心技术与实战》Study Notes","url":"/%E3%80%8ARedis-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8BStudy-Notes/","content":"开篇词 (1讲)开篇词 | 这样学Redis，才能技高一筹Redis 的坑\n使用 Redis 遇到的坑总的来说大致是以下四方面：\nCPU使用上的“坑”，例如数据结构的复杂度、跨CPU核的访问；\n内存使用上的“坑”，例如主从同步和AOF的内存竞争；\n存储持久化上的“坑”，例如在SSD上做快照的性能抖动；\n网络通信上的“坑”，例如多实例时的异常网络丢包。\n\n\n\n\n\n为什么懂得了一个个技术点，却依然用不好Redis？\n急于解决这些细微的问题，Redis 使用能力就很难得到质的提升。\n只关注零散的技术点，没有建立起一套完整的知识框架，缺乏系统观，但是，系统观其实是至关重要的。（在解决问题时，拥有了系统观，就意味着能有依据、有章法地定位和解决问题。）\n案例分析，把Redis的长尾延迟维持在一定阈值以下：\n\n\n首先，我对Redis的线程模型做了分析，我发现，对于单线程的Redis而言，任何阻塞性操作都会导致长尾延迟的产生。接着，我又开始寻找可能导致阻塞的关键因素，一开始想到的是网络阻塞，但随着对Redis网络框架的理解，我知道Redis网络IO使用了IO复用机制，并不会阻塞在单个客户端上。\n再后来，我又把目光转向了键值对数据结构、持久化机制下的fork调用、主从库同步时的AOF重写，以及缓冲区溢出等多个方面。绕了一大圈子之后，这条影响长尾延迟的“证据链”才得以形成。这样一来，我也系统地掌握了影响Redis性能的关键因素路径，之后再碰到类似的问题时，我就可以轻松解决了。\n\n\n\n高效地形成系统观？\n抓住主线，在自己的脑海中绘制一幅Redis全景知识图\n\nRedis知识全景图都包括：“两大维度，三大主线\n\n\n\n\n\n\n两大维度\n系统维度：\n\n了解Redis的各项关键技术的设计原理，这些能够为你判断和推理问题打下坚实的基础，而且，你还能从中掌握一些优雅的系统设计规范，例如run-to-complete模型、epoll网络模型，这些可以应用到你后续的系统开发实践中。\n\n\n应用维度\n\n应用场景驱动\n缓存和集群是Redis的两大广泛的应用场景。提到缓存场景，你肯定会想到缓存机制、缓存替换、缓存异常等一连串的问题。\n\n\n典型案例驱动\n只有特定的业务场景下（比如亿级访问压力场景）才会出现，并不是普遍现象。可以用“典型案例驱动”的方式学习了。我们可以重点解读一些对Redis的“三高”特性影响较大的使用案例，例如，多家大厂在万亿级访问量和万亿级数据量的情况下对Redis的深度优化，解读这些优化实践，非常有助于你透彻地理解Redis。而且，你还可以梳理一些方法论，做成Checklist，就像是一个个锦囊，之后当你遇到问题的时候，就可以随时拿出自己的“锦囊妙计”解决问题了。\n\n\n\n\n\n三大主线\n高性能主线，包括线程模型、数据结构、持久化、网络框架；\n高可靠主线，包括主从复制、哨兵机制；\n高可扩展主线，包括数据分片、负载均衡。\n\nRedis 问题画像图\n\n\n\n\n举个例子，如果你遇到了Redis的响应变慢问题，对照着这张图，你就可以发现，这个问题和Redis的性能主线相关，而性能主线又和数据结构、异步机制、RDB、AOF重写相关。找到了影响的因素，解决起来也就很容易了。\n\n\n在学习和使用的过程中，你完全可以根据你自己的方式，完善这张画像图，把你自己实践或掌握到的新知识点，按照“问题 –&gt; 主线 –&gt; 技术点”的方式梳理出来，放到这张图上。这样一来，你的积累越来越多，画像也会越来越丰富。以后在遇到问题的时候，就很容易解决了。\n\n\n\n课程是如何设计的？\n基础篇：打破技术点之间的壁垒，带你建立网状知识结构\n具体讲解数据结构、线程模型、持久化等\n\n\n\n\n实践篇：场景和案例驱动，取人之长，梳理出一套属于你自己的“武林秘籍”\n“案例”层面：介绍数据结构的合理使用、避免请求阻塞和抖动、避免内存竞争和提升内存使用效率\n“场景”层面：\n缓存场景：重点讲解缓存基本原理及淘汰策略，还有雪崩、穿透、污染等异常情况\n集群场景：围绕集群方案优化、数据一致性、高并发访问等问题，聊聊可行的解决方案。\n\n\n\n\n\n\n未来篇：具有前瞻性，解锁新特性\nRedis6 新特性\n以及当前业界对Redis的最新探索，这会让你拥有前瞻性视角，了解Redis的发展路线图，为未来的发展提前做好准备。\n\n\n\n\n\n总结\nRedis是一个非常优秀的系统，它在CPU使用、内存组织、存储持久化和网络通信这四大方面的设计非常经典，而这些，基本涵盖了一个优秀的后端系统工程师需要掌握的核心知识和关键技术。希望你通过这个课程的学习，成长为一名优秀的系统工程师。\n\n\n\n\n\n\n\n基础篇 (10讲)01 | 基本架构：一个键值数据库包含什么？概述\n更好的学习方式就是先建立起“系统观”：想要深入理解和优化Redis，就必须要对它的总体架构和关键模块有一个全局的认知，然后再深入到具体的技术点。\n经过这样一个过程，我们在实践中定位和解决问题时，就会轻松很多，而且你还可以把这个学习方式迁移到其他的学习活动上。彻底掌握这个学习思路，让自己的学习、工作效率更高。\n\n构造简单的键值数据库 SimpleKV\n我们只需要关注整体架构和核心模块。我们通过剖析这个最简单的键值数据库，来迅速抓住学习和调优Redis的关键。\n开始构造SimpleKV时，首先就要考虑里面可以存什么样的数据，对数据可以做什么样的操作，也就是数据模型和操作接口。\n才能明白 Redis，它到底能做什么，不能做什么呢？只有先搞懂它的数据模型和操作接口，我们才能真正把“这块好钢用在刀刃上”。\n\n可以存哪些数据？\n在对键值数据库进行选型时，一个重要的考虑因素是它支持的value类型。（例如，Memcached支持的value类型仅为String类型，而Redis支持的value类型包括了String、哈希表、列表、集合等。Redis能够在实际业务场景中得到广泛的应用，就是得益于支持多样化类型的value。）\n从使用的角度来说，不同value类型的实现，不仅可以支撑不同业务的数据需求，而且也隐含着不同数据结构在性能、空间效率等方面的差异，从而导致不同的value操作之间存在着差异。\n对于键值数据库而言，基本的数据模型是key-value模型\n在SimpleKV中，key是String类型，而value是基本数据类型\n从使用的角度来说，不同value类型的实现，不仅可以支撑不同业务的数据需求，而且也隐含着不同数据结构在性能、空间效率等方面的差异，从而导致不同的value操作之间存在着差异。\n理解了这背后的原理，我们才能在选择Redis value类型和优化Redis性能时，做到游刃有余。\n\n可以对数据做什么操作？\nSimpleKV需要支持的3种基本操作\n\nPUT：新写入或更新一个key-value对；\nGET：根据一个key读取相应的value值；\nDELETE：根据一个key删除整个key-value对。\n\n\n有些键值数据库的新写/更新操作叫SET。新写入和更新虽然是用一个操作接口，但在实际执行时，会根据key是否存在而执行相应的新写或更新流程。\n\n根据一段key的范围返回相应的value值。因此，PUT/GET/DELETE/SCAN是一个键值数据库的基本操作集合。\n\n实际业务场景通常还有更加丰富的需求（可以增加EXISTS操作接口，用于判断某个key是否存在）\n\n当一个键值数据库的value类型多样化时，就需要包含相应的操作接口。（Redis的value有列表类型，因此它的接口就要包括对列表value的操作）\n\n\n键值对保存在内存还是外存？\n\n\n-\n优点\n缺点\n\n\n\n保存在内存\n读写快，内存的访问速度一般都在百ns级别\n潜在的风险是一旦掉电，所有的数据都会丢失。\n\n\n保存在外存\n避免数据丢失\n限于磁盘的慢速读写（通常在几ms级别），键值数据库的整体性能会被拉低。\n\n\n\n如何进行设计选择，我们通常需要考虑键值数据库的主要应用场景。\n缓存场景下的数据需要能快速访问但允许丢失，那么，用于此场景的键值数据库通常采用内存保存键值数据。\n\n\nSimpleKV就采用内存保存键值数据。\nSimpleKV的基本组件（大体来说，一个键值数据库包括了访问框架、索引模块、操作模块和存储模块四部分）\n\n\n\n\n\n采用什么访问模式？常用的两种访问模式\n（1）通过函数库调用的方式供外部应用使用，比如，上图中的libsimplekv.so，就是以动态链接库的形式链接到我们自己的程序中，提供键值存储功能；\n（2）通过网络框架以Socket通信的形式对外提供键值对操作，这种形式可以提供广泛的键值存储服务。在上图中，我们可以看到，网络框架中包括Socket Server和协议解析。\n\n\n不同的键值数据库服务器和客户端交互的协议并不相同，我们在对键值数据库进行二次开发、新增功能时，必须要了解和掌握键值数据库的通信协议，这样才能开发出兼容的客户端。\n\n\n实际的键值数据库也基本采用上述两种方式，例如，RocksDB以动态链接库的形式使用，而Memcached和Redis则是通过网络框架访问。\n\nI/O模型设计\n通过网络框架提供键值存储服务，一方面扩大了键值数据库的受用面，但另一方面，也给键值数据库的性能、运行模型提供了不同的设计选择，带来了一些潜在的问题。\n举个例子，当客户端发送一个如下的命令后，该命令会被封装在网络包中发送给键值数据库：\n\nPUT &quot;hello&quot; &quot;world&quot;\n\n\n键值数据库网络框架接收到网络包，并按照相应的协议进行解析之后，就可以知道，客户端想写入一个键值对，并开始实际的写入流程。此时，我们会遇到一个系统设计上的问题，简单来说，就是网络连接的处理、网络请求的解析，以及数据存取的处理，是用一个线程、多个线程，还是多个进程来交互处理呢？该如何进行设计和取舍呢？我们一般把这个问题称为I/O模型设计。不同的I/O模型对键值数据库的性能和可扩展性会有不同的影响。\n举个例子，如果一个线程既要处理网络连接、解析请求，又要完成数据存取，一旦某一步操作发生阻塞，整个线程就会阻塞住，这就降低了系统响应速度。如果我们采用不同线程处理不同操作，那么，某个线程被阻塞时，其他线程还能正常运行。但是，不同线程间如果需要访问共享资源，那又会产生线程竞争，也会影响系统效率，这又该怎么办呢？所以，这的确是个“两难”选择，需要我们进行精心的设计。\n经常听说Redis是单线程，那么，Redis又是如何做到“单线程，高性能”的呢？\n\n\n\n如何定位键值对的位置？\nSimpleKV 需要查找所要操作的键值对是否存在，这依赖于键值数据库的索引模块。索引的作用是让键值数据库根据key找到相应value的存储位置，进而执行操作。\n索引的类型有很多：常见的有哈希表、B+树、字典树等\nMemcached和Redis采用哈希表作为key-value索引，而RocksDB则采用跳表作为内存中key-value的索引。\n一般而言，内存键值数据库（例如Redis）采用哈希表作为索引：原因在于，其键值数据基本都是保存在内存中的，而内存的高性能随机访问特性可以很好地与哈希表O(1)的操作复杂度相匹配。\nSimpleKV的索引根据key找到value的存储位置即可。\n对于Redis而言，它的value支持多种类型，当我们通过索引找到一个key所对应的value后，仍然需要从value的复杂结构（例如集合和列表）中进一步找到我们实际需要的数据，这个操作的效率本身就依赖于它们的实现结构。\nRedis采用一些常见的高效索引结构作为某些value类型的底层数据结构，这一技术路线为Redis实现高性能访问提供了良好的支撑。\n\n不同操作的具体逻辑是怎样的？\nSimpleKV的操作模块就实现了不同操作的具体逻辑：\n对于GET/SCAN操作而言，此时根据value的存储位置返回value值即可；\n对于PUT一个新的键值对数据而言，SimpleKV需要为该键值对分配内存空间；\n对于DELETE操作，SimpleKV需要删除键值对，并释放相应的内存空间，这个过程由分配器完成。\n\n\n\n如何实现重启后快速提供服务？\nSimpleKV采用了常用的内存分配器glibc的malloc和free，因此，SimpleKV并不需要特别考虑内存空间的管理问题。\n键值数据库的键值对通常大小不一，glibc的分配器在处理随机的大小内存块分配时，表现并不好。一旦保存的键值对数据规模过大，就可能会造成较严重的内存碎片问题。\n分配器是键值数据库中的一个关键因素。对于以内存存储为主的Redis而言，这点尤为重要。Redis的内存分配器提供了多种选择，分配效率也不一样\n\n\nSimpleKV重启后能快速重新提供服务，所以，在SimpleKV的存储模块中增加了持久化功能。\n鉴于磁盘管理要比内存管理复杂，SimpleKV就直接采用了文件形式，将键值数据通过调用本地文件系统的操作接口保存在磁盘上。\nSimpleKV只需要考虑何时将内存中的键值数据保存到文件中\n对于每一个键值对，SimpleKV都对其进行落盘保存（数据更加安全可靠，但性能受影响）\nSimpleKV只是周期性地把内存中的键值数据保存到文件中（避免写盘操作的性能影响，潜在代价是数据有丢失风险）\n\n\n\n小结\n\n\n\n\n从SimpleKV演进到Redis，有以下几个重要变化：\nRedis主要通过网络框架进行访问，而不再是动态库了，这也使得Redis可以作为一个基础性的网络服务进行访问，扩大了Redis的应用范围。\nRedis数据模型中的value类型很丰富，因此也带来了更多的操作接口，例如面向列表的LPUSH/LPOP，面向集合的SADD/SREM等。\nRedis的持久化模块能支持两种方式：日志（AOF）和快照（RDB），这两种持久化方式具有不同的优劣势，影响到Redis的访问性能和可靠性。\nSimpleKV是个简单的单机键值数据库，但是，Redis支持高可靠集群和高可扩展集群，因此，Redis中包含了相应的集群功能支撑模块。\n\n\n\n\n\n\n\n\n\n02 | 数据结构：快速的Redis有哪些慢操作？Redis为什么这么快，快在哪里呢？\n一个重要的表现：它接收到一个键值对操作后，能以微秒级别的速度找到数据，并快速完成操作。\n它是内存数据库，所有操作都在内存上完成，内存的访问速度本身就很快。\nRedis的 键值对是按一定的数据结构来组织的，操作键值对最终就是对数据结构进行增删改查操作，所以高效的数据结构是Redis快速处理数据的基础。\n底层数据结构一共有6种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。\n\n\n\n\n\n\n有些问题已经值得我们去考虑了：\n这些数据结构都是值的底层实现，键和值本身之间用什么结构组织？\n为什么集合类型有那么多的底层结构，它们都是怎么组织数据的，都很快吗？\n什么是简单动态字符串，和常用的字符串是一回事吗？\n\n\n\n键和值用什么结构组织？\n\n\n\n\n\n03 | 高性能IO模型：为什么单线程Redis能那么快？\n\n\n\n\n\n学习备注\n1\n\n&lt;font color=red&gt;&lt;/font&gt;&amp;emsp;&amp;emsp;\n\n\n\n","categories":["Database","Redis"],"tags":["Redis","Cache","Database"]},{"title":"《阿里新零售数据库设计与实战》study notes","url":"/%E3%80%8A%E9%98%BF%E9%87%8C%E6%96%B0%E9%9B%B6%E5%94%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8Bstudy-notes/","content":"前言\n从设计到落地，提升数据库“技术&amp;业务”综合能力\n相当于参与了真实项目的数据库设计[开发经验很难得]\n具备设计完整数据库平台的能力[设计思想要跟上]\n驾驭新零售数据库混合式集群[特别牛的技术]\n\n\n\n\n\n\n\n新零售是什么\n雷军：新零售是更高效率的零售，我们要从线上回到线下\n马云：线下与线上零售将深度结合，加上现代物流平台，构成未来的新零售\n商务部：以消费者为中心，以技术创新为驱动的零售模新式\n\n\n新零售线上业务仅是电商吗？\n\n\n线上业务不局限于电商，还包括了在线教育、医疗服务，以及金融业务等等\n\n\n新零售的线下业务\n\n\n利用云计算、大数据，以及人工智能技术，将客户分流到线下门店中，让用户体验到定制化的服务\n\n\n新零售平台构成\n\n\n\n\n\n\n\n\n\n前导知识Linux环境准备关闭SELinux\nSELinux是Linux2.6以上版本捆绑的一个安全模块\nSELinux配置复杂，容易跟其他程序冲突，所以建议关闭\n\nvi /etc/selinux/config# 设置SELINUX=disabled，重启系统\n\n\n\n替换yum源curl -o /etc/yum.repos.d/CentOS-Base.repo mirrors.163.com/.help/CentOS7-Base-163.repo# 更新缓存yum clean allyum makecache\n\n\n\n安装MySQL在线安装MySQL# 下载rpm文件yum localinstall https://repo.mysql.com//mysql80-community-release-el7-1.noarch.rpm# 安装MySQLyum install mysal-community-server -y\n\n\n\n本地安装MySQL\n离线下载安装\n\n# 下载MySQL压缩包文件，并上传到/root/mysql目录mysql-8.0.11-1.el7.x86 64.rpm-bundle.tartar xvf mysgl-8.0.11-1.el7.x86 64.rpm-bundle.tar\n\n# 安装第三方依赖包yum install perl -yyum install net-tools -y\n\n# 卸载系统自带的mariadbrpm -qa |grep mariadbrpm -e mariadb-libs-5.5.68-1.el7.x86_64 --nodeps# 安装MySQL程序包rpm -ivh mysql-community-common-8.0.11-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-8.0.11-1.el7.x86_64.rpmrpm -ivh mysql-community-client-8.0.11-1.el7.x86 64.rpmrpm -ivh mysql-community-server-8.0.11-1.el7.x86 64.rpm# 修改/var/lib/mysql目录访问权限chmod -R 777 /var/lib/mysql/# 初始化，初始化数据目录，生成必要的文件，生成root密码mysqld --initializechmod -R 777 /var/lib/mysql/*\n\n\n启动\n\n# 启动数据库# 在线安装使用：service mysql start# 离线本地安装使用：service mysqld start# 查看初始化密码grep&#x27;temporary password’ /var/log/mysqld.log\n\n\n修改root密码\n\n# 本地登录数据库mysql -u root -p# 修改root密码alter user user)) identified by &quot;abc123456&quot;;\n\n\n允许root远程登录\n\n# 允许远程使用root账户UPDATE user SET host = %&#x27; WHERE user =&#x27;root&#x27;;FLUSH PRIVILEGES;# 修改/etc/my.cnf文件character set server = utf8bind-address = 0.0.0.0\n\n\n系统防火墙开放3306端口\n\nfirewall-cmd--zone=public  --add-port=3306/tcp --permanentfirewall-cmd --reload\n\n\n\n业务数据库设计流程\n需求分析：根据用户的需求，分析出需要记录的数据\n概要设计：根据分析出的数据，设计ER图\n详细设计：将ER图转换成数据库模型图和数据表\n\n\n\n业务数据设计模型\n瀑布模型\n\n\n\n\n\n\n螺旋模型\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n学习备注\n1\n\n&lt;font color=red&gt;&lt;/font&gt;&amp;emsp;&amp;emsp;\n\n\n\n","categories":["DataBase","MySQL"],"tags":["DataBase","MySQL"]},{"title":"《深入浅出分布式技术原理》study notes","url":"/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E3%80%8Bstudy-notes/","content":"开篇词 (1讲)开篇词｜掌握好学习路径，分布式系统原来如此简单\n分布式系统，已经是互联网公司 IT 架构的事实标准\n是否能系统性地理解分布式系统是初级工程师和资深工程师之间最显著的差别\n\n学习路径的重要性\n在做架构设计和选型的时候，没有知识系统做支撑，不能系统性地思考，处理问题也没有十足的把握\n先要有分布式技术的一些实践和经验。经历一个分布式系统从小到大，从简单到复杂的完整演进过程。（这样可以对分布式系统有更全面、深刻的认知，熟悉分布式系统中每一个组件的设计原则，能够站在一个全局的角度，去思考分布式系统中各个组件之间的关联与取舍。对分布式系统也有清晰的知识脉络与理解）\n一定要有一条明确的学习路径，从最根本的原因出发\n多问自己为什么\n思考怎么做\n在技术理解与实践中反复横跳，才能由点成线\n在总结中抓住技术实现的关键点和系统脉络，不迷失于细节，才能连线成网\n\n\n\n课程设计\n首先，找到分布式系统中稳定不变的知识、原理和解决思路。比如注册发现的原理、故障处理的思路和 CAP 理论等等（分布式系统技术要点多，但万变不离其宗）\n其次，去繁从简。\n只聚焦于日常工作中接触最频繁的在线业务分布式系统，依据是否有状态将其分为“分布式计算”和“分布式存储”这两大部分，从简单到复杂依次介绍分布式系统的相关知识与原理\n\n\n\n\n\n\n\n学习计划\n专栏将分为四个递进的模块，学习计划如下\n\n概述篇\n学习一个知识应该先理解这个知识的来龙去脉，我们先讨论分布式系统产生的过程：它为什么会产生，产生后解决了什么问题，又带来了哪些新问题，遇到哪些方面的挑战。\n通过“概述篇”的学习，可以比较好地抓到分布式系统的脉络和关键点，有了很强的学习目标和路径，就不会迷失在各种系统和框架实现的细节中了。\n\n分布式计算篇\n从单机系统演进到分布式系统后，引入哪些新问题的角度，在技术原理层面一个一个讨论并解决这些问题。\n学习之后，可以在各种系统和场景中理解和运用它，并且知道在系统设计层面应该如何取舍。\n\n分布式存储篇\n分布式技术篇中的进阶篇，我们对计算进行分布式扩展后，再一起来讨论存储的分布式扩展。这里我们从简单到复杂，一起讨论数据分片、数据复制、分布式事务和一致性等相关的知识。\n掌握之后，再做架构设计时，你会发现思维的深度和广度都得到了提升。\n\n总结篇\n此时，已经对分布式系统的重要原理有了系统性地理解，这个时候，我们再一起来看分布式系统的发展历程和未来趋势。\n我们从分布式计算的角度，一起讨论分布式系统是怎么从单机系统演进到 Service Mesh的；还会从分布式存储的角度，一起讨论分布式系统是怎么从单机系统的 ACID 演进到NewSQL 的。\n\n\n这个专栏最大的价值就是能够系统性地解决你的问题，不需要花费大量的精力再进行一次低效的探索。\n\n参考资料\n[知乎：如何系统性的学习分布式系统?](如何系统性的学习分布式系统? - kylin的回答 - 知乎 https://www.zhihu.com/question/320812569/answer/1386491563)\n\n\n\n\n\n\n\n概述篇 (3讲)01｜导读：以前因后果为脉络，串起网状知识体系\n学习一个知识之前，比较好的方式是先理解它的前因后果：前因就是这个知识产生的过程中，它解决了什么问题，怎么样解决的。后果就是它的出现又带来了哪些新的问题，这样我们才能比较好地抓到它的脉络和关键点，不会一开始就迷失在细节中。\n\n\n\n前因：分布式系统解决了什么问题\n学习分布式之前，要解决的第一个问题就是：分布式系统解决了什么问题，怎么样解决的？\n\n分布式系统解决了单机性能瓶颈导致的成本问题\n解决了用户量和数据量爆炸性地增大导致的成本问题（必须寻找更经济的方案来处理和存储这些数据）\n满足了业务高可用的要求\n分布式系统解决了大规模软件系统的迭代效率和成本的问题\n\n\n在互联网时代，单机系统是无法解决成本、效率和高可用问题的\n\n\n\n分布式系统又是怎么解决单机系统面临的成本、效率和高可用的问题呢？\n分布式系统指的是由一组通过网络进行通信，为了完成共同的任务，而协调工作的计算机节点组成的系统（分布式系统是通过多工作节点，来解决单机系统面临的成本、效率和高可用问题的）\n\n\n\n\n分布式系统的发展是无法阻挡的技术大潮流\n\n\n如何理解分布式系统的出现，以及分布式系统在不同业务场景中的表现形式\n所以我们可以把分布式系统看成是单体系统的平民化和物美价廉的版本\n分布式系统在不同的业务场景中有着不同的表现形式\n流量路由策略加多副本部署（微服务是其中的一种架构形式）是无状态服务的分布式架构方案\nRedis Cluster 和 Codis 等方案实现了缓存的分布式化\nKubernetes 则完成了操作系统的分布式进化\nNoSQL 掀起了数据库分布式化的第一波浪潮，而 NewSQL 则推动着支持 ACID 的关系数据库的分布式化\n\n\n\n\n\n\n\n后果：如何思考和处理分布式系统引入的新问题\n分布式系统的出现也引入了分布式系统内部工作节点的协调问题，主要体现在分布式系统内部组件、实例之间，通过异步网络进行通信和协调的问题上。\n\n\n针对内部工作节点的协调问题，分布式系统是怎么做的？\n对于分布式计算（无状态）的情况，系统内部的协调需要做哪些工作\n怎么找到服务？（服务的注册与发现）\n怎么找到实例？（负载均衡与路由）\n怎么管理配置？（配置中心）\n怎么进行协同？（分布式锁）\n怎么确保请求只执行一次？（重试与幂等）\n怎么避免雪崩？（快速失败和降级机制（熔断、降级、限流等），弹性扩容机制）\n怎么监控告警和故障恢复？（完善分布式系统的监控（比如接口的时延和可用性等信息），分布式追踪 Trace ，模拟故障的混沌工程以及相关的告警等机制。同时做好故障恢复预案，确保在故障发生的时候，能够快速恢复故障。）\n\n\n分布式存储（有状态）的内部协调是怎么做的\n怎么进行协同？\n怎么做数据分片（单机系统是不可能存储所有数据的，所以需要解决怎么将数据按一定的规则，分别存储到不同的机器上这个问题，目前使用较多的方案是：Hash 和 Region 分片的策略，但是要注意了解一下它们的优缺点和各自的应用场景。）\n怎么做数据复制（为了满足系统的高可用要求，需要对数据做冗余处理）\n怎么做分布式事务\n\n\n\n\n\n\n\n系统学习\n从实践出发，研究目前比较常用的分布式系统的设计，HDFS 或者 GFS（分布式文件系统）、Kafka 和 Pulsar（分布式消息队列），Redis Cluster 和 Codis（分布式缓存），MySQL 的分库分表（传统关系型数据库的分布式方案），MongoDB 的 Replica Set 和Sharing 机制集（NoSQL 数据库），TiDB（NewSQL）以及一些微服务框架等\n\n从理论出发，研究分布式相关的论文（《Designing Data-IntensiveApplications》）\n\n\n\n为了更好地理解如何处理分布式系统引入的内部工作节点的协调问题，把它们总结为下面三类问题：\n路由问题\n\n\n分布式系统由单体系统拆分而来，必然会导致分布式系统内部，出现复杂的路由问题。路由问题主要是解决分布式系统内部各服务和实例之间的通信，我们可以将“怎么找到服务”和“怎么找到实例”等服务注册发现和负载均衡的问题，理解为正常情况下的路由问题，将“怎么做数据分片”的问题，理解为带状态的路由问题，将“怎么避免雪崩”涉及的熔断、降级等快速失败和降级机制，理解为异常情况下的路由问题。\n\n\n共识问题\n\n\n分布式系统的各个组件是运行在不同机器上的不同进程，因为程序总是需要按一定的逻辑有序地执行，所以需要一个办法，来协调分布式系统内部，已经各自为政的服务和实例，而共识就是讨论并解决这一类问题的，例如“怎么做数据复制”、“怎么做分布式事务”和“怎么做分布式锁”里，都会涉及共识问题。\n\n\n运维问题\n\n\n分布式系统相对于单体系统是非常碎片化的，如果还依靠人肉运维，在效率上是完全行不通的，所以催生了一系列自动化运维的工具和平台来解决这一类问题，例如“怎么管理配置”和“怎么监控告警和故障恢复”都涉及运维的问题。\n\n\n\n总结\n在学习新知识的时候，只有点、线结合，形成网状的知识体系\n\n\n\n\n\n\n\n\n\n02｜新的挑战：分布式系统是银弹吗？我看未必！\n要从根本上理解分布式系统的设计方法和原则，这就需要时刻谨记单体系统和分布式系统之间的差别\n从本质上来说，单体系统是以单进程的形式运行在一个计算机节点上，而分布式系统是以多进程的形式运行在多个计算机节点上，二者的本质差别导致了分布式系统面临着四个方面的新问题，分别是：故障处理、异步网络、时钟同步和共识协同。\n\n\n\n全部失败与部分失败\n单体服务系统中，在硬件正常的时候，对于一个确定的输入，总会得到一个确定的输出。就算是在内存、磁盘损坏等硬件异常的时候，对于一个确定的输入，计算机也会直接出现无法启动或崩溃的情况，而不是给出一个模棱两可或不正确的结果。\n这种全部失败的处理逻辑，会大大减轻用户使用计算机的心智负担，让我们明确地知道，如果系统内部发生了故障，计算机不会给出错误的结果，而是会全部崩溃。\n分布式系统由多个计算机节点组成，虽然每一个计算机节点都是全部失败的模型，但是如果系统中的某些节点出现宕机或者网络故障，整个分布式系统就会出现部分失败的情况\n在分布式系统中，我们需要接受部分失败。\n在分布式系统中，故障处理是软件设计的一个重要组成部分。我们需要时刻谨记节点宕机、网络分区等各种问题出现时，系统应该怎么正确处理，比如分布式系统在设计的时候，每一个组件都必须是高可用的。\n\n\n\n本地调用与远程调用\n单体系统内部几乎不依赖网络，但是网络却是架构分布式系统的根基。（单体系统和分布式系统对网络的依赖程度有非常明显的差别）\n\n在单机系统中，系统各个组件之间直接本地调用即可。在分布式系统中，不同的组件运行在不同的机器上，只能通过网络来进行调用，即远程调用。\n\n远程调用多依赖了网络这个通道，但是这却给系统带来了非常大的复杂性，其实主要原因还是网络本身的复杂性所导致的。\n\n单机系统的本地调用方式，我们可以理解为只要发起调用，调用操作就一定会执行，并且我们可以忽略调用方和被调用方之间的数据传递时间。\n\n务 A 通过网络远程调用服务 B 可能会出现哪些不确定的情况\n\n\n\n\n\n\n\n\n\n\n\n在这样的情况下，通常的做法是采用超时机制，请求方在发起请求后，设置一个超时时间，这样能确保请求方在超时时间内，一定能得到一个响应。如果在超时时间内，请求方得到了明确的响应，不论这个响应是被调用服务回复的，还是网络地址不可达等网络错误，调用方都可以根据响应结果一一来处理。\n\n如果请求在超时时间内没有收到任何响应，即响应超时，那么调用方将无法区分下面四种情况：\n\n\n\n\n\n\n\n\n\n\n\n在响应超时的情况下，如果调用方想确保这个请求被执行，只能重新发送刚刚的请求。但是，如果之前的请求只是在网络中延迟或者响应丢失了，例如上面 2、3 和 4 中描述的情况，重试操作会导致这个请求被多次执行；如果之前的请求在网络中丢失了，例如上面 1描述的情况，那么调用方不进行重试的话，这个请求就会出现一次都没有被执行过的情况。\n\n\n在分布式系统的设计中，我们要充分考虑通过网络进行远程调用导致的不确定性，比如在响应超时的情况下增加重试机制，确保请求能最少执行一次。在重试的时候增加幂等的机制，确保请求只被精确处理一次，并且对重试机制增加退避策略，确保系统不会因为重试导致雪崩。\n\n\n\n全局时钟与多个时钟\n计算机系统一般是通过石英钟来计算时间的，但是石英钟的振动频率会随着温度等原因变慢或变快，所以在运行时间比较长后，计算机系统的时间可能会发生比较大的误差，所以人们又增加了一组专门的时间服务器。我们可以认为这些时间服务器的时间是准确的，计算机系统通过网络定期获得时间服务器的时间，来调整本地时间，即网络时间协议（NTP）。我们可以通过下面的公式来计算当时的时间：本地时间 = 时间服务器的返回时间 + 时间服务器响应的网络时延\n网络时延是不可预测的，所以通过 NTP 我们依然无法获得准确的时间。\n一般的精度都是在几十毫秒的范围内。不过，这个精度对于单机系统来说是足够的\n计算机系统中，时间主要有两个作用\n第一个是记录事件发生的时间。这是一个绝对时间，是让我们来阅读和理解的\n第二个是记录事件之间的发生顺序，这是一个相对时间。\n\n\n在单机系统中，由于只有一个时钟，先执行的事件一定能获得更小的时间，通过本地时钟就可以确保全局事件之间顺序的正确性，所以单机系统是一个全局时钟的模型。\n\n\n分布式系统是由多台计算机节点组成的，每一个节点都有自己的时钟，并且计算机执行的速度非常快，在一个毫秒内可以做非常多的事情。在这种情况下，如果在每一个节点，都采用本地的时钟来记录事件的发生时间，然后基于多个节点上的事件按发生时间进行排序，就很容易出现时间穿越的问题:\n\n\n\n\n\n\n在多主复制的情况下，客户端 A 在主副本 1 修改了 x = 5，记录时间为 10 ms，但是该副本时间慢了 10 ms，所以实际时间为 20 ms。几乎同一时间，客户端 B 在主副本 2 修改了 x = 10，记录时间为 15 ms，但是该副本时间快了 10 ms，所以实际时间为 5ms。\n一般对于这种情况的处理策略是最后写入获胜（LWW），在数据合并的时候，如果按照主副本 1、2 的记录时间来处理的话，最终 x = 10，会导致主副本 1 的修改丢失。\n\n\n在分布式系统的设计中，我们一定要谨记系统中各个节点的本地时钟是存在误差的，不能依赖各自的时钟对事件进行排序。\n针对上面问题的解决思路:\n一个是回到单机系统的全局时钟的模式，所有节点对于需要排序的事件时间，不使用本地时钟的时间，而是去请求同一个时间服务器获得事件的发生时间，然后依据这个时间进行排序；\n另一个是 Google 在 Spanner 中使用的，通过 GPS 和原子钟实现 TrueTime API 来解决。\n\n\n\n\n\n一言堂与共识\n线程之间的同步操作：在计算机系统中，同时只允许一个线程操作某一个数据，和同时只允许一个线程执行某一个操作，如果不遵守这个规则，就可能会导致数据错误等不可预料的后果\n在单体系统中，需要协同的多个线程是属于同一个进程的，所以同步操作很简单，直接使用进程内的资源来做协同就可以了，比如锁、信号量等。对于这些线程来说，所有的同步操作都以进程的资源为准，就好像进程是一个一言堂的管理员，协同进程内部的所有线程之间的同步。\n分布式系统中各个组件都是独立的进程，运行在不同的机器上。所以，对于分布式系统来说，我们需要处理的是一个跨机器的多进程同步问题。\n方法：我们选择一个服务来做同步操作的管理者（我们称为同步服务），在多个进程间需要同步时，就到同步服务来请求一个锁，获得锁的进程就可以操作，其他的进程就必须等待。\n\n\n在做分布式系统设计的时候，我们必须要考虑到故障的存在，所以同步服务不能只有一个实例，它需要多个实例来保障它的高可用，那么同步服务应该由哪一个实例，来处理其他进程的同步请求呢？\n\n\n你可能会想通过配置直接指定一个，这确实解决了同步服务启动时的问题，但是如果被指定实例宕机了，接下来该由哪一个实例来继续处理同步请求呢？\n\n\n我们通过这些讨论，会发现问题依然没有解决，只是转移了，也就是将分布式系统的多进程同步问题变成了同步服务的选主问题。\n其实，这是一个共识问题，需要分布式系统中参与同步的进程之间能达成共识，目前我们是通过 Paxos 或者 Raft 这样的共识算法来解决问题的\n\n\n\n总结\n\n\n\n\n在不可靠的硬件上通过软件来容错，构建高可用的分布式系统。\n如何确保请求只被精确处理一次成为了分布式场景下新的挑战。\n如何对系统中的事件进行排序，变成分布式场景下新的挑战。\n单体系统的单进程、多线程的同步模型变成了跨机器的多进程同步模型，要解决这个问题，就需要分布式系统中参与同步的进程之间能达成共识。\n\n\n\n\n\n\n\n03｜CAP 理论：分布式场景下我们真的只能三选二吗？\n经过不断地思考，人们在实践分布式系统架构的时候，从系统可用性和数据一致性的权衡中总结出来了 CAP 理论，它是指导人们在面对架构分布式系统时，进行取舍的设计原则。同时，CAP 理论深刻影响着分布式系统的设计与发展，是我们在学习分布式系统时不能绕过的知识。\n\n\n\n什么是 CAP 理论\nCAP 理论是加州理工大学伯克利分校的 Eric Brewer 教授在 2000 年 7 月的 ACM PODC会议上首次提出的，它是 Eric Brewer 在 Inktomi 期间研发搜索引擎、分布式 Web 缓存时得出的关于数据一致性（ C：Consistency ）、服务可用性（ A：Availability ）、分区容错性（ P：Partition-tolerance ）的一个著名猜想：\n\n\nIt is impossible for a web service to provide the three following guarantees : Consistency, Availability and Partition-tolerance.\n\n\n在这个猜想提出的 2 年以后，来自麻省理工学院的 Seth Gilbert 和 Nancy Lynch 从理论上证明了 Eric Brewer 教授的 CAP 猜想是成立的，从此，CAP 理论在学术上正式成为了分布式领域公认的定理，并深刻影响着分布式系统的发展。\n\nCAP 理论告诉我们，一个分布式系统不可能同时满足数据一致性、服务可用性和分区容错性这三个基本需求，最多只能同时满足其中的两个。\n\n\n\n\n一致性（ C ）\nCAP 理论中的一致性是指强一致性（ Strong Consistency ），又叫线性一致性（Linearizable Consistency ），它要求多节点组成的分布式系统，能像单节点一样运作，如果一个写操作返回成功，那么之后的读请求都必须读到这个新数据；如果返回失败，那么所有的读操作都不能读到这个数据。\n其他的一致性级别\n序列一致性（ Sequential Consistency ）\n最终一致性（ Eventual Consistency ）\n……\n\n\n\n\n\n可用性（ A ）\n\n\n\n\n\n学习备注\n1\n\n&lt;font color=red&gt;&lt;/font&gt;&amp;emsp;&amp;emsp;\n\n\n\n","categories":["distributed"],"tags":["distributed"]},{"title":"《高并发 高性能 高可用 MySQL 实战》study notes","url":"/%E3%80%8A%E9%AB%98%E5%B9%B6%E5%8F%91-%E9%AB%98%E6%80%A7%E8%83%BD-%E9%AB%98%E5%8F%AF%E7%94%A8-MySQL-%E5%AE%9E%E6%88%98%E3%80%8Bstudy-notes/","content":"第1章 课程介绍问卷调查\n你真的搞懂MySQL底层原理了吗?\n你知道如何改善慢查询性能吗?\n你知道如何架设高性能集群吗?\n你知道未来数据库的发展趋势吗?\n\n\n\n\n以上，这些问题很重要! 因为\n工作中: MySQL高性能集群越来越流行\n面试中:深入考察MySQL原理、性能调优\n职业规划:需要根据技术发展方向选择职业路径\n\n\n\n\n\n精通MySQL，应该怎么学\n\n以技术原理作为坚实基础\n以真实场景作为学习环境\n以架构思维作为学习目标\n\n\n\n下面三点是课程主线：\n\n\n\n（1）从理论到实战\n从数据表逻辑结构，到优化数据表的性能\n从数据查询原理，到改善慢SQL性能\n从事务原理，到优化事务执行效率\n\n\n\n（2）从单点到集群\n从学习单点原理，到掌握集群原理\n从高性能单点，到高性能集群\n从单点快速部署，到集群快速部署\n\n\n\n（3）从现在到未来\n从5.x版本，到8.0版本\n从原生单体数据库，到原生分布式数据库\n从学习技术原理，到理解技术趋势\n\n\n\n什么是“三高”\n高并发：同时处理的事务数高\n高性能：事务/SQL的执行速度高\n高可用：系统可用时间高\n\n\n\n\n“三高”只是目的，不是手段。手段有：复制、扩展、切换\n\n\n\n复制\n目的:数据冗余\n手段: binlog传送\n收获:并发量提升、可用性提升\n问题:占用更多硬件资源\n\n\n\n扩展\n目的:扩展数据库容量\n手段:数据分片分库、分表\n收获:性能、并发量的提升\n问题:可能降低可用性\n\n\n\n切换\n目的:提高可用性\n手段:主从身份切换\n收获:并发量的提升\n问题:丢失切换时期数据\n\n\n\n“三高”的实现\n高并发:通过复制和拓展，将数据分散至多节点\n高性能:复制提升速度，拓展提升容量\n高可用:节点间身份切换保证随时可用\n\n\n\n\n“三高”的集群也是以单点的高性能作为保障的。学习“三高”之前，应该学习如何提高单点性能\n\n\n\n如何提升单点性能\n建表:表结构合理，索引高效\nB+树的数据结构与InnoDB的存储结构\nInnoDB行记录格式的历史与原理\n索引、数据约束、视图的注意事项\n\n\n查询:优化SQL语句，选择正确索引\n覆盖索引、索引下推、松散索引的原理与实战\n排序、随机选取、COUNT的优化方法\n索引失效时的排查方向\n\n\n更新:正确使用锁，合理优化事务\nMySQL和InnoDB日志体系\n全局锁、表锁、元数据锁、行锁、间隙锁\n死锁的原理与优化方法\n事务与MVCC的原理与性能优化\n\n\n\n\n\n未来数据库发展趋势\nMySQL8.0新特性\nNewSQL数据库\n新一代分布式数据库CockroachDB\n\n\n\n\n\n\n\n第2章 环境搭建\n准备CentOS7环境\n\n\n\n安装MySQL 5.7cd /installwget https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.33-1.el7.x86_64.rpm-bundle.tartar -xvf mysql-5.7.33-1.el7.x86_64.rpm-bundle.tarrpm -qa|grep  mariadbrpm -e --nodeps mariadb-libs-5.5.68-1.el7.x86_64rpm -ivh mysql-community-common-5.7.33-1.el7.x86_64.rpmrpm -ivh --force --nodeps  mysql-community-libs-5.7.33-1.el7.x86_64.rpmrpm -ivh mysql-community-client-5.7.33-1.el7.x86_64.rpmrpm -ivh --force --nodeps  mysql-community-server-5.7.33-1.el7.x86_64.rpmwhich mysql\n\n\n\nMySQL的启停systemctl status mysqld.servicesystemctl start mysqld.servicesystemctl stop mysqld.service\n\n\n\n初始化配置# 查询安装后的初始化密码grep &#x27;temporary password&#x27; /var/log/mysqld.log\n\nset password=password(&quot;Happy2023@&quot;);flush privileges;\n\nset global validate_password_policy=LOW;set global validate_password_length=4;set password=password(&quot;root&quot;);\n\n# 永久打开防火墙3306端口firewall-cmd --zone=public --add-port=3306/tcp --permanentfirewall-cmd --reload\n\nGRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;root&#x27; WITH GRANT OPTION;flush privileges;\n\n\n\n\n\n\n\n第3章 一个SQL语句如何执行\n有了电子表格，为什么还要数据库?\n\n\n\n数据库理论上没有行数上限。单机数据库若行数太多遇到性能问题，可以通过分库分表等技术解决\n数据库有完备的结构化查询语言 (SQL)。Excel结构化查询功能不如数据库强大\n数据库面向软件，提供软件接口。（Excel是文件级别的，直接面向终端用户）\n数据库事务是关系型数据库的核心优势。（Excel没有事务，无法做到不同人的工作同时进行）\n分布式 - 数据库的潜力巨大。数据库具有主备复制、高可用、分布式等形态。Excel天生是单体的，面向文件的\n\n\n\n电子表格面向个人，以文件为基础，拓展性差\n数据库面向软件，支持事务、拓展性好\n\n\n\n数据库软件的典型架构是怎样的?常见软件架构MVC 分层架构\n\n\n\n事件驱动架构\n\n\n\n管道-过滤器架构\n\n\n\n微核架构\n\n\n\nMySQL软件架构是怎样的？\nMySQL的软件架构\n\n\n\n\n\n\n以分层架构看MySQL架构\n\n\n\n\n\n\n以管道过滤器-架构看MySQL架构\n\n\n\n\n\n\n以微核-架构看MySQL架构\n\n\n\n\n\n\n软件工程当中有很多经典的架构设计\n大型软件往往不是使用单一的架构设计，而是多种混合\n研究问题要有清晰的视野，分清楚微观和宏观\n理论要灵活实践，不要死读书\n\n\n\n客户端怎样连接MySQL数据库客户端与MySQL的连接方式\nTCP/IP 连接\nTCP/IP 连接是MySQL在任何平台上都提供的连接方法\nTCP/IP是目前互联网最主流的网络连接方式\n\n\n命名管道\n命名管道:同一台服务器通讯 (Windows)\n命名管道开启方式:–enable-named-pipe\n\n\n共享内存\n服务端:配置-shared-memory\n客户端:配置-protocol=memory\n\n\nUNIX套接字\n服务端:配置-socket=/tmp/mysql.sock\n客户端:配置-S =/tmp/mysql.sock\n\n\n\n\n\nMySQL TCP通讯协议\n三次握手建立TCP连接\n认证连接\n服务端-&gt;客户端:发送握手初始化包\n客户端-&gt;服务端:发送验证\n服务端-&gt;客户端:认证结果消息\n\n\n认证通过之后，客户端开始与服务端之间交互\n客户端-&gt;服务端:发送命令包(Command Packet)\n服务端-&gt;客户端:发送回应包\n\n\n断开MySQL连接\n客户端-&gt;服务器:发送退出命令包\n\n\n四次握手断开TCP连接\n\n\n\n\nMySQL TCP 报文格式\n消息头:3字节报文长度、1字节序号\n消息体:1字节指令、其余为参数\n指令举例: 切换数据库(0x02)、查询命令(0x03)\n\n\n\n\n\n\n\n总结\nTCP/IP 连接是MySQL最常用的连接方式\nTCP/IP连接报文可以作为其他C/S架构的参考\n其他连接方式均限于本机连接，使用范围有限\n\n\n\n一个SQL语句是怎样执行的\n\n\n\n查询缓存\n之前执行过的语句会KV的形式缓存在内存中\n查询之前先查找之前执行过的相同语句\n不推荐使用缓存:数据表修改后，会删除所有相关缓存\n\n\n\n分析器\n分析器的作用是知道你要“干什么“\n先做词法分析，识别SQL语句中的关键字\n再做句法分析，判断SQL语句是否符合语法\n\n\n\n优化器\n优化器的作用是要知道“怎么做”\n优化器的主要工作是决定如何使用索引\n\n\n\n执行器\n执行器的主要工作是校验权限、调用存储引擎\n执行器首先校验此用户对目标数据有无权限\n执行器会以行为粒度，调用存储引擎，执行SQL\n在没有索引的情况下，执行器会循环查询所有行\n\n\n\n存储引擎\n存储引擎的任务是将执行器的指令落实在数据文件上\n不同存储引擎的原理和执行方法有很大不同\n\n\n\n总结\nSQL语句执行的过程涉及到了MySQL几乎所有的模块\n一个SQL语句是按照分析-优化-执行-落盘的步骤执行的\nMySQL8.0之后已经停用了缓存功能\n\n\n\n四种常见的MySQL存储引擎\nInnoDB\nMySQL5.5.5之后的默认存储引擎\n支持事务、外键\n支持崩溃修复能力和并发控制\n\n\nMyISAM\nMySQL 5.5.5之前的默认存储引擎\n插入数据快\n空间利用率高\n不支持事务\n\n\nMemory\n所有的数据都在内存中，速度快\n数据安全性差\n\n\nArchive\n数据压缩、空间利用率高\n插入速度快\n不支持索引，查询性能差\n\n\n\n\n\n总结\nInnoDB是目前最主流的存储引擎，适合各种互联网业务\n查询效率要求非常高的可以考虑MyISAM\n日志信息归档可以考虑Archive\n临时表可以考虑MEMORY\n\n\n\n\n\n\n\n第4章 如何建表更符合业务索引组织表(Index Organized Table)\n索引组织表不是一种“组织表“\n索引组织表是由索引“组织起来的”表\nInnoDB中，表都是根据主键顺序组织存放的\n\n\n\n\n\n\n\n学习备注\n\n大多数情况下，都应该举一反三，比如课程中讲的mysql架构，应该好好熟悉。但是还有呢对应的课程专门讲解mysql架构，所以在本门课程中，我们只需要熟悉最核心的知识，或者熟悉本门课程的知识即可，其它重要的知识点在其它课程中好好学习即可。所以学习其它知识、课程亦是如此。（把握每个课程的重点，各个击破。达到系统掌握整体的目的）\n注意识别课程中提到的知识，哪些是特别重要的，比如本门课程中，常见架构很重要，但是本门课并不专门讲解架构，所以应该后续找对应的课程，学习架构知识。\n课程提到的mysql架构、tcp连接，都是很重要的知识，需要再深入理解。（一些底层基础知识很重要）\n\n\n&lt;font color=red&gt;&lt;/font&gt;&amp;emsp;&amp;emsp;\n\n\n\n","categories":["DataBase","MySQL"],"tags":["DataBase","MySQL"]},{"title":"《高级Redis进阶课 解决Redis实际问题+掌握Redis6.x特性》Study Notes","url":"/%E3%80%8A%E9%AB%98%E7%BA%A7Redis%E8%BF%9B%E9%98%B6%E8%AF%BE-%E8%A7%A3%E5%86%B3Redis%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98-%E6%8E%8C%E6%8F%A1Redis6-x%E7%89%B9%E6%80%A7%E3%80%8BStudy-Notes/","content":"第1章 课程介绍为何Redis经久不衰？\n功能强大、丰富\n丰富的数据结构、主从、集群、持久化、模块化、哨兵\n能够支撑很多的互联网应用场景，比如缓存、分布式锁队列、集合、GEO.BitMap操作等\n\n\n持续改进\n高性能\n底层C语言编写，内存数据库，通讯采用epoll非阻塞I/O多路复用机制\n\n\n线程安全\n单线程-原子操作（高并发下数据安全）\n\n\n\n课程内容课程项目架构\n\n\n\n以问带学\n\n\n\n底层原理\n网络底层\n事务处理\n持久化原理\n主从复制原理\n哨兵机制\n分片存储原理\n\n\n\n底层算法\nSorted Set底层\nBitmap、Geo算法\n数据过期淘汰算法\nLeader选举流程\n槽位定位算法\n备份迁移及其算法\n\n\n\n性能提升方案\nKey与Value设计规范\n避免BigKey\n避免耗时操作\nPipeline管道操作\n连接池性能优化\n子进程的开销与优化\n\n\n\n故障解决方案\n数据延迟\n数据脏读\n数据抖动\n数据一致性\n热点数据存储\nRDB文件损坏\n\n\n\n怎么学\n对Redis有兴趣，但不懂如何和项目深度结合\n了解Redis日常操作，但不懂得Redis底层原理\n遇到Redis故障完全没有思路，不知如何解决\n\n\n\n\n\n\n\n第2章 Redis快速入门章节介绍[学习目标]1、了解Redis为什么能流行这么多年，高性能的原因2、掌握Redis环境安装以及配置3、了解微服务项目的构建以及SpringBoot开发\n\n\n[理论知识]1、缓存相关中间件 (Redis、 Memcache和Ehcache) 的比较2、对Redis的基本理解3、微服务相关概念\n\n\n[实际操作]1、Redis安装、配置以及启动2、Redis的基本命令3、数据库表结构设计4、SpringBoot&amp;SpringCloud项目搭建\n\n\nRedis介绍特点\n内存数据库，速度快，也支持数据的持久化\nRedis不仅仅支持简单的key-value类型的数据，同时还提供Lists、 Hashes、 Sets 、Sorted Sets 等多种数据结构的存储\nRedis支持数据的备份 (master-slave) 与集群 (分片存储)，以及拥有哨兵监控机制.\n支持事务\n\n\n\n优势\n性能极高 - Redis能读的速度是110000次/s，写的速度是81000次/s\n丰富的数据类型 - Redis支持 Strings、 Lists、 Hashes、Sets 、Sorted Sets 等数据类型操作\n原子操作 - Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行 (事务）\n丰富的特性 - Redis还支持 publish/subscribe,通知,key 过期等特性。\n\n\n\nRedis、Memcached、 Ehcache的区别\n这三个中间件都可以应用于缓存，但目前市面上使用Redis的场景会更多，更广泛，其原因是: Redis性能高、原子操作、支持多种数据类型，主从复制与哨兵监控，持久化操作等。\n\n\n\nRedis的高并发\n官方的bench-mark数据: 测试完成了50个并发执行100000个请求。设置和获取的值是一个256字节字符串。结果: 读的速度是110000次/s,写的速度是81000次/s。redis尽量少写多读，符合缓存的适用要求。单机redis支撑万级，如果10万+可以采用主从复制的模式。\n\n\n\n原理\nRedis是纯内存数据库，所以读取速度快。\nRedis使用的是非阻塞10，10多路复用，减少了线程切换时上下文的切换和竞争\nRedis采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争\nRedis存储结构多样化，不同的数据结构对数据存储进行了优化加快读取的速度\nRedis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大\n\n\n\nRedis的单线程原因\n不需要各种锁的性能消耗\n单线程多进程集群方案\nCPU消耗\n\n优劣\n单进程单线程优势\n代码更清晰，处理逻辑更简单\n不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗\n不存在多进程或者多线程导致的切换而消耗CPU\n\n\n单进程单线程弊端\n无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善\n\n\n\n\n\nI/O多路复用技术\nredis 采用网络I/O多路复用技术来保证在多连接的时候，系统的高吞吐量。\n\n\n\n版本说明\nRedis2.6\n键的过期时间支持毫秒\n从节点支持只读功能\n\n\nRedis2.8\n可以用bind命令绑定多个IP地址\n发布订阅添加了pub/sub\nRedis Sentinel第二版，相比于Redis2.6的Redis Sentinel，此版本已经变成生产可用\n\n\nRedis3.0 (里程碑)\n Redis最大的改动就是添加Redis的分布式实现Redis cluster。\n\n\nRedis3.2\n添加GEO相关功能。\n新的List编码类型: quicklist。\n\n\nRedis4.0 (重大改版)\n提供了模块系统，方便第三方开发者拓展Redis的功能\n提供了新的缓存剔除算法: LFU (Last Frequently Used)，并对已有算法进行了优化\n提供了非阻塞del和flushall/flushdb功能，有效解决删除了bigkey可能造成的Redis阻塞.\n提供了RDB-AOF混合持久化格式，充分利用了AOF和RDB各自优势。\n\n\nRedis5.0\n新的stream数据类型\n客户经常连接和断开连接时性能更好\n\n\nRedis6.0\n多线程I/O。多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程\n\n\n\n\n\nRedis软件安装下载解压wget -P /usr/local/src/ https://download.redis.io/releases/redis-6.0.9.tar.gzcd /usr/local/src/tar -zxvf redis-6.0.9.tar.gz\n\n\n\n确保环境依赖（升级 GCC）\n在编译 Redis 6 之前需要升级 gc 的版本，默认情况 yum 安装的 gcc 版本是 4.8.5，由于版本过低，在编译时会报如下错误。所以我们需要执行以下操作升级 GCC。\n\n# 安装 Sc1 源yum install -y centos-release-scl scl-utils-build# 安装 9 版本的 gcc、gcc-c++、gdb 工具链 (toolchian)yum install -y devtoolset-9-toolchain# 临时覆盖系统原有的 gcc 引用scl enable devtoolset-9 bash# 查看 gcc 当前版本gcc -v\n\n\n\n预编译cd /usr/local/src/redis-6.0.9/make\n\n\n\n安装mkdir -p /usr/local/redis-6.0.9cd /usr/local/src/redis-6.0.9/make PREFIX=/usr/local/redis-6.0.9 install\n\n\n\n创建软连接cd /usr/local/ln -s redis-6.0.9/ redis\n\n\n\nRedis的启动前台启动cd /usr/local/redisbin/redis-server\n\n\n\n后台启动cp /usr/local/src/redis-6.0.9/redis.conf /usr/local/redis/bin/cd /usr/local/redis/bin/vim redis.conf# 修改以守护进程方式启动daemonize yes# 使用配置文件，后台启动cd /usr/local/redis/bin/./redis-server redis.conf\n\n\n\n配置开机启动 (centos7及以上)# 在系统服务目录里创建redis.service文件vim /etc/systemd/system/redis.service# 写入以下内容:[Unit]Description=redis-serverAfter=network.target[Service]Type=forkingExecStart=/usr/local/redis/bin/redis-server /usr/local/redis/bin/redis.confPrivateTmp=true[Install]WantedBy=multi-user.target# 重载系统服务systemctl daemon-reload# 关闭redis-server: systemctl stop redis.servicesystemctl start redis.servicesystemctl status redis.service# 开启成功，将服务加入开机自启systemctl enable redis.service\n\n\n\nRedis的配置\n\n\n\n\n\n学习备注\n1\n\n&lt;font color=red&gt;&lt;/font&gt;&amp;emsp;&amp;emsp;\n\n\n\n","categories":["Database","Redis"],"tags":["Redis","Cache","Database"]}]