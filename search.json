[{"title":"《Java分布式架构设计与开发实战》study notes","url":"/%E3%80%8AJava%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E3%80%8Bstudy-notes/","content":"课程导学与学习指南\n课程内容设计（结合实际应用场景）\n\n\n\n\n\n\n内容兼具深度、广度\n\n\n\n\n\n\n\n\n\n\n\n\n\n硅步千里，分布式理论加强内功修炼本章节目标\n了解大型互联网系统演进\n掌握架构设计思想\n掌握CAP理论\n掌握BASE理论\n\n\n\n\n中国互联网发展历程\n1994 - 2000年:从四大门户到搜索\n2001-2009年:从搜索到社交化网络\n2010- 至今:移动互联网和自媒体\n\n\n\n\n\n单体应用架构到分布式架构的演进\n单体应用架构\nLinux+Apache+MySQL+PHP\n网站刚起步的时候，流量少。用一台服务器就可以满足\n\n\n应用服务与数据服务分离\n访问增加，带来更大压力\n增加配置解决临时问题\n从横向进行扩展，一分为多\n\n\n不同服务器配置要求不同\n\n\n\n\n服务器类型\n不同配置要求\n\n\n\n应用服务器\nCPU配置高\n\n\n数据库服务器\n磁盘IO快和稳，内存足够大\n\n\n文件服务器\n磁盘足够大\n\n\n\n开始引入缓存\n\n大量交易访问数据库压力增大，响应延迟\n给数据库减负，把请求在前面就处理完\n在数据库前面加入缓存\n\n\n应用服务器集群部署\n\n所有的请求直接打到负载均衡组件\n单台服务器 &gt;多台服务器\n软件: Apache / Nginx / HaProxy / LVS\n硬件:F5\n\n\n数据库的读写分离\n\n并非所有请求都操作缓存，且存在缓存失效场景，对数据库访问造成压力\n利用数据库主从复制机制，将读和写操作分开，进一步提升性能\n\n\n数据库访问模块\n\n对接多个数据源、处理读写分离、甚至分库分表等\n独立于应用程序存在的\nApache ShardingSphere\n\n\n内容分发网络 - CDN\n\nCDN服务进行资源加速\n\n把静态资源提前缓存到各地的边缘服务器\n可以有效地降低DDoS攻击\n\n\n全面分布式化\n\n随着规模不断发展产生数据越来越多，单文件件服务器、单数据库服务器也渐渐地达到瓶颈。利用集群化横向扩展解决问题\nHDFS、TFS、FastDFS\nNoSQL &amp; 搜索引擎\nLucene是一个搜索引擎的开发工具包:全文检索\nSolr和Elasticsearch它们是基于Lucene开发的\n常见的NoSQL有Mongodb和ELasticsearch\n\n\n\n\n单体应用面临诸多问题和挑战\n\n单体应用的代码膨胀，研发成本变高，难实现敏捷交付\n代码维护成本变高，开发人员交接困难\n测试成本变高，回归的工作量变大，给测试带来巨大工作量\n可扩展性差，技术升级时需考虑整体，无法单独调整\n\n\n“大而全的单体”拆分为多个“独立的应用”\n\n应用拆分和解耦\n\n对应用模块进行拆分之后，通过消息中间件进行交互\n此外还有异步处理应用解耦、流量削峰等作用\n\n\n常见的消息中间件\n\n\n\n\n\n消息中间件特性\n\n\n\n\nActiveMQ\n历史悠久，使用Java语言编写的，功能全面，基本上MQ的功能它都有，因此也比较复杂。\n\n\nRabbitMQ\n目前主流之一，跟Spring框架师出同门，因此Spring对RabbitMQ的支持最好\n\n\nKafka\n高性能方面比较有优势。但一开始是基于大吞吐量数据场景设计，在消息可靠性方面比较弱\n\n\nRocketMQ\n它相对前面几个，有后发优势，结合了各方优点综合能力比较好。\n\n\n\n模块拆分引发的问题\n代码冗余，多处相同的代码维护起来困难\n复杂度扩散\n共用一套数据库资源\n\n\n\n\n\n引入服务化架构SOA与微服务对比\n\n\n\n\n\n\n\nSOA\n微服务\n\n\n\n共同点\n都是在分布式环境下，以服务为中心的松耦合应用架构模式服务之间是通过定义明确的接口和协议来进行相互通信\n都是在分布式环境下，以服务为中心的松耦合应用架构模式服务之间是通过定义明确的接口和协议来进行相互通信\n\n\n目标\n解决的是异构系统的服务化\n解决互联网系统快速交付\n\n\n规模\n相对粗粒度\n细粒度\n\n\n适用性\n跨企业、大企业跨部门的复杂应用系统建设\n适合小型团队的持续化发布\n\n\n为快不破，分布式缓存提升系统性能\n\n\n\n\n\n学习备注\n1\n\n&lt;font color=red&gt;&lt;/font&gt;&amp;emsp;&amp;emsp;\n\n\n\n","categories":["distributed"],"tags":["distributed"]},{"title":"Redis study notes","url":"/Redis-study-notes/","content":"Redis 概述NoSQL 简介\nNoSQL（“non-relational”， “Not Only SQL”），泛指非关系型的数据库。随着互联网 web2.0网站的兴起，传统的关系数据库在处理 web2.0 网站，特别是超大规模和高并发的 SNS 类型的 web2.0 纯动态网站已经显得力不从心，出现了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL 数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，特别是大数据应用难题。\n\n键值存储数据库\n\nRedis 简介\nRedis，Remote Dictionary Server，远程字典服务，由意大利人 Salvatore Sanfilippo（又名 Antirez）开发，是一个使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、NoSQL 开源内存数据库，其提供多种语言的 API。从 2010 年 3 月 15 日起，Redis 的开发工作由 VMware 主持。从2013 年 5 月开始，Redis 的开发由 Pivotal 赞助。\n2008 年时 Salvatore Sanfilippo 自己开发一个叫 LLOOGG 的网站。\nRedis之所以称之为字典服务，是因为 Redis 是一个 key-value存储系统。支持存储的 value类型很多，包括 String(字符串)、List(链表)、Set(集合)、Zset(sorted set –有序集合)和 Hash（哈希类型）等。\nRedis 的国际知名用户有，Twitter、GitHub、Facebook 等，国内知名用户有，阿里巴巴、腾讯、百度、搜狐、优酷、美团、小米等。熟练使用和运维 Redis 已经成为开发运维人员的一个必备技能。\n\n\n\n\n\nRedis 的用途Redis 的特性\n能够做缓存的技术、中间件很多，例如，MyBatis 自带的二级缓存、Memched 等。只所以在生产中做缓存的产品几乎无一例外的会选择 Redis，是因为它有很多其它产品所不具备的特性。\n\n\n性能极高：Redis 读的速度可以达到 11w 次/s，写的速度可以达到 8w 次/s。\n\n\n之所以具有这么高的性能，因为以下几点原因：\n（1）Redis 的所有操作都是在内存中发生的。\n（2）Redis 是用 C 语言开发的。\n（3）Redis 源码非常精细（集性能与优雅于一身）。\n\nRedis 的IO模型\nRedis 客户端提交的各种请求是如何最终被 Redis 处理的？Redis 处理客户端请求所采用的处理架构，称为 Redis 的 IO 模型。不同版本的 Redis 采用的 IO 模型是不同的\n\n\n\n单线程模型\n对于 Redis 3.0 及其以前版本，Redis 的 IO 模型采用的是纯粹的单线程模型。即所有客户端的请求全部由一个线程处理。\n\n\n\n\n\n\n\nRedis 的安装与配置\n\n\n\n\n\n学习备注\n1\n\n&lt;font color=red&gt;&lt;/font&gt;&amp;emsp;&amp;emsp;\n\n\n\n","categories":["DataBase","NoSQL","Redis"],"tags":["Redis","NoSQL","DataBase"]},{"title":"《Java分布式系统解决方案 掌握企业级分布式项目方案》study notes","url":"/%E3%80%8AJava%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E6%8E%8C%E6%8F%A1%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E9%A1%B9%E7%9B%AE%E6%96%B9%E6%A1%88%E3%80%8Bstudy-notes/","content":"\n\n\n\n\n\n学习备注\n1\n\n&lt;font color=red&gt;&lt;/font&gt;&amp;emsp;&amp;emsp;\n\n\n\n"},{"title":"《Java设计模式精讲 Debug方式+内存分析》study notes","url":"/%E3%80%8AJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B2%BE%E8%AE%B2-Debug%E6%96%B9%E5%BC%8F-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E3%80%8Bstudy-notes/","content":"简单工厂类型与定义\n定义:由一个工厂对象决定创建出哪一种产品类的实例\n类型:创建型，但不属于GOF23种设计模式\n\n\n\n适用场景\n工厂类负责创建的对象比较少\n客户端(应用层)只知道传入工厂类的参数，对于如何创建对象(逻辑)不关心\n\n\n\n优点\n只需要传入一个正确的参数，就可以获取你所需要的对象而无须知道其创建细节\n\n\n\n缺点\n工厂类的职责相对过重，如果增加新的产品需要修改工厂类的判断逻辑，违背开闭原则\n\n\n\nCodingpublic abstract class Coder &#123;    public abstract void coding();&#125;public class Javaer extends Coder&#123;    @Override    public void coding() &#123;        System.out.println(&quot;I&#x27;m a Java programmer，I can use Java programming .&quot;);    &#125;&#125;public class Gopher extends Coder&#123;    @Override    public void coding() &#123;        System.out.println(&quot;I&#x27;m a Go programmer，I can use Go programming .&quot;);    &#125;&#125;public class CoderFactory &#123;    public static Coder createCoder(Class clazz) &#123;        Coder coder = null;        try &#123;            coder = (Coder) Class.forName(clazz.getName()).newInstance();        &#125; catch (InstantiationException e) &#123;            throw new RuntimeException(e);        &#125; catch (IllegalAccessException e) &#123;            throw new RuntimeException(e);        &#125; catch (ClassNotFoundException e) &#123;            throw new RuntimeException(e);        &#125;        return coder;    &#125;&#125;public class Tests &#123;    public static void main(String[] args) &#123;        Coder coder = CoderFactory.createCoder(Javaer.class);        coder.coding();        Coder coder1= CoderFactory.createCoder(Gopher.class);        coder1.coding();    &#125;&#125;\n\n\n\n源码分析java.util.Calendar\n\n\n\nch.qos.logback.classic.LoggerContext\n其中，既使用到了简单工厂又使用到了工厂方法模式\n\n\n\n\n\n\n\n工厂方法模式定义与类型\n定义:定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行\n类型:创建型\n\n\n\n适用场景\n创建对象需要大量重复的代码\n客户端(应用层)不依赖于产品类实例如何被创建、实现等细节\n一个类通过其子类来指定创建哪个对象\n\n\n\n优点\n用户只需要关心所需产品对应的工厂，无须关心创建细节\n加入新产品符合开闭原则，提高可扩展性\n\n\n\n缺点\n类的个数容易过多，增加复杂度\n增加了系统的抽象性和理解难度\n\n\n\nCodingpublic abstract class Coder &#123;    public abstract void coding();&#125;public class Gopher extends Coder &#123;    @Override    public void coding() &#123;        System.out.println(&quot;I&#x27;m a Go programmer，I can use Go programming .&quot;);    &#125;&#125;public class Javaer extends Coder &#123;    @Override    public void coding() &#123;        System.out.println(&quot;I&#x27;m a Java programmer，I can use Java programming .&quot;);    &#125;&#125;public abstract class CoderFactory &#123;    public abstract Coder createCoder();&#125;public class GopherFactory extends CoderFactory&#123;    @Override    public Coder createCoder() &#123;        return new Gopher();    &#125;&#125;public class JavaerFactory extends CoderFactory&#123;    @Override    public Coder createCoder() &#123;        return new Javaer();    &#125;&#125;public class Tests &#123;    public static void main(String[] args) &#123;        CoderFactory coderFactory = new JavaerFactory();        Coder coder = coderFactory.createCoder();        coder.coding();        CoderFactory coderFactory2 = new GopherFactory();        Coder coder2 = coderFactory2.createCoder();        coder2.coding();    &#125;&#125;\n\n\n\n源码分析\njdk源码中的 Collection类 Iterator&lt;E&gt; iterator();，就使用了工厂方法，Iterator是抽象产品。ArrayList中有具体实现。\n\npublic Iterator&lt;E&gt; iterator() &#123;    return new Itr();&#125;\n\n\njdk源码Luncher类中\n\nprivate static class Factory implements URLStreamHandlerFactory &#123;    private static String PREFIX = &quot;sun.net.www.protocol&quot;;    private Factory() &#123;    &#125;    public URLStreamHandler createURLStreamHandler(String var1) &#123;        String var2 = PREFIX + &quot;.&quot; + var1 + &quot;.Handler&quot;;        try &#123;            Class var3 = Class.forName(var2);            return (URLStreamHandler)var3.newInstance();        &#125; catch (ReflectiveOperationException var4) &#123;            throw new InternalError(&quot;could not load &quot; + var1 + &quot;system protocol handler&quot;, var4);        &#125;    &#125;&#125;\n\n\n\n\n\n\n\n抽象工厂模式定义与类型\n\n\n\n\n\n学习备注\n1\n\n&lt;font color=red&gt;&lt;/font&gt;&amp;emsp;&amp;emsp;\n\n\n\n","categories":["Design Pattern"],"tags":["Design Pattern"]},{"title":"《阿里新零售数据库设计与实战》study notes","url":"/%E3%80%8A%E9%98%BF%E9%87%8C%E6%96%B0%E9%9B%B6%E5%94%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8Bstudy-notes/","content":"前言\n从设计到落地，提升数据库“技术&amp;业务”综合能力\n相当于参与了真实项目的数据库设计[开发经验很难得]\n具备设计完整数据库平台的能力[设计思想要跟上]\n驾驭新零售数据库混合式集群[特别牛的技术]\n\n\n\n\n\n\n\n新零售是什么\n雷军：新零售是更高效率的零售，我们要从线上回到线下\n马云：线下与线上零售将深度结合，加上现代物流平台，构成未来的新零售\n商务部：以消费者为中心，以技术创新为驱动的零售模新式\n\n\n新零售线上业务仅是电商吗？\n\n\n线上业务不局限于电商，还包括了在线教育、医疗服务，以及金融业务等等\n\n\n新零售的线下业务\n\n\n利用云计算、大数据，以及人工智能技术，将客户分流到线下门店中，让用户体验到定制化的服务\n\n\n新零售平台构成\n\n\n\n\n\n\n\n\n\n前导知识Linux环境准备关闭SELinux\nSELinux是Linux2.6以上版本捆绑的一个安全模块\nSELinux配置复杂，容易跟其他程序冲突，所以建议关闭\n\nvi /etc/selinux/config# 设置SELINUX=disabled，重启系统\n\n\n\n替换yum源curl -o /etc/yum.repos.d/CentOS-Base.repo mirrors.163.com/.help/CentOS7-Base-163.repo# 更新缓存yum clean allyum makecache\n\n\n\n安装MySQL在线安装MySQL# 下载rpm文件yum localinstall https://repo.mysql.com//mysql80-community-release-el7-1.noarch.rpm# 安装MySQLyum install mysal-community-server -y\n\n\n\n本地安装MySQL\n离线下载安装\n\n# 下载MySQL压缩包文件，并上传到/root/mysql目录mysql-8.0.11-1.el7.x86 64.rpm-bundle.tartar xvf mysgl-8.0.11-1.el7.x86 64.rpm-bundle.tar\n\n# 安装第三方依赖包yum install perl -yyum install net-tools -y\n\n# 卸载系统自带的mariadbrpm -qa |grep mariadbrpm -e mariadb-libs-5.5.68-1.el7.x86_64 --nodeps# 安装MySQL程序包rpm -ivh mysql-community-common-8.0.11-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-8.0.11-1.el7.x86_64.rpmrpm -ivh mysql-community-client-8.0.11-1.el7.x86 64.rpmrpm -ivh mysql-community-server-8.0.11-1.el7.x86 64.rpm# 修改/var/lib/mysql目录访问权限chmod -R 777 /var/lib/mysql/# 初始化，初始化数据目录，生成必要的文件，生成root密码mysqld --initializechmod -R 777 /var/lib/mysql/*\n\n\n启动\n\n# 启动数据库# 在线安装使用：service mysql start# 离线本地安装使用：service mysqld start# 查看初始化密码grep&#x27;temporary password’ /var/log/mysqld.log\n\n\n修改root密码\n\n# 本地登录数据库mysql -u root -p# 修改root密码alter user user)) identified by &quot;abc123456&quot;;\n\n\n允许root远程登录\n\n# 允许远程使用root账户UPDATE user SET host = %&#x27; WHERE user =&#x27;root&#x27;;FLUSH PRIVILEGES;# 修改/etc/my.cnf文件character set server = utf8bind-address = 0.0.0.0\n\n\n系统防火墙开放3306端口\n\nfirewall-cmd--zone=public  --add-port=3306/tcp --permanentfirewall-cmd --reload\n\n\n\n业务数据库设计流程\n需求分析：根据用户的需求，分析出需要记录的数据\n概要设计：根据分析出的数据，设计ER图\n详细设计：将ER图转换成数据库模型图和数据表\n\n\n\n业务数据设计模型\n瀑布模型\n\n\n\n\n\n\n螺旋模型\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n学习备注\n1\n\n&lt;font color=red&gt;&lt;/font&gt;&amp;emsp;&amp;emsp;\n\n\n\n","categories":["DataBase","MySQL"],"tags":["DataBase","MySQL"]},{"title":"Linux 常用基础操作","url":"/Linux-%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/","content":"前言SELinux\nSELinux是Linux2.6以上版本捆绑的一个安全模块\nSELinux配置复杂，容易跟其他程序冲突，所以建议关闭\n\n\n关闭SELinux\n\nvim /etc/selinux/config# 设置SELINUX=disabled，重启系统\n\n\n\n\n\n\n\nyum\n替换yum源\n\ncurl -o /etc/yum.repos.d/CentOS-Base.repo mirrors.163.com/.help/CentOS7-Base-163.repo# 更新缓存yum clean allyum makecache\n\n\n\n\n\n\n\nLinux防火墙\n\n\n\n\n\n学习备注\n1\n\n&lt;font color=red&gt;&lt;/font&gt;&amp;emsp;&amp;emsp;\n\n\n\n","categories":["Linux"],"tags":["Linux"]},{"title":"《高并发 高性能 高可用 MySQL 实战》study notes","url":"/%E3%80%8A%E9%AB%98%E5%B9%B6%E5%8F%91-%E9%AB%98%E6%80%A7%E8%83%BD-%E9%AB%98%E5%8F%AF%E7%94%A8-MySQL-%E5%AE%9E%E6%88%98%E3%80%8Bstudy-notes/","content":"第1章 课程介绍问卷调查\n你真的搞懂MySQL底层原理了吗?\n你知道如何改善慢查询性能吗?\n你知道如何架设高性能集群吗?\n你知道未来数据库的发展趋势吗?\n\n\n\n\n以上，这些问题很重要! 因为\n工作中: MySQL高性能集群越来越流行\n面试中:深入考察MySQL原理、性能调优\n职业规划:需要根据技术发展方向选择职业路径\n\n\n\n\n\n精通MySQL，应该怎么学\n\n以技术原理作为坚实基础\n以真实场景作为学习环境\n以架构思维作为学习目标\n\n\n\n下面三点是课程主线：\n\n\n\n（1）从理论到实战\n从数据表逻辑结构，到优化数据表的性能\n从数据查询原理，到改善慢SQL性能\n从事务原理，到优化事务执行效率\n\n\n\n（2）从单点到集群\n从学习单点原理，到掌握集群原理\n从高性能单点，到高性能集群\n从单点快速部署，到集群快速部署\n\n\n\n（3）从现在到未来\n从5.x版本，到8.0版本\n从原生单体数据库，到原生分布式数据库\n从学习技术原理，到理解技术趋势\n\n\n\n什么是“三高”\n高并发：同时处理的事务数高\n高性能：事务/SQL的执行速度高\n高可用：系统可用时间高\n\n\n\n\n“三高”只是目的，不是手段。手段有：复制、扩展、切换\n\n\n\n复制\n目的:数据冗余\n手段: binlog传送\n收获:并发量提升、可用性提升\n问题:占用更多硬件资源\n\n\n\n扩展\n目的:扩展数据库容量\n手段:数据分片分库、分表\n收获:性能、并发量的提升\n问题:可能降低可用性\n\n\n\n切换\n目的:提高可用性\n手段:主从身份切换\n收获:并发量的提升\n问题:丢失切换时期数据\n\n\n\n“三高”的实现\n高并发:通过复制和拓展，将数据分散至多节点\n高性能:复制提升速度，拓展提升容量\n高可用:节点间身份切换保证随时可用\n\n\n\n\n“三高”的集群也是以单点的高性能作为保障的。学习“三高”之前，应该学习如何提高单点性能\n\n\n\n如何提升单点性能\n建表:表结构合理，索引高效\nB+树的数据结构与InnoDB的存储结构\nInnoDB行记录格式的历史与原理\n索引、数据约束、视图的注意事项\n\n\n查询:优化SQL语句，选择正确索引\n覆盖索引、索引下推、松散索引的原理与实战\n排序、随机选取、COUNT的优化方法\n索引失效时的排查方向\n\n\n更新:正确使用锁，合理优化事务\nMySQL和InnoDB日志体系\n全局锁、表锁、元数据锁、行锁、间隙锁\n死锁的原理与优化方法\n事务与MVCC的原理与性能优化\n\n\n\n\n\n未来数据库发展趋势\nMySQL8.0新特性\nNewSQL数据库\n新一代分布式数据库CockroachDB\n\n\n\n\n\n\n\n第2章 环境搭建\n准备CentOS7环境\n\n\n\n安装MySQL 5.7cd /installwget https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.33-1.el7.x86_64.rpm-bundle.tartar -xvf mysql-5.7.33-1.el7.x86_64.rpm-bundle.tarrpm -qa|grep  mariadbrpm -e --nodeps mariadb-libs-5.5.68-1.el7.x86_64rpm -ivh mysql-community-common-5.7.33-1.el7.x86_64.rpmrpm -ivh --force --nodeps  mysql-community-libs-5.7.33-1.el7.x86_64.rpmrpm -ivh mysql-community-client-5.7.33-1.el7.x86_64.rpmrpm -ivh --force --nodeps  mysql-community-server-5.7.33-1.el7.x86_64.rpmwhich mysql\n\n\n\nMySQL的启停systemctl status mysqld.servicesystemctl start mysqld.servicesystemctl stop mysqld.service\n\n\n\n初始化配置# 查询安装后的初始化密码grep &#x27;temporary password&#x27; /var/log/mysqld.log\n\nset password=password(&quot;Happy2023@&quot;);flush privileges;\n\nset global validate_password_policy=LOW;set global validate_password_length=4;set password=password(&quot;root&quot;);\n\n# 永久打开防火墙3306端口firewall-cmd --zone=public --add-port=3306/tcp --permanentfirewall-cmd --reload\n\nGRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;root&#x27; WITH GRANT OPTION;flush privileges;\n\n\n\n\n\n\n\n第3章 一个SQL语句如何执行\n有了电子表格，为什么还要数据库?\n\n\n\n数据库理论上没有行数上限。单机数据库若行数太多遇到性能问题，可以通过分库分表等技术解决\n数据库有完备的结构化查询语言 (SQL)。Excel结构化查询功能不如数据库强大\n数据库面向软件，提供软件接口。（Excel是文件级别的，直接面向终端用户）\n数据库事务是关系型数据库的核心优势。（Excel没有事务，无法做到不同人的工作同时进行）\n分布式 - 数据库的潜力巨大。数据库具有主备复制、高可用、分布式等形态。Excel天生是单体的，面向文件的\n\n\n\n电子表格面向个人，以文件为基础，拓展性差\n数据库面向软件，支持事务、拓展性好\n\n\n\n数据库软件的典型架构是怎样的?常见软件架构MVC 分层架构\n\n\n\n事件驱动架构\n\n\n\n管道-过滤器架构\n\n\n\n微核架构\n\n\n\nMySQL软件架构是怎样的？\nMySQL的软件架构\n\n\n\n\n\n\n以分层架构看MySQL架构\n\n\n\n\n\n\n以管道过滤器-架构看MySQL架构\n\n\n\n\n\n\n以微核-架构看MySQL架构\n\n\n\n\n\n\n软件工程当中有很多经典的架构设计\n大型软件往往不是使用单一的架构设计，而是多种混合\n研究问题要有清晰的视野，分清楚微观和宏观\n理论要灵活实践，不要死读书\n\n\n\n客户端怎样连接MySQL数据库客户端与MySQL的连接方式\nTCP/IP 连接\nTCP/IP 连接是MySQL在任何平台上都提供的连接方法\nTCP/IP是目前互联网最主流的网络连接方式\n\n\n命名管道\n命名管道:同一台服务器通讯 (Windows)\n命名管道开启方式:–enable-named-pipe\n\n\n共享内存\n服务端:配置-shared-memory\n客户端:配置-protocol=memory\n\n\nUNIX套接字\n服务端:配置-socket=/tmp/mysql.sock\n客户端:配置-S =/tmp/mysql.sock\n\n\n\n\n\nMySQL TCP通讯协议\n三次握手建立TCP连接\n认证连接\n服务端-&gt;客户端:发送握手初始化包\n客户端-&gt;服务端:发送验证\n服务端-&gt;客户端:认证结果消息\n\n\n认证通过之后，客户端开始与服务端之间交互\n客户端-&gt;服务端:发送命令包(Command Packet)\n服务端-&gt;客户端:发送回应包\n\n\n断开MySQL连接\n客户端-&gt;服务器:发送退出命令包\n\n\n四次握手断开TCP连接\n\n\n\n\nMySQL TCP 报文格式\n消息头:3字节报文长度、1字节序号\n消息体:1字节指令、其余为参数\n指令举例: 切换数据库(0x02)、查询命令(0x03)\n\n\n\n\n\n\n\n总结\nTCP/IP 连接是MySQL最常用的连接方式\nTCP/IP连接报文可以作为其他C/S架构的参考\n其他连接方式均限于本机连接，使用范围有限\n\n\n\n一个SQL语句是怎样执行的\n\n\n\n查询缓存\n之前执行过的语句会KV的形式缓存在内存中\n查询之前先查找之前执行过的相同语句\n不推荐使用缓存:数据表修改后，会删除所有相关缓存\n\n\n\n分析器\n分析器的作用是知道你要“干什么“\n先做词法分析，识别SQL语句中的关键字\n再做句法分析，判断SQL语句是否符合语法\n\n\n\n优化器\n优化器的作用是要知道“怎么做”\n优化器的主要工作是决定如何使用索引\n\n\n\n执行器\n执行器的主要工作是校验权限、调用存储引擎\n执行器首先校验此用户对目标数据有无权限\n执行器会以行为粒度，调用存储引擎，执行SQL\n在没有索引的情况下，执行器会循环查询所有行\n\n\n\n存储引擎\n存储引擎的任务是将执行器的指令落实在数据文件上\n不同存储引擎的原理和执行方法有很大不同\n\n\n\n总结\nSQL语句执行的过程涉及到了MySQL几乎所有的模块\n一个SQL语句是按照分析-优化-执行-落盘的步骤执行的\nMySQL8.0之后已经停用了缓存功能\n\n\n\n四种常见的MySQL存储引擎\nInnoDB\nMySQL5.5.5之后的默认存储引擎\n支持事务、外键\n支持崩溃修复能力和并发控制\n\n\nMyISAM\nMySQL 5.5.5之前的默认存储引擎\n插入数据快\n空间利用率高\n不支持事务\n\n\nMemory\n所有的数据都在内存中，速度快\n数据安全性差\n\n\nArchive\n数据压缩、空间利用率高\n插入速度快\n不支持索引，查询性能差\n\n\n\n\n\n总结\nInnoDB是目前最主流的存储引擎，适合各种互联网业务\n查询效率要求非常高的可以考虑MyISAM\n日志信息归档可以考虑Archive\n临时表可以考虑MEMORY\n\n\n\n\n\n\n\n第4章 如何建表更符合业务索引组织表(Index Organized Table)\n索引组织表不是一种“组织表“\n索引组织表是由索引“组织起来的”表\nInnoDB中，表都是根据主键顺序组织存放的\n\n\n\n\n\n\n\n学习备注\n\n大多数情况下，都应该举一反三，比如课程中讲的mysql架构，应该好好熟悉。但是还有呢对应的课程专门讲解mysql架构，所以在本门课程中，我们只需要熟悉最核心的知识，或者熟悉本门课程的知识即可，其它重要的知识点在其它课程中好好学习即可。所以学习其它知识、课程亦是如此。（把握每个课程的重点，各个击破。达到系统掌握整体的目的）\n注意识别课程中提到的知识，哪些是特别重要的，比如本门课程中，常见架构很重要，但是本门课并不专门讲解架构，所以应该后续找对应的课程，学习架构知识。\n课程提到的mysql架构、tcp连接，都是很重要的知识，需要再深入理解。（一些底层基础知识很重要）\n\n\n&lt;font color=red&gt;&lt;/font&gt;&amp;emsp;&amp;emsp;\n\n\n\n","categories":["DataBase","MySQL"],"tags":["DataBase","MySQL"]},{"title":"《MySQL 必知必会》study notes","url":"/%E3%80%8AMySQL-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8Bstudy-notes/","content":"课前准备 (2讲)开篇词 | 在实战中学习，是解锁MySQL技能的最佳方法\n\n\n\n\n\n环境准备 | 带你安装MySQL和图形化管理工具Workbench\n\n\n\n\n\n学习备注\n1\n\n&lt;font color=red&gt;&lt;/font&gt;&amp;emsp;&amp;emsp;\n\n\n\n","categories":["DataBase","MySQL"],"tags":["DataBase","MySQL"]}]