<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ratears</title>
  
  <subtitle>ratears&#39;s blog</subtitle>
  <link href="https://ratears.github.io/dev.ratears.life/atom.xml" rel="self"/>
  
  <link href="https://ratears.github.io/dev.ratears.life/"/>
  <updated>2023-03-03T14:04:16.000Z</updated>
  <id>https://ratears.github.io/dev.ratears.life/</id>
  
  <author>
    <name>ratears</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mybatis Study Notes（1）：Mybatis Inroduction</title>
    <link href="https://ratears.github.io/dev.ratears.life/Mybatis-Study-Notes%EF%BC%881%EF%BC%89%EF%BC%9AMybatis-Inroduction/"/>
    <id>https://ratears.github.io/dev.ratears.life/Mybatis-Study-Notes%EF%BC%881%EF%BC%89%EF%BC%9AMybatis-Inroduction/</id>
    <published>2023-03-03T14:04:16.000Z</published>
    <updated>2023-03-03T14:04:16.000Z</updated>
    
    <content type="html"><![CDATA[<br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><p>1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;br&gt;

&lt;br&gt;

&lt;br&gt;

&lt;h1 id=&quot;学习备注&quot;&gt;&lt;a href=&quot;#学习备注&quot; class=&quot;headerlink&quot; title=&quot;学习备注&quot;&gt;&lt;/a&gt;学习备注&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>《高级Redis进阶课 解决Redis实际问题+掌握Redis6.x特性》Study Notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/%E3%80%8A%E9%AB%98%E7%BA%A7Redis%E8%BF%9B%E9%98%B6%E8%AF%BE-%E8%A7%A3%E5%86%B3Redis%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98-%E6%8E%8C%E6%8F%A1Redis6-x%E7%89%B9%E6%80%A7%E3%80%8BStudy-Notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/%E3%80%8A%E9%AB%98%E7%BA%A7Redis%E8%BF%9B%E9%98%B6%E8%AF%BE-%E8%A7%A3%E5%86%B3Redis%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98-%E6%8E%8C%E6%8F%A1Redis6-x%E7%89%B9%E6%80%A7%E3%80%8BStudy-Notes/</id>
    <published>2023-03-03T02:54:21.000Z</published>
    <updated>2023-03-03T02:54:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h1><h2 id="为何Redis经久不衰？"><a href="#为何Redis经久不衰？" class="headerlink" title="为何Redis经久不衰？"></a>为何Redis经久不衰？</h2><ul><li>功能强大、丰富<ul><li>丰富的数据结构、主从、集群、持久化、模块化、哨兵</li><li>能够支撑很多的互联网应用场景，比如缓存、分布式锁队列、集合、GEO.BitMap操作等</li></ul></li><li>持续改进</li><li>高性能<ul><li>底层C语言编写，内存数据库，通讯采用epoll非阻塞I/O多路复用机制</li></ul></li><li>线程安全<ul><li>单线程-原子操作（高并发下数据安全）</li></ul></li></ul><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><h3 id="课程项目架构"><a href="#课程项目架构" class="headerlink" title="课程项目架构"></a>课程项目架构</h3><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/e7208bb05b39a307ee763120d570664.685ja194n3w0.webp" width="70%"><br><h3 id="以问带学"><a href="#以问带学" class="headerlink" title="以问带学"></a>以问带学</h3><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.54s59g6nhpg0.webp" width="70%"><br><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><ul><li>网络底层</li><li>事务处理</li><li>持久化原理</li><li>主从复制原理</li><li>哨兵机制</li><li>分片存储原理</li></ul><br><h3 id="底层算法"><a href="#底层算法" class="headerlink" title="底层算法"></a>底层算法</h3><ul><li>Sorted Set底层</li><li>Bitmap、Geo算法</li><li>数据过期淘汰算法</li><li>Leader选举流程</li><li>槽位定位算法</li><li>备份迁移及其算法</li></ul><br><h3 id="性能提升方案"><a href="#性能提升方案" class="headerlink" title="性能提升方案"></a>性能提升方案</h3><ul><li>Key与Value设计规范</li><li>避免BigKey</li><li>避免耗时操作</li><li>Pipeline管道操作</li><li>连接池性能优化</li><li>子进程的开销与优化</li></ul><br><h3 id="故障解决方案"><a href="#故障解决方案" class="headerlink" title="故障解决方案"></a>故障解决方案</h3><ul><li>数据延迟</li><li>数据脏读</li><li>数据抖动</li><li>数据一致性</li><li>热点数据存储</li><li>RDB文件损坏</li></ul><br><h2 id="怎么学"><a href="#怎么学" class="headerlink" title="怎么学"></a>怎么学</h2><ul><li>对Redis有兴趣，但不懂如何和项目深度结合</li><li>了解Redis日常操作，但不懂得Redis底层原理</li><li>遇到Redis故障完全没有思路，不知如何解决</li></ul><br><br><br><h1 id="第2章-Redis快速入门"><a href="#第2章-Redis快速入门" class="headerlink" title="第2章 Redis快速入门"></a>第2章 Redis快速入门</h1><h2 id="章节介绍"><a href="#章节介绍" class="headerlink" title="章节介绍"></a>章节介绍</h2><h3 id="学习目标"><a href="#学习目标" class="headerlink" title="[学习目标]"></a>[学习目标]</h3><p>1、了解Redis为什么能流行这么多年，高性能的原因<br>2、掌握Redis环境安装以及配置<br>3、了解微服务项目的构建以及SpringBoot开发</p><br><h3 id="理论知识"><a href="#理论知识" class="headerlink" title="[理论知识]"></a>[理论知识]</h3><p>1、缓存相关中间件 (Redis、 Memcache和Ehcache) 的比较<br>2、对Redis的基本理解<br>3、微服务相关概念</p><br><h3 id="实际操作"><a href="#实际操作" class="headerlink" title="[实际操作]"></a>[实际操作]</h3><p>1、Redis安装、配置以及启动<br>2、Redis的基本命令<br>3、数据库表结构设计<br>4、SpringBoot&amp;SpringCloud项目搭建</p><br><h2 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>内存数据库，速度快，也支持数据的持久化</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供Lists、 Hashes、 Sets 、Sorted Sets 等多种数据结构的存储</li><li>Redis支持数据的备份 (master-slave) 与集群 (分片存储)，以及拥有哨兵监控机制.</li><li>支持事务</li></ul><br><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>性能极高 - Redis能读的速度是110000次/s，写的速度是81000次/s</li><li>丰富的数据类型 - Redis支持 Strings、 Lists、 Hashes、Sets 、Sorted Sets 等数据类型操作</li><li>原子操作 - Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行 (事务）</li><li>丰富的特性 - Redis还支持 publish/subscribe,通知,key 过期等特性。</li></ul><br><h3 id="Redis、Memcached、-Ehcache的区别"><a href="#Redis、Memcached、-Ehcache的区别" class="headerlink" title="Redis、Memcached、 Ehcache的区别"></a>Redis、Memcached、 Ehcache的区别</h3><ul><li>这三个中间件都可以应用于缓存，但目前市面上使用Redis的场景会更多，更广泛，其原因是: Redis性能高、原子操作、支持多种数据类型，主从复制与哨兵监控，持久化操作等。</li></ul><br><h2 id="Redis的高并发"><a href="#Redis的高并发" class="headerlink" title="Redis的高并发"></a>Redis的高并发</h2><ul><li>官方的bench-mark数据: 测试完成了50个并发执行100000个请求。设置和获取的值是一个256字节字符串。结果: 读的速度是110000次/s,写的速度是81000次/s。redis尽量少写多读，符合缓存的适用要求。单机redis支撑万级，如果10万+可以采用主从复制的模式。</li></ul><br><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li>Redis是纯内存数据库，所以读取速度快。</li><li>Redis使用的是非阻塞10，10多路复用，减少了线程切换时上下文的切换和竞争</li><li>Redis采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争</li><li>Redis存储结构多样化，不同的数据结构对数据存储进行了优化加快读取的速度</li><li>Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大</li></ol><br><h3 id="Redis的单线程"><a href="#Redis的单线程" class="headerlink" title="Redis的单线程"></a>Redis的单线程</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ul><li>不需要各种锁的性能消耗</li><li>单线程多进程集群方案</li><li>CPU消耗</li></ul><h4 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h4><ul><li>单进程单线程优势<ul><li>代码更清晰，处理逻辑更简单</li><li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</li><li>不存在多进程或者多线程导致的切换而消耗CPU</li></ul></li><li>单进程单线程弊端<ul><li>无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善</li></ul></li></ul><br><h3 id="I-O多路复用技术"><a href="#I-O多路复用技术" class="headerlink" title="I/O多路复用技术"></a>I/O多路复用技术</h3><ul><li>redis 采用网络I/O多路复用技术来保证在多连接的时候，系统的高吞吐量。</li></ul><br><h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><ul><li>Redis2.6<ul><li>键的过期时间支持毫秒</li><li>从节点支持只读功能</li></ul></li><li>Redis2.8<ul><li>可以用bind命令绑定多个IP地址</li><li>发布订阅添加了pub/sub</li><li>Redis Sentinel第二版，相比于Redis2.6的Redis Sentinel，此版本已经变成生产可用</li></ul></li><li>Redis3.0 (里程碑)<ul><li> Redis最大的改动就是添加Redis的分布式实现Redis cluster。</li></ul></li><li>Redis3.2<ul><li>添加GEO相关功能。</li><li>新的List编码类型: quicklist。</li></ul></li><li>Redis4.0 (重大改版)<ul><li>提供了模块系统，方便第三方开发者拓展Redis的功能</li><li>提供了新的缓存剔除算法: LFU (Last Frequently Used)，并对已有算法进行了优化</li><li>提供了非阻塞del和flushall/flushdb功能，有效解决删除了bigkey可能造成的Redis阻塞.</li><li>提供了RDB-AOF混合持久化格式，充分利用了AOF和RDB各自优势。</li></ul></li><li>Redis5.0<ul><li>新的stream数据类型</li><li>客户经常连接和断开连接时性能更好</li></ul></li><li>Redis6.0<ul><li>多线程I/O。多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程</li></ul></li></ul><br><h2 id="Redis软件安装"><a href="#Redis软件安装" class="headerlink" title="Redis软件安装"></a>Redis软件安装</h2><h3 id="下载解压"><a href="#下载解压" class="headerlink" title="下载解压"></a>下载解压</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget -P /usr/local/src/ https://download.redis.io/releases/redis-6.0.9.tar.gz</span><br><span class="line"></span><br><span class="line">cd /usr/local/src/</span><br><span class="line">tar -zxvf redis-6.0.9.tar.gz</span><br></pre></td></tr></table></figure><br><h3 id="确保环境依赖（升级-GCC）"><a href="#确保环境依赖（升级-GCC）" class="headerlink" title="确保环境依赖（升级 GCC）"></a>确保环境依赖（升级 GCC）</h3><ul><li>在编译 Redis 6 之前需要升级 gc 的版本，默认情况 yum 安装的 gcc 版本是 4.8.5，由于版本过低，在编译时会报如下错误。所以我们需要执行以下操作升级 GCC。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 Sc1 源</span></span><br><span class="line">yum install -y centos-release-scl scl-utils-build</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 9 版本的 gcc、gcc-c++、gdb 工具链 (toolchian)</span></span><br><span class="line">yum install -y devtoolset-9-toolchain</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时覆盖系统原有的 gcc 引用</span></span><br><span class="line">scl enable devtoolset-9 bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 gcc 当前版本</span></span><br><span class="line">gcc -v</span><br></pre></td></tr></table></figure><br><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src/redis-6.0.9/</span><br><span class="line">make</span><br></pre></td></tr></table></figure><br><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/local/redis-6.0.9</span><br><span class="line">cd /usr/local/src/redis-6.0.9/</span><br><span class="line">make PREFIX=/usr/local/redis-6.0.9 install</span><br></pre></td></tr></table></figure><br><h3 id="创建软连接"><a href="#创建软连接" class="headerlink" title="创建软连接"></a>创建软连接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/</span><br><span class="line">ln -s redis-6.0.9/ redis</span><br></pre></td></tr></table></figure><br><h2 id="Redis的启动"><a href="#Redis的启动" class="headerlink" title="Redis的启动"></a>Redis的启动</h2><h3 id="前台启动"><a href="#前台启动" class="headerlink" title="前台启动"></a>前台启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/redis</span><br><span class="line">bin/redis-server</span><br></pre></td></tr></table></figure><br><h3 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a>后台启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/local/src/redis-6.0.9/redis.conf /usr/local/redis/bin/</span><br><span class="line"></span><br><span class="line">cd /usr/local/redis/bin/</span><br><span class="line"></span><br><span class="line">vim redis.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改以守护进程方式启动</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用配置文件，后台启动</span></span><br><span class="line">cd /usr/local/redis/bin/</span><br><span class="line">./redis-server redis.conf</span><br></pre></td></tr></table></figure><br><h3 id="配置开机启动-centos7及以上"><a href="#配置开机启动-centos7及以上" class="headerlink" title="配置开机启动 (centos7及以上)"></a>配置开机启动 (centos7及以上)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在系统服务目录里创建redis.service文件</span></span><br><span class="line">vim /etc/systemd/system/redis.service</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写入以下内容:</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/redis/bin/redis-server /usr/local/redis/bin/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重载系统服务</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭redis-server:</span> </span><br><span class="line">systemctl stop redis.service</span><br><span class="line"></span><br><span class="line">systemctl start redis.service</span><br><span class="line"></span><br><span class="line">systemctl status redis.service</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启成功，将服务加入开机自启</span></span><br><span class="line">systemctl enable redis.service</span><br></pre></td></tr></table></figure><br><h2 id="Redis的配置"><a href="#Redis的配置" class="headerlink" title="Redis的配置"></a>Redis的配置</h2><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><p>1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第1章-课程介绍&quot;&gt;&lt;a href=&quot;#第1章-课程介绍&quot; class=&quot;headerlink&quot; title=&quot;第1章 课程介绍&quot;&gt;&lt;/a&gt;第1章 课程介绍&lt;/h1&gt;&lt;h2 id=&quot;为何Redis经久不衰？&quot;&gt;&lt;a href=&quot;#为何Redis经久不衰？&quot; cla</summary>
      
    
    
    
    <category term="Database" scheme="https://ratears.github.io/dev.ratears.life/Categories/Database/"/>
    
    <category term="Redis" scheme="https://ratears.github.io/dev.ratears.life/Categories/Database/Redis/"/>
    
    
    <category term="Redis" scheme="https://ratears.github.io/dev.ratears.life/Tags/Redis/"/>
    
    <category term="Cache" scheme="https://ratears.github.io/dev.ratears.life/Tags/Cache/"/>
    
    <category term="Database" scheme="https://ratears.github.io/dev.ratears.life/Tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Redis Study Notes（4）：Redis Persistence</title>
    <link href="https://ratears.github.io/dev.ratears.life/Redis-Study-Notes%EF%BC%884%EF%BC%89%EF%BC%9ARedis-Persistence/"/>
    <id>https://ratears.github.io/dev.ratears.life/Redis-Study-Notes%EF%BC%884%EF%BC%89%EF%BC%9ARedis-Persistence/</id>
    <published>2023-03-01T16:30:35.000Z</published>
    <updated>2023-03-01T16:30:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>Redis 具有持久化功能，其会按照设置以<strong>快照（RDB）</strong>或<strong>操作日志（AOF）</strong>的形式将数据持久化到磁盘。</li></ul><br><br><br><h1 id="Redis-持久化基本原理"><a href="#Redis-持久化基本原理" class="headerlink" title="Redis 持久化基本原理"></a>Redis 持久化基本原理</h1><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/1677688583843.29d7zy1cbbbw.webp" width="70%"><br><ul><li>Redis 持久化也称为钝化，是指将内存中数据库的状态描述信息保存到磁盘中。只不过是不同的持久化技术，对数据的状态描述信息是不同的，生成的持久化文件也是不同的。但它们的作用都是相同的：避免数据意外丢失。</li><li><strong>通过手动方式，或自动定时方式，或自动条件触发方式，将内存中数据库的状态描述信息写入到指定的持久化文件中。</strong>当系统重新启动时，自动加载持久化文件，并根据文件中数据库状态描述信息将数据恢复到内存中，这个数据恢复过程也称为激活。这个钝化与激活的过程就是 Redis 持久化的基本原理。</li><li>对于 Redis 单机状态下，无论是手动方式，还是定时方式或条件触发方式，都<strong>存在数据丢失问题</strong>：在尚未手动/自动保存时发生了 Redis 宕机状况，那么从上次保存到宕机期间产生的数据就会丢失。不同的持久化方式，其数据的丢失率也是不同的。</li><li><strong>RDB 是默认持久化方式，但 Redis 允许 RDB 与 AOF 两种持久化技术同时开启，此时系统会使用 AOF 方式做持久化，即 AOF 持久化技术的优先级要更高。同样的道理，两种技术同时开启状态下，系统启动时若两种持久化文件同时存在，则优先加载 AOF持久化文件。</strong></li></ul><br><br><br><h1 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul><li><strong>RDB，Redis DataBase，是指将内存中某一时刻的数据快照全量写入到指定的 rdb 文件的持久化技术。</strong></li><li>RDB 持久化默认是开启的。当 Redis 启动时会自动读取 RDB 快照文件，将数据从硬盘载入到内存，以恢复 Redis 关机前的数据库状态。</li></ul><br><h2 id="持久化的执行"><a href="#持久化的执行" class="headerlink" title="持久化的执行"></a>持久化的执行</h2><ul><li>RDB 持久化的执行有三种方式：手动 save 命令、手动 bgsave 命令，与自动条件触发。</li></ul><br><h3 id="手动-save-命令"><a href="#手动-save-命令" class="headerlink" title="手动 save  命令"></a>手动 save  命令</h3><ul><li>通过在 redis-cli 客户端中执行 save 命令可立即进行一次持久化保存。</li><li><strong>save 命令在执行期间会阻塞 redis-server 进程，直至持久化过程完毕。而在 redis-server 进程阻塞期间，Redis不能处理任何读写请求，无法对外提供服务。</strong></li></ul><br><h3 id="手动-bgsave-命令"><a href="#手动-bgsave-命令" class="headerlink" title="手动 bgsave  命令"></a>手动 bgsave  命令</h3><ul><li>通过在 redis-cli 客户端中执行 bgsave 命令可立即进行一次持久化保存。</li><li><strong>bgsave 命令会使服务器进程 redis-server 生成一个子进程，由该子进程负责完成保存过程。在子进程进行保存过程中，不会阻塞 redis-server 进程对客户端读写请求的处理。</strong></li></ul><br><h3 id="自动条件触发"><a href="#自动条件触发" class="headerlink" title="自动条件触发"></a>自动条件触发</h3><ul><li>自动条件触发的本质仍是 bgsave 命令的执行。只不过是<strong>用户通过在配置文件中做相应的设置后，Redis 会根据设置信息自动调用 bgsave 命令执行。</strong>具体配置方式，参考 <a href="#save">RDB 优化配置 - save</a></li></ul><br><h3 id="查看持久化时间"><a href="#查看持久化时间" class="headerlink" title="查看持久化时间"></a>查看持久化时间</h3><ul><li>通过 lastsave 命令可以查看最近一次执行持久化的时间，其返回的是一个 Unix 时间戳。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lastsave</span><br><span class="line">(integer) 1677689127</span><br><span class="line">127.0.0.1:6379&gt; exit</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# date -d @1677689127</span><br><span class="line">Thu Mar  2 00:45:27 CST 2023</span><br></pre></td></tr></table></figure><br><h2 id="RDB-优化配置"><a href="#RDB-优化配置" class="headerlink" title="RDB 优化配置"></a>RDB 优化配置</h2><ul><li>DB 相关的配置在 redis.conf 文件的 SNAPSHOTTING 部分</li></ul><br><h3 id="save"><a href="#save" class="headerlink" title="save"></a>save</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">save 3600 1 300 100 60 10000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">该配置用于设置快照的自动保存触发条件，即 save point，保存点。该触发条件是在指定时间段内发生了指定次数的写操作。除非另有规定，默认情况下持久化条件为 save 3600 1 300 100 60 10000。（跟redis6的默认值比，条件更宽松）其等价于以下三条：</span></span><br><span class="line">save 3600 1 # 在 3600 秒(1 小时)内发生 1 次写操作</span><br><span class="line">save 300 100 # 在 300 秒(5 分钟)内发生 100 次写操作</span><br><span class="line">save 60 10000 # 在 60 秒(1 分钟)内发生 1 万次写操作</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不启用 RDB 持久化，只需设置 save 的参数为空串即可：save “”。</span></span><br></pre></td></tr></table></figure><br><h3 id="stop-write-on-bgsave-error"><a href="#stop-write-on-bgsave-error" class="headerlink" title="stop-write-on-bgsave-error"></a>stop-write-on-bgsave-error</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认情况下，如果 RDB 快照已启用（至少一个保存点），且最近的 bgsave 命令失败，Redis将停止接受写入。这样设置是为了让用户意识到数据没有正确地保存到磁盘上，否则很可能没有人会注意到，并会发生一些灾难。当然，如果 bgsave 命令后来可以正常工作了，Redis将自动允许再次写入。</span></span><br></pre></td></tr></table></figure><br><h3 id="rdbcompression"><a href="#rdbcompression" class="headerlink" title="rdbcompression"></a>rdbcompression</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rdbcompression yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当进行持久化时启用 LZF 压缩字符串对象。虽然压缩 RDB 文件会消耗系统资源，降低性能，但可大幅降低文件的大小，方便保存到磁盘，加速主从集群中从节点的数据同步。</span></span><br></pre></td></tr></table></figure><br><h3 id="rdbchecksum"><a href="#rdbchecksum" class="headerlink" title="rdbchecksum"></a>rdbchecksum</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rdbchecksum yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从 RDB5 开始，RDB 文件的 CRC64 校验和就被放置在了文件末尾。这使格式更能抵抗 RDB文件的损坏，但在保存和加载 RDB 文件时，性能会受到影响（约 10%），因此可以设置为 no禁用校验和以获得最大性能。在禁用校验和的情况下创建的 RDB 文件的校验和为零，这将告诉加载代码跳过校验检查。默认为 <span class="built_in">yes</span>，开启了校验功能。</span></span><br></pre></td></tr></table></figure><br><h3 id="sanitize-dump-payload"><a href="#sanitize-dump-payload" class="headerlink" title="sanitize-dump-payload"></a>sanitize-dump-payload</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sanitize-dump-payload no</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">该配置用于设置在加载 RDB 文件或进行持久化时是否开启对 zipList、listPack 等数据的全面安全检测。该检测可以降低命令处理时发生系统崩溃的可能。其可设置的值有三种选择：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">no：不检测</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">yes</span>：总是检测</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">clients：只有当客户端连接时检测。排除了加载 RDB 文件与进行持久化时的检测。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认值本应该是 clients，但其会影响 Redis 集群的工作，所以默认值为 no，不检测</span></span><br></pre></td></tr></table></figure><br><h3 id="dbfilename"><a href="#dbfilename" class="headerlink" title="dbfilename"></a>dbfilename</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定 RDB 文件的默认名称，默认为 dump.rdb。</span></span><br></pre></td></tr></table></figure><br><h3 id="rdb-del-sync-files"><a href="#rdb-del-sync-files" class="headerlink" title="rdb-del-sync-files"></a>rdb-del-sync-files</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rdb-del-sync-files no</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主从复制时，是否删除用于同步的从机上的 RDB 文件。默认是 no，不删除。不过需要注意，只有当从机的 RDB 和 AOF 持久化功能都未开启时才生效。</span></span><br></pre></td></tr></table></figure><br><h3 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dir ./</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定 RDB 与 AOF 文件的生成目录。默认为 Redis 安装根目录。</span></span><br></pre></td></tr></table></figure><br><h2 id="RDB-文件结构"><a href="#RDB-文件结构" class="headerlink" title="RDB 文件结构"></a>RDB 文件结构</h2><ul><li>RDB 持久化文件 dump.rdb 整体上有五部分构成：</li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/1677690793796.ahq2vfvxqbk.webp" width="70%"><br><h3 id="SOF"><a href="#SOF" class="headerlink" title="SOF"></a>SOF</h3><ul><li>SOF 是一个常量，一个字符串 REDIS，仅包含这五个字符，其长度为 5。<strong>于标识 RDB文件的开始</strong>，以便在加载 RDB 文件时可以迅速判断出文件是否是 RDB 文件。</li></ul><br><h3 id="rdb-version"><a href="#rdb-version" class="headerlink" title="rdb_version"></a>rdb_version</h3><ul><li>一个整数，长度为 4 字节，表示 RDB 文件的版本号。</li></ul><br><h3 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h3><ul><li>EOF 是一个常量，占 1 个字节，用于标识 RDB 数据的结束，校验和的开始</li></ul><br><h3 id="check-sum"><a href="#check-sum" class="headerlink" title="check_sum"></a>check_sum</h3><ul><li>校验和 check_sum 用于判断 RDB 文件中的内容是否出现数据异常。其采用的是 CRC 校验算法。</li></ul><blockquote><p>CRC 校验算法：</p><ul><li>在持久化时，先将 SOF、rdb_version 及内存数据库中的数据快照这三者的二进制数据拼接起来，形成一个二进制数（假设称为数 a），然后再使用这个 a 除以校验和 check_sum，此时可获取到一个余数 b，然后再将这个 b 拼接到 a 的后面，形成 databases。</li><li>在加载时，需要先使用 check_sum 对 RDB 文件进行数据损坏验证。验证过程：只需将RDB 文件中除 EOF 与 check_sum 外的数据除以 check_sum。只要除得的余数不是 0，就说明文件发生损坏。当然，如果余数是 0，也不能肯定文件没有损坏。</li><li>这种验证算法，是数据损坏校验，而不是数据没有损坏的校验。</li></ul></blockquote><br><h3 id="databases"><a href="#databases" class="headerlink" title="databases"></a>databases</h3><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.73la3w8w01k0.webp" width="70%"><br><ul><li>databases 部分是 RDB 文件中最重要的数据部分，其可以包含任意多个非空数据库。而每个 database 又是由三部分构成：<ul><li>SODB：是一个常量，占 1 个字节，用于标识一个数据库的开始。</li><li>db_number：数据库编号</li><li>key_value_pairs：当前数据库中的键值对数据。每个 key_value_pairs 又由很多个用于描述键值对的数据构成。<ul><li>VALUE_TYPE：是一个常量，占 1 个字节，用于标识该键值对中 value 的类型。</li><li>EXPIRETIME_UNIT：是一个常量，占 1 个字节，用于标识过期时间的单位是秒还是毫秒。</li><li>time：当前 key-value 的过期时间</li></ul></li></ul></li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.6uquj9ci3a40.webp" width="70%"><br><h2 id="RDB-持久化过程"><a href="#RDB-持久化过程" class="headerlink" title="*RDB 持久化过程"></a>*RDB 持久化过程</h2><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.69rmnjs1gv40.webp" width="100%"><br><ul><li>对于 Redis 默认的 RDB 持久化，在进行 bgsave 持久化时，redis-server 进程会 fork 出一个 bgsave 子进程，由该子进程以异步方式负责完成持久化。而在持久化过程中，redis-server进程不会阻塞，其会继续接收并处理用户的读写请求。</li><li>bgsave 子进程的详细工作原理如下：<ul><li>由于子进程可以继承父进程的所有资源，且父进程不能拒绝子进程的继承权。所以，bgsave 子进程有权读取到 redis-server 进程写入到内存中的用户数据，使得将内存数据持久化到 dump.rdb 成为可能。</li><li>bgsave 子进程在持久化时首先会将内存中的全量数据 copy 到磁盘中的一个 RDB 临时文件，copy 结束后，再将该文件 rename 为 dump.rdb，替换掉原来的同名文件。</li><li>不过，在进行持久化过程中，如果 redis-server 进程接收到了用户写请求，则系统会将</li><li>内存中发生数据修改的物理块 copy 出一个副本。等内存中的全量数据 copy 结束后，会再将副本中的数据 copy 到 RDB 临时文件。这个副本的生成是由于 Linux 系统的写时复制技术（Copy-On-Write）实现的。</li></ul></li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.w8m0t6tk85s.webp" width="100%"><br><h2 id="写时复制技术（Copy-On-Write）"><a href="#写时复制技术（Copy-On-Write）" class="headerlink" title="*写时复制技术（Copy-On-Write）"></a>*写时复制技术（Copy-On-Write）</h2><ul><li>原本在 Unix 系统中，当一个主进程通过 fork()系统调用创建子进程后，内核进程会复制主进程的整个内存空间中的数据，然后分配给子进程。这种方式存在的问题有以下几点：<ul><li>这个过程非常耗时</li><li>这个过程降低了系统性能</li><li>如果主进程修改了其内存数据，子进程副本中的数据是没有修改的。即出现了数据冗余，而冗余数据最大的问题是数据一致性无法保证。</li></ul></li></ul><ul><li>现代的 Linux 则采用了更为有效的方式：<ul><li>写时复制。子进程会继承父进程的所有资源，其中就包括主进程的内存空间。即子进程与父进程共享内存。只要内存被共享，那么该内存就是只读的（写保护的）。而写时复制则是在任何一方需要写入数据到共享内存时都会出现异常，此时内核进程就会将需要写入的数据 copy 出一个副本写入到另外一块非共享内存区域。</li></ul></li></ul><br><br><br><h1 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><ul><li>AOF，Append Only File，是指 Redis 将每一次的写操作都以日志的形式记录到一个 AOF文件中的持久化技术。当需要恢复内存数据时，将这些写操作重新执行一次，便会恢复到之前的内存数据状态。</li></ul><br><h2 id="AOF-基础配置"><a href="#AOF-基础配置" class="headerlink" title="AOF 基础配置"></a>AOF 基础配置</h2><h3 id="AOF-的开启"><a href="#AOF-的开启" class="headerlink" title="AOF 的开启"></a>AOF 的开启</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认情况下 AOF 持久化是没有开启的，通过修改配置文件中的 appendonly 属性为 <span class="built_in">yes</span>可以开启。</span></span><br></pre></td></tr></table></figure><br><h3 id="文件名配置"><a href="#文件名配置" class="headerlink" title="文件名配置"></a>文件名配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br></pre></td></tr></table></figure><ul><li>Redis 7 在这里发生了重大变化。原来只有一个 appendonly.aof 文件，现在具有了三类多个文件：<ul><li>基本文件：可以是 RDF 格式也可以是 AOF 格式。其存放的内容是由 RDB 转为 AOF 当时内存的快照数据。该文件可以有多个。</li><li>增量文件：以操作日志形式记录转为 AOF 后的写入操作。该文件可以有多个。</li><li>清单文件：用于维护 AOF 文件的创建顺序，保障激活时的应用顺序。该文件只有一个。</li></ul></li></ul><br><h3 id="混合式持久化开启"><a href="#混合式持久化开启" class="headerlink" title="混合式持久化开启"></a>混合式持久化开启</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aof-use-rdb-preamble yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对于基本文件可以是 RDF 格式也可以是 AOF 格式。通过 aof-use-rdb-preamble 属性可以选择。其默认值为 <span class="built_in">yes</span>，即默认 AOF 持久化的基本文件为 rdb 格式文件，也就是默认采用混合式持久化。</span></span><br></pre></td></tr></table></figure><br><h3 id="AOF-文件目录配置"><a href="#AOF-文件目录配置" class="headerlink" title="AOF 文件目录配置"></a>AOF 文件目录配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appenddirname &quot;appendonlydir&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为了方便管理，可以专门为 AOF 持久化文件指定存放目录。目录名由 appenddirname属性指定，存放在 redis.conf 配置文件的 <span class="built_in">dir</span> 属性指定的目录，默认为 Redis 安装目录。</span></span><br></pre></td></tr></table></figure><br><h2 id="AOF-文件格式"><a href="#AOF-文件格式" class="headerlink" title="AOF 文件格式"></a>AOF 文件格式</h2><ul><li>AOF 文件包含三类文件：基本文件、增量文件与清单文件。其中基本文件一般为 rdb 格式</li></ul><br><h3 id="Redis-协议"><a href="#Redis-协议" class="headerlink" title="Redis 协议"></a>Redis 协议</h3><ul><li>增量文件扩展名为.aof，采用 AOF 格式。AOF 格式其实就是 Redis 通讯协议格式，AOF持久化文件的本质就是基于 Redis 通讯协议的文本，将命令以纯文本的方式写入到文件中。</li><li>Redis 协议规定，Redis 文本是以行来划分，每行以\r\n 行结束。每一行都有一个消息头，以表示消息类型。消息头由六种不同的符号表示，其意义如下：<ul><li>(+) 表示一个正确的状态信息</li><li>(-) 表示一个错误信息</li><li>(*) 表示消息体总共有多少行，不包括当前行</li><li>($) 表示下一行消息数据的长度，不包括换行符长度\r\n</li><li>(空) 表示一个消息数据</li><li>(:) 表示返回一个数值</li></ul></li></ul><br><h3 id="查看-AOF-文件"><a href="#查看-AOF-文件" class="headerlink" title="查看 AOF 文件"></a>查看 AOF 文件</h3><br><br><br><h1 id="RDB-与-AOF-的取舍和选择"><a href="#RDB-与-AOF-的取舍和选择" class="headerlink" title="RDB 与 AOF 的取舍和选择"></a>RDB 与 AOF 的取舍和选择</h1><h2 id="RDB-与-AOF-的对比"><a href="#RDB-与-AOF-的对比" class="headerlink" title="RDB 与 AOF 的对比"></a>RDB 与 AOF 的对比</h2><table><thead><tr><th align="center">-</th><th align="center">优势</th><th align="center">不足</th></tr></thead><tbody><tr><td align="center">RDB</td><td align="center">RDB 文件较小<br>数据恢复较快</td><td align="center">数据安全性较差<br>写时复制会降低性能<br>RDB 文件可读性较差</td></tr><tr><td align="center">AOF</td><td align="center">数据安全性高<br>AOF 文件可读性强</td><td align="center">AOF 文件较大<br>写操作会影响性能<br>数据恢复较慢</td></tr></tbody></table><br><h2 id="Redis-持久化的取舍和选择"><a href="#Redis-持久化的取舍和选择" class="headerlink" title="Redis 持久化的取舍和选择"></a>Redis 持久化的取舍和选择</h2><ul><li>官方推荐使用 RDB 与 AOF 混合式持久化。</li><li>若对数据安全性要求不高，则推荐使用纯 RDB 持久化方式。</li><li>不推荐使用纯 AOF 持久化方式。</li><li>若 Redis 仅用于缓存，则无需使用任何持久化技术。</li></ul><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><ol><li>RDB文件格式这块还有点模糊</li><li>后续再参考其它教程看看情况</li></ol></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Redis 具有持久化功能，其会按照设置以&lt;strong&gt;快照（RDB）&lt;/strong&gt;或&lt;strong&gt;操作日志（AOF）&lt;</summary>
      
    
    
    
    <category term="Database" scheme="https://ratears.github.io/dev.ratears.life/Categories/Database/"/>
    
    <category term="Redis" scheme="https://ratears.github.io/dev.ratears.life/Categories/Database/Redis/"/>
    
    
    <category term="Redis" scheme="https://ratears.github.io/dev.ratears.life/Tags/Redis/"/>
    
    <category term="Cache" scheme="https://ratears.github.io/dev.ratears.life/Tags/Cache/"/>
    
    <category term="Database" scheme="https://ratears.github.io/dev.ratears.life/Tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>《深入浅出分布式技术原理》study notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E3%80%8Bstudy-notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E3%80%8Bstudy-notes/</id>
    <published>2023-02-24T18:10:57.000Z</published>
    <updated>2023-02-24T18:10:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开篇词-1讲"><a href="#开篇词-1讲" class="headerlink" title="开篇词 (1讲)"></a>开篇词 (1讲)</h1><h2 id="开篇词｜掌握好学习路径，分布式系统原来如此简单"><a href="#开篇词｜掌握好学习路径，分布式系统原来如此简单" class="headerlink" title="开篇词｜掌握好学习路径，分布式系统原来如此简单"></a>开篇词｜掌握好学习路径，分布式系统原来如此简单</h2><ul><li>分布式系统，已经是互联网公司 IT 架构的事实标准</li><li>是否能系统性地理解分布式系统是初级工程师和资深工程师之间最显著的差别</li></ul><h3 id="学习路径的重要性"><a href="#学习路径的重要性" class="headerlink" title="学习路径的重要性"></a>学习路径的重要性</h3><ul><li>在做架构设计和选型的时候，没有知识系统做支撑，不能系统性地思考，处理问题也没有十足的把握</li><li><strong>先要有分布式技术的一些实践和经验。经历一个分布式系统从小到大，从简单到复杂的完整演进过程。</strong>（这样可以对分布式系统有更全面、深刻的认知，熟悉分布式系统中每一个组件的设计原则，能够站在一个全局的角度，去思考分布式系统中各个组件之间的关联与取舍。对分布式系统也有清晰的知识脉络与理解）</li><li>一定要有一条明确的学习路径，从最根本的原因出发<ul><li>多问自己为什么</li><li>思考怎么做</li><li>在技术理解与实践中反复横跳，才能由点成线</li><li>在总结中抓住技术实现的关键点和系统脉络，不迷失于细节，才能连线成网</li></ul></li></ul><h3 id="课程设计"><a href="#课程设计" class="headerlink" title="课程设计"></a>课程设计</h3><ul><li><strong>首先，找到分布式系统中稳定不变的知识、原理和解决思路。</strong>比如注册发现的原理、故障处理的思路和 CAP 理论等等（分布式系统技术要点多，但万变不离其宗）</li><li><strong>其次，去繁从简。</strong><ul><li>只聚焦于日常工作中接触最频繁的在线业务分布式系统，依据是否有状态将其分为“分布式计算”和“分布式存储”这两大部分，从简单到复杂依次介绍分布式系统的相关知识与原理</li></ul></li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/fab78448a78d69c9891f9e6b64a620a.u2bzdet8v28.webp" width="100%"><br><h4 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h4><ul><li><strong>专栏将分为四个递进的模块，学习计划如下</strong></li></ul><h5 id="概述篇"><a href="#概述篇" class="headerlink" title="概述篇"></a>概述篇</h5><blockquote><p><strong>学习一个知识应该先理解这个知识的来龙去脉</strong>，我们先讨论分布式系统产生的过程：它为什么会产生，产生后解决了什么问题，又带来了哪些新问题，遇到哪些方面的挑战。</p><p>通过“概述篇”的学习，可以比较好地抓到分布式系统的脉络和关键点，有了很强的学习目标和路径，就不会迷失在各种系统和框架实现的细节中了。</p></blockquote><h5 id="分布式计算篇"><a href="#分布式计算篇" class="headerlink" title="分布式计算篇"></a>分布式计算篇</h5><blockquote><p><strong>从单机系统演进到分布式系统后，引入哪些新问题的角度，在技术原理层面一个一个讨论并解决这些问题。</strong></p><p>学习之后，可以在各种系统和场景中理解和运用它，并且知道在系统设计层面应该如何取舍。</p></blockquote><h5 id="分布式存储篇"><a href="#分布式存储篇" class="headerlink" title="分布式存储篇"></a>分布式存储篇</h5><blockquote><p>分布式技术篇中的进阶篇，我们对计算进行分布式扩展后，再一起来讨论存储的分布式扩展。这里我们从简单到复杂，一起讨论数据分片、数据复制、分布式事务和一致性等相关的知识。</p><p>掌握之后，再做架构设计时，你会发现思维的深度和广度都得到了提升。</p></blockquote><h5 id="总结篇"><a href="#总结篇" class="headerlink" title="总结篇"></a>总结篇</h5><blockquote><p>此时，已经对分布式系统的重要原理有了系统性地理解，这个时候，我们再一起来看分布式系统的发展历程和未来趋势。</p><p>我们从分布式计算的角度，一起讨论分布式系统是怎么从单机系统演进到 Service Mesh的；还会从分布式存储的角度，一起讨论分布式系统是怎么从单机系统的 ACID 演进到NewSQL 的。</p></blockquote><ul><li><strong>这个专栏最大的价值就是能够系统性地解决你的问题，不需要花费大量的精力再进行一次低效的探索。</strong></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>[知乎：如何系统性的学习分布式系统?](如何系统性的学习分布式系统? - kylin的回答 - 知乎 <a class="link"   href="https://www.zhihu.com/question/320812569/answer/1386491563" >https://www.zhihu.com/question/320812569/answer/1386491563<i class="fas fa-external-link-alt"></i></a>)</li></ul><br><br><br><h1 id="概述篇-3讲"><a href="#概述篇-3讲" class="headerlink" title="概述篇 (3讲)"></a>概述篇 (3讲)</h1><h2 id="01｜导读：以前因后果为脉络，串起网状知识体系"><a href="#01｜导读：以前因后果为脉络，串起网状知识体系" class="headerlink" title="01｜导读：以前因后果为脉络，串起网状知识体系"></a>01｜导读：以前因后果为脉络，串起网状知识体系</h2><ul><li><strong>学习一个知识之前，比较好的方式是先理解它的前因后果：前因就是这个知识产生的过程中，它解决了什么问题，怎么样解决的。后果就是它的出现又带来了哪些新的问题，这样我们才能比较好地抓到它的脉络和关键点，不会一开始就迷失在细节中。</strong></li></ul><br><h3 id="前因：分布式系统解决了什么问题"><a href="#前因：分布式系统解决了什么问题" class="headerlink" title="前因：分布式系统解决了什么问题"></a>前因：分布式系统解决了什么问题</h3><ul><li><p>学习分布式之前，要解决的第一个问题就是：分布式系统解决了什么问题，怎么样解决的？</p><ul><li>分布式系统解决了单机性能瓶颈导致的成本问题</li><li>解决了用户量和数据量爆炸性地增大导致的成本问题（必须寻找更经济的方案来处理和存储这些数据）</li><li>满足了业务高可用的要求</li><li>分布式系统解决了大规模软件系统的迭代效率和成本的问题</li></ul></li><li><p>在互联网时代，单机系统是无法解决成本、效率和高可用问题的</p></li></ul><ul><li>分布式系统又是怎么解决单机系统面临的成本、效率和高可用的问题呢？<ul><li>分布式系统指的是由一组通过网络进行通信，为了完成共同的任务，而协调工作的计算机节点组成的系统（分布式系统是通过多工作节点，来解决单机系统面临的成本、效率和高可用问题的）</li></ul></li></ul><ul><li>分布式系统的发展是无法阻挡的技术大潮流</li></ul><ul><li>如何理解分布式系统的出现，以及分布式系统在不同业务场景中的表现形式<ul><li><strong>所以我们可以把分布式系统看成是单体系统的平民化和物美价廉的版本</strong></li><li>分布式系统在不同的业务场景中有着不同的表现形式<ul><li>流量路由策略加多副本部署（微服务是其中的一种架构形式）是无状态服务的分布式架构方案</li><li>Redis Cluster 和 Codis 等方案实现了缓存的分布式化</li><li>Kubernetes 则完成了操作系统的分布式进化</li><li>NoSQL 掀起了数据库分布式化的第一波浪潮，而 NewSQL 则推动着支持 ACID 的关系数据库的分布式化</li></ul></li></ul></li></ul><br><h3 id="后果：如何思考和处理分布式系统引入的新问题"><a href="#后果：如何思考和处理分布式系统引入的新问题" class="headerlink" title="后果：如何思考和处理分布式系统引入的新问题"></a>后果：如何思考和处理分布式系统引入的新问题</h3><ul><li>分布式系统的出现也引入了分布式系统内部工作节点的协调问题，主要体现在分布式系统内部组件、实例之间，通过异步网络进行通信和协调的问题上。</li></ul><ul><li><strong>针对内部工作节点的协调问题，分布式系统是怎么做的？</strong><ul><li><strong>对于分布式计算（无状态）的情况，系统内部的协调需要做哪些工作</strong><ul><li>怎么找到服务？（服务的注册与发现）</li><li>怎么找到实例？（负载均衡与路由）</li><li>怎么管理配置？（配置中心）</li><li>怎么进行协同？（分布式锁）</li><li>怎么确保请求只执行一次？（重试与幂等）</li><li>怎么避免雪崩？（快速失败和降级机制（熔断、降级、限流等），弹性扩容机制）</li><li>怎么监控告警和故障恢复？（完善分布式系统的监控（比如接口的时延和可用性等信息），分布式追踪 Trace ，模拟故障的混沌工程以及相关的告警等机制。同时做好故障恢复预案，确保在故障发生的时候，能够快速恢复故障。）</li></ul></li><li><strong>分布式存储（有状态）的内部协调是怎么做的</strong><ul><li>怎么进行协同？</li><li>怎么做数据分片（单机系统是不可能存储所有数据的，所以需要解决怎么将数据按一定的规则，分别存储到不同的机器上这个问题，目前使用较多的方案是：Hash 和 Region 分片的策略，但是要注意了解一下它们的优缺点和各自的应用场景。）</li><li>怎么做数据复制（为了满足系统的高可用要求，需要对数据做冗余处理）</li><li>怎么做分布式事务</li></ul></li></ul></li></ul><br><h3 id="系统学习"><a href="#系统学习" class="headerlink" title="系统学习"></a>系统学习</h3><ul><li><p><strong>从实践出发</strong>，研究目前比较常用的分布式系统的设计，HDFS 或者 GFS（分布式文件系统）、Kafka 和 Pulsar（分布式消息队列），Redis Cluster 和 Codis（分布式缓存），MySQL 的分库分表（传统关系型数据库的分布式方案），MongoDB 的 Replica Set 和Sharing 机制集（NoSQL 数据库），TiDB（NewSQL）以及一些微服务框架等</p></li><li><p><strong>从理论出发</strong>，研究分布式相关的论文（《Designing Data-IntensiveApplications》）</p></li></ul><ul><li>为了更好地理解如何处理分布式系统引入的内部工作节点的协调问题，把它们总结为下面三类问题：</li><li><strong>路由问题</strong></li></ul><blockquote><p>分布式系统由单体系统拆分而来，必然会导致分布式系统内部，出现复杂的路由问题。路由问题主要是解决分布式系统内部各服务和实例之间的通信，我们可以将“怎么找到服务”和“怎么找到实例”等服务注册发现和负载均衡的问题，理解为正常情况下的路由问题，将“怎么做数据分片”的问题，理解为带状态的路由问题，将“怎么避免雪崩”涉及的熔断、降级等快速失败和降级机制，理解为异常情况下的路由问题。</p></blockquote><ul><li><strong>共识问题</strong></li></ul><blockquote><p>分布式系统的各个组件是运行在不同机器上的不同进程，因为程序总是需要按一定的逻辑有序地执行，所以需要一个办法，来协调分布式系统内部，已经各自为政的服务和实例，而共识就是讨论并解决这一类问题的，例如“怎么做数据复制”、“怎么做分布式事务”和“怎么做分布式锁”里，都会涉及共识问题。</p></blockquote><ul><li><strong>运维问题</strong></li></ul><blockquote><p>分布式系统相对于单体系统是非常碎片化的，如果还依靠人肉运维，在效率上是完全行不通的，所以催生了一系列自动化运维的工具和平台来解决这一类问题，例如“怎么管理配置”和“怎么监控告警和故障恢复”都涉及运维的问题。</p></blockquote><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>在学习新知识的时候，只有点、线结合，形成网状的知识体系</li></ul><img src="" width="70%"><br><br><br><h2 id="02｜新的挑战：分布式系统是银弹吗？我看未必！"><a href="#02｜新的挑战：分布式系统是银弹吗？我看未必！" class="headerlink" title="02｜新的挑战：分布式系统是银弹吗？我看未必！"></a>02｜新的挑战：分布式系统是银弹吗？我看未必！</h2><ul><li>要从根本上理解分布式系统的设计方法和原则，这就需要时刻谨记单体系统和分布式系统之间的差别</li><li><strong>从本质上来说，单体系统是以单进程的形式运行在一个计算机节点上，而分布式系统是以多进程的形式运行在多个计算机节点上，二者的本质差别导致了分布式系统面临着四个方面的新问题，分别是：故障处理、异步网络、时钟同步和共识协同。</strong></li></ul><br><h3 id="全部失败与部分失败"><a href="#全部失败与部分失败" class="headerlink" title="全部失败与部分失败"></a>全部失败与部分失败</h3><ul><li>单体服务系统中，在硬件正常的时候，对于一个确定的输入，总会得到一个确定的输出</li><li><strong>这种全部失败的处理逻辑，会大大减轻用户使用计算机的心智负担，让我们明确地知道，如果系统内部发生了故障，计算机不会给出错误的结果，而是会全部崩溃。</strong></li><li>分布式系统由多个计算机节点组成，虽然每一个计算机节点都是全部失败的模型，但是<strong>如果系统中的某些节点出现宕机或者网络故障，整个分布式系统就会出现部分失败的情况</strong></li><li>在分布式系统中，我们需要接受部分失败。</li><li>在分布式系统中，故障处理是软件设计的一个重要组成部分。我们需要时刻谨记节点宕机、网络分区等各种问题出现时，系统应该怎么正确处理，比如分布式系统在设计的时候，每一个组件都必须是高可用的。</li></ul><br><h3 id="本地调用与远程调用"><a href="#本地调用与远程调用" class="headerlink" title="本地调用与远程调用"></a>本地调用与远程调用</h3><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><p>1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;开篇词-1讲&quot;&gt;&lt;a href=&quot;#开篇词-1讲&quot; class=&quot;headerlink&quot; title=&quot;开篇词 (1讲)&quot;&gt;&lt;/a&gt;开篇词 (1讲)&lt;/h1&gt;&lt;h2 id=&quot;开篇词｜掌握好学习路径，分布式系统原来如此简单&quot;&gt;&lt;a href=&quot;#开篇词｜掌握好学习路</summary>
      
    
    
    
    <category term="distributed" scheme="https://ratears.github.io/dev.ratears.life/Categories/distributed/"/>
    
    
    <category term="distributed" scheme="https://ratears.github.io/dev.ratears.life/Tags/distributed/"/>
    
  </entry>
  
  <entry>
    <title>《Java分布式系统解决方案 掌握企业级分布式项目方案》study notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/%E3%80%8AJava%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E6%8E%8C%E6%8F%A1%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E9%A1%B9%E7%9B%AE%E6%96%B9%E6%A1%88%E3%80%8Bstudy-notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/%E3%80%8AJava%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E6%8E%8C%E6%8F%A1%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E9%A1%B9%E7%9B%AE%E6%96%B9%E6%A1%88%E3%80%8Bstudy-notes/</id>
    <published>2023-02-23T14:16:11.000Z</published>
    <updated>2023-02-23T14:16:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="玩转N种企业级解决方案，笑傲分布式开发"><a href="#玩转N种企业级解决方案，笑傲分布式开发" class="headerlink" title="玩转N种企业级解决方案，笑傲分布式开发"></a>玩转N种企业级解决方案，笑傲分布式开发</h1><ul><li>分布式场景下解决方案和技术选型</li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/5c4bb4f9e8f8cd64ebc31749fbe2f03.7glrt6915tc0.webp" width="90%"><br><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.skrnvv5d32o.webp" width="90%"><br><ul><li>SpringCloud和分布式解决方案<ul><li>SpringCloud是分布式架构，一定需要分布式解决方案</li></ul></li></ul><ul><li><strong>目标</strong>：掌握常见分布式场景中的解决方案</li></ul><br><br><br><h1 id="分布式ID"><a href="#分布式ID" class="headerlink" title="分布式ID"></a>分布式ID</h1><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><p>1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;玩转N种企业级解决方案，笑傲分布式开发&quot;&gt;&lt;a href=&quot;#玩转N种企业级解决方案，笑傲分布式开发&quot; class=&quot;headerlink&quot; title=&quot;玩转N种企业级解决方案，笑傲分布式开发&quot;&gt;&lt;/a&gt;玩转N种企业级解决方案，笑傲分布式开发&lt;/h1&gt;&lt;ul&gt;
</summary>
      
    
    
    
    <category term="distributed" scheme="https://ratears.github.io/dev.ratears.life/Categories/distributed/"/>
    
    
    <category term="distributed" scheme="https://ratears.github.io/dev.ratears.life/Tags/distributed/"/>
    
  </entry>
  
  <entry>
    <title>《Java分布式架构设计与开发实战》study notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/%E3%80%8AJava%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E3%80%8Bstudy-notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/%E3%80%8AJava%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E3%80%8Bstudy-notes/</id>
    <published>2023-02-22T04:06:25.000Z</published>
    <updated>2023-02-22T04:06:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="课程导学与学习指南"><a href="#课程导学与学习指南" class="headerlink" title="课程导学与学习指南"></a>课程导学与学习指南</h1><ul><li>课程内容设计（结合实际应用场景）</li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.73j7o3a193k0.webp" width="70%"><br><ul><li>内容兼具深度、广度</li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.oxikmcilqsw.webp" width="70%"><br><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.41p3fu3lo7i0.webp" width="70%"><br><br><br><h1 id="硅步千里，分布式理论加强内功修炼"><a href="#硅步千里，分布式理论加强内功修炼" class="headerlink" title="硅步千里，分布式理论加强内功修炼"></a>硅步千里，分布式理论加强内功修炼</h1><h2 id="本章节目标"><a href="#本章节目标" class="headerlink" title="本章节目标"></a>本章节目标</h2><ul><li>了解大型互联网系统演进</li><li>掌握架构设计思想</li><li>掌握CAP理论</li><li>掌握BASE理论</li></ul><br><ul><li>中国互联网发展历程<ul><li>1994 - 2000年:从四大门户到搜索</li><li>2001-2009年:从搜索到社交化网络</li><li>2010- 至今:移动互联网和自媒体</li></ul></li></ul><br><h2 id="单体应用架构到分布式架构的演进"><a href="#单体应用架构到分布式架构的演进" class="headerlink" title="单体应用架构到分布式架构的演进"></a>单体应用架构到分布式架构的演进</h2><ul><li>单体应用架构<ul><li>Linux+Apache+MySQL+PHP</li><li>网站刚起步的时候，流量少。用一台服务器就可以满足</li></ul></li><li>应用服务与数据服务分离<ul><li>访问增加，带来更大压力</li><li>增加配置解决临时问题</li><li>从横向进行扩展，一分为多</li></ul></li><li>不同服务器配置要求不同</li></ul><table><thead><tr><th align="center">服务器类型</th><th align="center">不同配置要求</th></tr></thead><tbody><tr><td align="center">应用服务器</td><td align="center">CPU配置高</td></tr><tr><td align="center">数据库服务器</td><td align="center">磁盘IO快和稳，内存足够大</td></tr><tr><td align="center">文件服务器</td><td align="center">磁盘足够大</td></tr></tbody></table><ul><li><p>开始引入缓存</p><ul><li>大量交易访问数据库压力增大，响应延迟</li><li>给数据库减负，把请求在前面就处理完</li><li>在数据库前面加入缓存</li></ul></li><li><p>应用服务器集群部署</p><ul><li>所有的请求直接打到负载均衡组件</li><li>单台服务器 &gt;多台服务器</li><li>软件: Apache / Nginx / HaProxy / LVS</li><li>硬件:F5</li></ul></li><li><p>数据库的读写分离</p><ul><li>并非所有请求都操作缓存，且存在缓存失效场景，对数据库访问造成压力</li><li>利用数据库主从复制机制，将读和写操作分开，进一步提升性能</li></ul></li><li><p>数据库访问模块</p><ul><li>对接多个数据源、处理读写分离、甚至分库分表等</li><li>独立于应用程序存在的</li><li>Apache ShardingSphere</li></ul></li><li><p>内容分发网络 - CDN</p></li><li><p>CDN服务进行资源加速</p><ul><li>把静态资源提前缓存到各地的边缘服务器</li><li>可以有效地降低DDoS攻击</li></ul></li><li><p>全面分布式化</p><ul><li>随着规模不断发展产生数据越来越多，单文件件服务器、单数据库服务器也渐渐地达到瓶颈。利用集群化横向扩展解决问题</li><li>HDFS、TFS、FastDFS</li><li>NoSQL &amp; 搜索引擎<ul><li>Lucene是一个搜索引擎的开发工具包:全文检索</li><li>Solr和Elasticsearch它们是基于Lucene开发的</li><li>常见的NoSQL有Mongodb和ELasticsearch</li></ul></li></ul></li><li><p><strong>单体应用面临诸多问题和挑战</strong></p><ul><li>单体应用的代码膨胀，研发成本变高，难实现敏捷交付</li><li>代码维护成本变高，开发人员交接困难</li><li>测试成本变高，回归的工作量变大，给测试带来巨大工作量</li><li>可扩展性差，技术升级时需考虑整体，无法单独调整</li></ul></li><li><p>“大而全的单体”拆分为多个“独立的应用”</p></li><li><p>应用拆分和解耦</p><ul><li>对应用模块进行拆分之后，通过消息中间件进行交互</li><li>此外还有异步处理应用解耦、流量削峰等作用</li></ul></li><li><p>常见的消息中间件</p></li></ul><table><thead><tr><th align="center">消息中间件特性</th><th></th></tr></thead><tbody><tr><td align="center">ActiveMQ</td><td>历史悠久，使用Java语言编写的，功能全面，基本上MQ的功能它都有，因此也比较复杂。</td></tr><tr><td align="center">RabbitMQ</td><td>目前主流之一，跟Spring框架师出同门，因此Spring对RabbitMQ的支持最好</td></tr><tr><td align="center">Kafka</td><td>高性能方面比较有优势。但一开始是基于大吞吐量数据场景设计，在消息可靠性方面比较弱</td></tr><tr><td align="center">RocketMQ</td><td>它相对前面几个，有后发优势，结合了各方优点综合能力比较好。</td></tr></tbody></table><ul><li>模块拆分引发的问题<ul><li>代码冗余，多处相同的代码维护起来困难</li><li>复杂度扩散</li><li>共用一套数据库资源</li></ul></li></ul><br><h2 id="引入服务化架构"><a href="#引入服务化架构" class="headerlink" title="引入服务化架构"></a>引入服务化架构</h2><h3 id="SOA与微服务对比"><a href="#SOA与微服务对比" class="headerlink" title="SOA与微服务对比"></a>SOA与微服务对比</h3><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.2zz2vosvmw60.webp" width="70%"><br><table><thead><tr><th align="center"></th><th>SOA</th><th>微服务</th></tr></thead><tbody><tr><td align="center">共同点</td><td>都是在分布式环境下，以服务为中心的松耦合应用架构模式服务之间是通过定义明确的接口和协议来进行相互通信</td><td>都是在分布式环境下，以服务为中心的松耦合应用架构模式服务之间是通过定义明确的接口和协议来进行相互通信</td></tr><tr><td align="center">目标</td><td>解决的是异构系统的服务化</td><td>解决互联网系统快速交付</td></tr><tr><td align="center">规模</td><td>相对粗粒度</td><td>细粒度</td></tr><tr><td align="center">适用性</td><td>跨企业、大企业跨部门的复杂应用系统建设</td><td>适合小型团队的持续化发布</td></tr></tbody></table><h1 id="为快不破，分布式缓存提升系统性能"><a href="#为快不破，分布式缓存提升系统性能" class="headerlink" title="为快不破，分布式缓存提升系统性能"></a>为快不破，分布式缓存提升系统性能</h1><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><p>1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;课程导学与学习指南&quot;&gt;&lt;a href=&quot;#课程导学与学习指南&quot; class=&quot;headerlink&quot; title=&quot;课程导学与学习指南&quot;&gt;&lt;/a&gt;课程导学与学习指南&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;课程内容设计（结合实际应用场景）&lt;/li&gt;
&lt;/ul&gt;
&lt;img src</summary>
      
    
    
    
    <category term="distributed" scheme="https://ratears.github.io/dev.ratears.life/Categories/distributed/"/>
    
    
    <category term="distributed" scheme="https://ratears.github.io/dev.ratears.life/Tags/distributed/"/>
    
  </entry>
  
  <entry>
    <title>Redis study notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/Redis-study-notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/Redis-study-notes/</id>
    <published>2023-02-18T22:45:02.000Z</published>
    <updated>2023-02-18T22:45:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NoSQL-简介"><a href="#NoSQL-简介" class="headerlink" title="NoSQL 简介"></a>NoSQL 简介</h1><ul><li>NoSQL（“non-relational”， “Not Only SQL”），泛指非关系型的数据库。随着互联网 web2.0网站的兴起，传统的关系数据库在处理 web2.0 网站，特别是超大规模和高并发的 SNS 类型的 web2.0 纯动态网站已经显得力不从心，出现了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL 数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，特别是大数据应用难题。</li></ul><br><h2 id="键值存储数据库"><a href="#键值存储数据库" class="headerlink" title="键值存储数据库"></a>键值存储数据库</h2><ul><li>就像 Map 一样的 key-value 对。典型代表就是 Redis。</li></ul><br><h2 id="列存储数据库"><a href="#列存储数据库" class="headerlink" title="列存储数据库"></a>列存储数据库</h2><ul><li>关系型数据库是典型的行存储数据库。其存在的问题是，按行存储的数据在物理层面占用的是连续存储空间，不适合海量数据存储。而按列存储则可实现分布式存储，适合海量存储。典型代表是 HBase。</li></ul><br><h2 id="文档型数据库"><a href="#文档型数据库" class="headerlink" title="文档型数据库"></a>文档型数据库</h2><ul><li> NoSQL 与关系型数据的结合，最像关系型数据库的 NoSQL。典型代表是 MongoDB。</li></ul><br><h2 id="图形-Graph-数据库"><a href="#图形-Graph-数据库" class="headerlink" title="图形(Graph) 数据库"></a>图形(Graph) 数据库</h2><ul><li>用于存放一个节点关系的数据库，例如描述不同人间的关系。典型代表是 Neo4J。</li></ul><br><br><br><h1 id="NoSQL-VS-关系型数据库"><a href="#NoSQL-VS-关系型数据库" class="headerlink" title="NoSQL VS 关系型数据库"></a>NoSQL VS 关系型数据库</h1><ul><li></li></ul><br><br><br><h1 id="Redis-概述"><a href="#Redis-概述" class="headerlink" title="Redis 概述"></a>Redis 概述</h1><h2 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h2><ul><li>Redis，Remote Dictionary Server，远程字典服务，由意大利人 Salvatore Sanfilippo（又名 Antirez）开发，是一个使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、NoSQL 开源内存数据库，其提供多种语言的 API。从 2010 年 3 月 15 日起，Redis 的开发工作由 VMware 主持。从2013 年 5 月开始，Redis 的开发由 Pivotal 赞助。</li><li>2008 年时 Salvatore Sanfilippo 自己开发一个叫 LLOOGG 的网站。</li><li>Redis之所以称之为字典服务，是因为 Redis 是一个 key-value存储系统。支持存储的 value类型很多，包括 String(字符串)、List(链表)、Set(集合)、Zset(sorted set –有序集合)和 Hash（哈希类型）等。</li><li>Redis 的国际知名用户有，Twitter、GitHub、Facebook 等，国内知名用户有，阿里巴巴、腾讯、百度、搜狐、优酷、美团、小米等。熟练使用和运维 Redis 已经成为开发运维人员的一个必备技能。</li></ul><br><h2 id="Redis-的用途"><a href="#Redis-的用途" class="headerlink" title="Redis 的用途"></a>Redis 的用途</h2><h3 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h3><ul><li>客户端从 DBMS（Database Management System） 中查询出的数据首先写入到 Redis 中，后续无论哪个客户端再需要访问该数据，直接读取 Redis 中的即可，不仅减小了 RT（response time 简称RT，响应时间：从系统接收请求开始到返回响应之间的时间跨度），而且降低了 DBMS 的压力。</li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/1677190973987.1jn6209v28ww.webp" width="70%"><br><ul><li>根据 Redis 缓存的数据与 DBMS 中数据的同步性划分，缓存一般可划分为两类：实时同步缓存，与阶段性同步缓存。</li><li>实时同步缓存是指，DBMS 中数据更新后，Redis 缓存中的存放的相关数据会被立即清除，以促使再有对该数据的访问请求到来时，必须先从 DBMS 中查询获取到最新数据，然后再写入到 Redis。</li><li>阶段性同步缓存是指，Redis 缓存中的数据允许在一段时间内与 DBMS 中的数据不完全一致。而这个时间段就是这个缓存数据的过期时间。</li></ul><br><h2 id="Redis-的特性"><a href="#Redis-的特性" class="headerlink" title="Redis 的特性"></a>Redis 的特性</h2><blockquote><p>能够做缓存的技术、中间件很多，例如，MyBatis 自带的二级缓存、Memched 等。之所以在生产中做缓存的产品几乎无一例外的会选择 Redis，是因为它有很多其它产品所不具备的特性。</p></blockquote><ul><li>性能极高：Redis 读的速度可以达到 11w 次/s，写的速度可以达到 8w 次/s。</li></ul><blockquote><p>之所以具有这么高的性能，因为以下几点原因：</p><p>（1）Redis 的所有操作都是在内存中发生的。</p><p>（2）Redis 是用 C 语言开发的。</p><p>（3）Redis 源码非常精细（集性能与优雅于一身）。</p></blockquote><ul><li>简单稳定：Redis 源码很少。早期版本只有 2w 行左右。从 3.0 版本开始，增加了集群功能，代码变为了 5w 行左右。</li><li>持久化：Redis 内存中的数据可以进行持久化，其有两种方式：RDB 与 AOF。</li><li>高可用集群：Redis 提供了高可用的主从集群功能，可以确保系统的安全性。</li><li>丰富的数据类型：Redis 是一个 key-value 存储系统。支持存储的 value 类型很多，包括String(字符串)、List(链表)、Set(集合)、Zset(sorted set –有序集合)和 Hash（哈希类型）等，还有 BitMap、HyperLogLog、Geospatial 类型。<ul><li>BitMap：一般用于大数据量的二值性统计</li><li>HyperLogLog：其是 Hyperlog Log，用于对数据量超级庞大的日志做去重统计</li><li>Geospatial：地理空间，其主要用于地理位置相关的计算</li></ul></li><li>强大的功能：Redis 提供了数据过期功能、发布/订阅功能、简单事务功能，还支持 Lua脚本扩展功能。</li><li>客户端语言广泛：Redis提供了简单的TCP通信协议，编程语言可以方便地的接入Redis。所以，有很多的开源社区、大公司等开发出了很多语言的 Redis 客户端。</li><li>支持 ACL 权限控制：之前的权限控制非常笨拙。从 Redis6 开始引入了 ACL 模块，可以为不同用户定制不同的用户权限。</li></ul><blockquote><ul><li>ACL，Access Control List，访问控制列表，是一种细粒度的权限管理策略，可以针对任意用户与组进行权限控制。目前大多数 Unix 系统与 Linux 2.6 版本已经支持 ACL 了。</li><li>Zookeeper 早已支持 ACL 了。</li><li>Unix 与 Linux 系统默认使用是 UGO（User、Group、Other）权限控制策略，其是一种粗粒度的权限管理策略。</li></ul></blockquote><ul><li>支持多线程 IO 模型：Redis 之前版本采用的是单线程模型，从 6.0 版本开始支持了多线程模型。</li></ul><br><h2 id="Redis-的IO模型"><a href="#Redis-的IO模型" class="headerlink" title="Redis 的IO模型"></a>Redis 的IO模型</h2><ul><li>Redis 客户端提交的各种请求是如何最终被 Redis 处理的？Redis 处理客户端请求所采用的处理架构，称为 Redis 的 IO 模型。不同版本的 Redis 采用的 IO 模型是不同的</li></ul><h3 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h3><ul><li>对于 Redis 3.0 及其以前版本，Redis 的 IO 模型采用的是<strong>纯粹的单线程模型</strong>。即所有客户端的请求全部由一个线程处理。</li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.6sosx0t4lqw0.webp" width="70%"><br><ul><li>Redis 的单线程模型采用了多路复用技术。</li></ul><blockquote><ul><li>对于多路复用器的多路选择算法常见的有三种：select 模型、poll 模型、epoll 模型。<ul><li>poll 模型的选择算法：采用的是轮询算法。该模型对客户端的就绪处理是有延迟的</li><li>epoll 模型的选择算法：采用的是回调方式。根据就绪事件发生后的处理方式的不同，又可分为 LT 模型与 ET 模型。</li></ul></li></ul></blockquote><ul><li><p>每个客户端若要向 Redis 提交请求，都需要与 Redis 建立一个 socket 连接，并向事件分发器注册一个事件。一旦该事件发生就表明该连接已经就绪。而一旦连接就绪，事件分发器就会感知到，然后获取客户端通过该连接发送的请求，并将由该事件分发器所绑定的这个唯一的线程来处理。如果该线程还在处理多个任务，则将该任务写入到任务队列等待线程处理。</p></li><li><p>之所以称为事件分发器，是因为它会根据不同的就绪事件，将任务交由不同的事件处理<br>器去处理。</p></li></ul><h3 id="混合线程模型"><a href="#混合线程模型" class="headerlink" title="混合线程模型"></a>混合线程模型</h3><ul><li>从 Redis 4.0 版本开始，Redis 中就开始加入了多线程元素。处理客户端请求的仍是单线程模型，但对于一些比较耗时但又不影响对客户端的响应的操作，就由后台其它线程来处理。例如，持久化、对 AOF 的 rewrite、对失效连接的清理等。</li></ul><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><ul><li>Redis 6.0 版本，才是真正意义上的多线程模型。因为其对于客户端请求的处理采用的是多线程模型。</li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.7ge3bn7lv0o0.webp" width="70%"><br><ul><li>多线程 IO 模型中的“多线程”仅用于接受、解析客户端的请求，然后将解析出的请求写入到任务队列。而对具体任务（命令）的处理，仍是由主线程处理。这样做使得用户无需考虑线程安全问题，无需考虑事务控制，无需考虑像 LPUSH/LPOP 等命令的执行顺序问题。</li></ul><h3 id="Redis-的-IO-模型优缺点总结"><a href="#Redis-的-IO-模型优缺点总结" class="headerlink" title="Redis 的 IO 模型优缺点总结"></a>Redis 的 IO 模型优缺点总结</h3><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>单线程模型</td><td>可维护性高，性能高。<br/>不存在并发读写情况，所以也就不存在执行顺序的不确定性，不存在线程切换开销，不存在死锁问题，不存在为了数据安全而进行的加锁/解锁开销。</td><td>性能会受到影响，且由于单线程只能使用一个处理器，所以会形成处理器浪费。</td></tr><tr><td>多线程模型</td><td>其结合了多线程与单线程的优点，避开了它们的所有不足</td><td>该模型没有显示不足。<br/>如果非要找其不足的话就是，其并非是一个真正意义上的“多线程”，因为真正处理“任务”的线程仍是单线程。所以，其对性能也是有些影响的。</td></tr></tbody></table><br><br><br><h1 id="Redis-的安装与配置"><a href="#Redis-的安装与配置" class="headerlink" title="Redis 的安装与配置"></a>Redis 的安装与配置</h1><h2 id="Redis-的安装"><a href="#Redis-的安装" class="headerlink" title="Redis 的安装"></a>Redis 的安装</h2><h3 id="安装前的准备工作"><a href="#安装前的准备工作" class="headerlink" title="安装前的准备工作"></a>安装前的准备工作</h3><ul><li>服务器选择CentOS 7.x，需要安装 gcc、gcc-c++</li></ul><blockquote><p>由于 Redis 是由 C/C++语言编写的，而从官网下载的 Redis 安装包是需要编译后才可安装的，所以对其进行编译就必须要使用相关编译器。对于 C/C++语言的编译器，使用最多的是gcc与gcc-c++，而这两款编译器在CentOS7中是没有安装的，所以首先要安装这两款编译器。</p><p>GCC，GNU Compiler Collection，GNU 编译器集合。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc gcc-c++</span><br></pre></td></tr></table></figure><h3 id="下载-上传-Redis-安装包"><a href="#下载-上传-Redis-安装包" class="headerlink" title="下载/上传 Redis 安装包"></a>下载/上传 Redis 安装包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/</span><br><span class="line">wget https://github.com/redis/redis/archive/7.0.8.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf 7.0.8.tar.gz</span><br><span class="line"></span><br><span class="line">[root@localhost opt]# ls</span><br><span class="line">7.0.8.tar.gz  redis-7.0.8</span><br></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><ul><li>编译过程是根据 Makefile 文件进行的，而 Redis 解压包中已经存在该文件了。所以可以直接进行编译了。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# cd /opt/redis-7.0.8/</span><br><span class="line">[root@localhost redis-7.0.8]# ll</span><br><span class="line">total 264</span><br><span class="line">-rw-rw-r--  1 root root  40942 Jan 17 00:40 00-RELEASENOTES</span><br><span class="line">-rw-rw-r--  1 root root     51 Jan 17 00:40 BUGS</span><br><span class="line">-rw-rw-r--  1 root root   5027 Jan 17 00:40 CODE_OF_CONDUCT.md</span><br><span class="line">-rw-rw-r--  1 root root   2634 Jan 17 00:40 CONTRIBUTING.md</span><br><span class="line">-rw-rw-r--  1 root root   1487 Jan 17 00:40 COPYING</span><br><span class="line">drwxrwxr-x  7 root root    119 Jan 17 00:40 deps</span><br><span class="line">-rw-rw-r--  1 root root     11 Jan 17 00:40 INSTALL</span><br><span class="line">-rw-rw-r--  1 root root    151 Jan 17 00:40 Makefile</span><br><span class="line">-rw-rw-r--  1 root root   6888 Jan 17 00:40 MANIFESTO</span><br><span class="line">-rw-rw-r--  1 root root  22441 Jan 17 00:40 README.md</span><br><span class="line">-rw-rw-r--  1 root root 106545 Jan 17 00:40 redis.conf</span><br><span class="line">-rwxrwxr-x  1 root root    279 Jan 17 00:40 runtest</span><br><span class="line">-rwxrwxr-x  1 root root    283 Jan 17 00:40 runtest-cluster</span><br><span class="line">-rwxrwxr-x  1 root root   1613 Jan 17 00:40 runtest-moduleapi</span><br><span class="line">-rwxrwxr-x  1 root root    285 Jan 17 00:40 runtest-sentinel</span><br><span class="line">-rw-rw-r--  1 root root   1695 Jan 17 00:40 SECURITY.md</span><br><span class="line">-rw-rw-r--  1 root root  14005 Jan 17 00:40 sentinel.conf</span><br><span class="line">drwxrwxr-x  4 root root   8192 Jan 17 00:40 src</span><br><span class="line">drwxrwxr-x 11 root root    199 Jan 17 00:40 tests</span><br><span class="line">-rw-rw-r--  1 root root   3055 Jan 17 00:40 TLS.md</span><br><span class="line">drwxrwxr-x  8 root root   4096 Jan 17 00:40 utils</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-7.0.8]# make</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">    LINK redis-server</span><br><span class="line">    INSTALL redis-sentinel</span><br><span class="line">    CC redis-cli.o</span><br><span class="line">    CC redisassert.o</span><br><span class="line">    CC cli_common.o</span><br><span class="line">    LINK redis-cli</span><br><span class="line">    CC redis-benchmark.o</span><br><span class="line">    LINK redis-benchmark</span><br><span class="line">    INSTALL redis-check-rdb</span><br><span class="line">    INSTALL redis-check-aof</span><br><span class="line"></span><br><span class="line">Hint: It&#x27;s a good idea to run &#x27;make test&#x27; ;)</span><br><span class="line"></span><br><span class="line">make[1]: Leaving directory `/opt/redis-7.0.8/src&#x27;</span><br><span class="line">[root@localhost redis-7.0.8]#</span><br></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>在 Linux 中对于编译过的安装包执行 <code>make install</code> 进行安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-7.0.8]# make install</span><br><span class="line">cd src &amp;&amp; make install</span><br><span class="line">which: no python3 in (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin)</span><br><span class="line">make[1]: Entering directory `/opt/redis-7.0.8/src&#x27;</span><br><span class="line">    CC Makefile.dep</span><br><span class="line">make[1]: Leaving directory `/opt/redis-7.0.8/src&#x27;</span><br><span class="line">which: no python3 in (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin)</span><br><span class="line">make[1]: Entering directory `/opt/redis-7.0.8/src&#x27;</span><br><span class="line"></span><br><span class="line">Hint: It&#x27;s a good idea to run &#x27;make test&#x27; ;)</span><br><span class="line"></span><br><span class="line">    INSTALL redis-server</span><br><span class="line">    INSTALL redis-benchmark</span><br><span class="line">    INSTALL redis-cli</span><br><span class="line">make[1]: Leaving directory `/opt/redis-7.0.8/src&#x27;</span><br><span class="line">[root@localhost redis-7.0.8]#</span><br></pre></td></tr></table></figure><ul><li>至此，Redis安装完成。可以看到，共安装了三个组件：redis 服务器、客户端与一个性能测试工具 benchmark。</li></ul><h3 id="查看-bin-目录"><a href="#查看-bin-目录" class="headerlink" title="查看 bin 目录"></a>查看 bin 目录</h3><ul><li>安装完成后，打开/usr/local/bin 目录，可以看到出现了很多的文件。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# cd /usr/local/bin/</span><br><span class="line">[root@localhost bin]# ll</span><br><span class="line">total 21560</span><br><span class="line">-rwxr-xr-x 1 root root    32592 Mar 26  2021 earlyoom</span><br><span class="line">-rwxr-xr-x 1 root root  5198152 Feb 24 07:07 redis-benchmark</span><br><span class="line">lrwxrwxrwx 1 root root       12 Feb 24 07:07 redis-check-aof -&gt; redis-server</span><br><span class="line">lrwxrwxrwx 1 root root       12 Feb 24 07:07 redis-check-rdb -&gt; redis-server</span><br><span class="line">-rwxr-xr-x 1 root root  5411488 Feb 24 07:07 redis-cli</span><br><span class="line">lrwxrwxrwx 1 root root       12 Feb 24 07:07 redis-sentinel -&gt; redis-server</span><br><span class="line">-rwxr-xr-x 1 root root 11427160 Feb 24 07:07 redis-server</span><br></pre></td></tr></table></figure><ul><li>通过 <code>echo $PATH</code> 可以看到，/usr/local/bin 目录是存在于该系统变量中的，这样这些命令就可以在任意目录中执行了。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure><br><h2 id="Redis-启动与停止"><a href="#Redis-启动与停止" class="headerlink" title="Redis 启动与停止"></a>Redis 启动与停止</h2><h3 id="前台启动"><a href="#前台启动" class="headerlink" title="前台启动"></a>前台启动</h3><ul><li>在任意目录执行redis-server命令即可启动Redis。这种启动方式会占用当前命令行窗口。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# redis-server</span><br><span class="line">6717:C 24 Feb 2023 07:13:54.221 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">6717:C 24 Feb 2023 07:13:54.221 # Redis version=7.0.8, bits=64, commit=00000000, modified=0, pid=6717, just started</span><br><span class="line">6717:C 24 Feb 2023 07:13:54.221 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf</span><br><span class="line">6717:M 24 Feb 2023 07:13:54.221 * monotonic clock: POSIX clock_gettime</span><br><span class="line">                _._</span><br><span class="line">           _.-``__ &#x27;&#x27;-._</span><br><span class="line">      _.-``    `.  `_.  &#x27;&#x27;-._           Redis 7.0.8 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ &#x27;&#x27;-._</span><br><span class="line"> (    &#x27;      ,       .-`  | `,    )     Running in standalone mode</span><br><span class="line"> |`-._`-...-` __...-.``-._|&#x27;` _.-&#x27;|     Port: 6379</span><br><span class="line"> |    `-._   `._    /     _.-&#x27;    |     PID: 6717</span><br><span class="line">  `-._    `-._  `-./  _.-&#x27;    _.-&#x27;</span><br><span class="line"> |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|</span><br><span class="line"> |    `-._`-._        _.-&#x27;_.-&#x27;    |           https://redis.io</span><br><span class="line">  `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;</span><br><span class="line"> |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|</span><br><span class="line"> |    `-._`-._        _.-&#x27;_.-&#x27;    |</span><br><span class="line">  `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;</span><br><span class="line">      `-._    `-.__.-&#x27;    _.-&#x27;</span><br><span class="line">          `-._        _.-&#x27;</span><br><span class="line">              `-.__.-&#x27;</span><br><span class="line"></span><br><span class="line">6717:M 24 Feb 2023 07:13:54.221 # Server initialized</span><br><span class="line">6717:M 24 Feb 2023 07:13:54.221 # WARNING Memory overcommit must be enabled! Without it, a background save or replication may fail under low memory condition. Being disabled, it can can also cause failures without low memory condition, see https://github.com/jemalloc/jemalloc/issues/1328. To fix this issue add &#x27;vm.overcommit_memory = 1&#x27; to /etc/sysctl.conf and then reboot or run the command &#x27;sysctl vm.overcommit_memory=1&#x27; for this to take effect.</span><br><span class="line">6717:M 24 Feb 2023 07:13:54.222 * Ready to accept connections</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>再开启一个会话窗口，可以查看到当前的 Redis 进程，默认端口号为 6379。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -ef |grep redis</span><br><span class="line">root      6717  2057  0 07:13 pts/2    00:00:00 redis-server *:6379</span><br><span class="line">root      6755  6726  0 07:14 pts/3    00:00:00 grep --color=auto redis</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="命令式后台启动"><a href="#命令式后台启动" class="headerlink" title="命令式后台启动"></a>命令式后台启动</h3><ul><li>使用 nohub 命令，最后再添加一个&amp;符，可以使要启动的程序在后台以守护进程方式运行。这样的好处是，进程启动后不会占用一个会话窗口，且其还会在当前目录，即运行启动命令的当前目录中创建一个 nohup.out 文件用于记录 Redis 的操作日志。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup redis-server &amp;</span><br></pre></td></tr></table></figure><h3 id="配置式后台启动"><a href="#配置式后台启动" class="headerlink" title="配置式后台启动"></a>配置式后台启动</h3><ul><li>使用 nohup 命令可以使 Redis 后台启动，但每次都要键入 nohup 与&amp;符，比较麻烦。可以通过修改 Linux 中 Redis 的核心配置文件 redis.conf 达到后台启动的目的。redis.conf 文件在Redis 的安装目录根下。</li></ul><h2 id="Redis-连接前配置"><a href="#Redis-连接前配置" class="headerlink" title="Redis 连接前配置"></a>Redis 连接前配置</h2><h3 id="绑定客户端-IP"><a href="#绑定客户端-IP" class="headerlink" title="绑定客户端 IP"></a>绑定客户端 IP</h3><ul><li>Redis 可以通过修改配置文件来限定可以访问自己的客户端 IP</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">bind</span> 127.0.0.1 -::1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以上设置（默认设置,未注释），只允许当前主机访问当前的 Redis，其它主机均不可访问。所以，如果不想限定访问的客户端，只需要将该行注释掉即可。</span></span><br></pre></td></tr></table></figure><h3 id="关闭保护模式"><a href="#关闭保护模式" class="headerlink" title="关闭保护模式"></a>关闭保护模式</h3><ul><li>默认保护模式是开启的。其只允许本机的客户端访问，即只允许自己访问自己。但生产中应该关闭，以确保其它客户端可以连接 Redis。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected-mode no</span><br></pre></td></tr></table></figure><h3 id="设置访问密码"><a href="#设置访问密码" class="headerlink" title="设置访问密码"></a>设置访问密码</h3><ul><li>为 Redis 设置访问密码，可以对要读/写 Redis 的用户进行身份验证。没有密码的用户可以登录 Redis，但无法访问。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass redis</span><br></pre></td></tr></table></figure><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><ol><li>用途写的太单薄了，需要重构</li><li>缓存划分</li></ol></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NoSQL-简介&quot;&gt;&lt;a href=&quot;#NoSQL-简介&quot; class=&quot;headerlink&quot; title=&quot;NoSQL 简介&quot;&gt;&lt;/a&gt;NoSQL 简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;NoSQL（“non-relational”， “Not Only SQL”），</summary>
      
    
    
    
    <category term="DataBase" scheme="https://ratears.github.io/dev.ratears.life/Categories/DataBase/"/>
    
    <category term="NoSQL" scheme="https://ratears.github.io/dev.ratears.life/Categories/DataBase/NoSQL/"/>
    
    <category term="Redis" scheme="https://ratears.github.io/dev.ratears.life/Categories/DataBase/NoSQL/Redis/"/>
    
    
    <category term="Redis" scheme="https://ratears.github.io/dev.ratears.life/Tags/Redis/"/>
    
    <category term="NoSQL" scheme="https://ratears.github.io/dev.ratears.life/Tags/NoSQL/"/>
    
    <category term="DataBase" scheme="https://ratears.github.io/dev.ratears.life/Tags/DataBase/"/>
    
  </entry>
  
  <entry>
    <title>《Java设计模式精讲 Debug方式+内存分析》study notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/%E3%80%8AJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B2%BE%E8%AE%B2-Debug%E6%96%B9%E5%BC%8F-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E3%80%8Bstudy-notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/%E3%80%8AJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B2%BE%E8%AE%B2-Debug%E6%96%B9%E5%BC%8F-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E3%80%8Bstudy-notes/</id>
    <published>2023-02-18T17:05:28.000Z</published>
    <updated>2023-02-18T17:05:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h1><h2 id="类型与定义"><a href="#类型与定义" class="headerlink" title="类型与定义"></a>类型与定义</h2><ul><li>定义:由一个工厂对象决定创建出哪一种产品类的实例</li><li>类型:创建型，但不属于GOF23种设计模式</li></ul><br><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>工厂类负责创建的对象比较少</li><li>客户端(应用层)只知道传入工厂类的参数，对于如何创建对象(逻辑)不关心</li></ul><br><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>只需要传入一个正确的参数，就可以获取你所需要的对象而无须知道其创建细节</li></ul><br><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>工厂类的职责相对过重，如果增加新的产品需要修改工厂类的判断逻辑，违背开闭原则</li></ul><br><h2 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Coder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">coding</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Javaer</span> <span class="keyword">extends</span> <span class="title class_">Coder</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">coding</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m a Java programmer，I can use Java programming .&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Gopher</span> <span class="keyword">extends</span> <span class="title class_">Coder</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">coding</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m a Go programmer，I can use Go programming .&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoderFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Coder <span class="title function_">createCoder</span><span class="params">(Class clazz)</span> &#123;</span><br><span class="line">        <span class="type">Coder</span> <span class="variable">coder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            coder = (Coder) Class.forName(clazz.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Coder</span> <span class="variable">coder</span> <span class="operator">=</span> CoderFactory.createCoder(Javaer.class);</span><br><span class="line">        coder.coding();</span><br><span class="line"></span><br><span class="line">        Coder coder1= CoderFactory.createCoder(Gopher.class);</span><br><span class="line">        coder1.coding();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="java-util-Calendar"><a href="#java-util-Calendar" class="headerlink" title="java.util.Calendar"></a>java.util.Calendar</h3><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.6ybjgo0ug3o0.webp" width="60%"><br><h3 id="ch-qos-logback-classic-LoggerContext"><a href="#ch-qos-logback-classic-LoggerContext" class="headerlink" title="ch.qos.logback.classic.LoggerContext"></a>ch.qos.logback.classic.LoggerContext</h3><ul><li>其中，既使用到了<strong>简单工厂</strong>又使用到了<strong>工厂方法模式</strong></li></ul><br><br><br><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><h2 id="定义与类型"><a href="#定义与类型" class="headerlink" title="定义与类型"></a>定义与类型</h2><ul><li>定义:定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行</li><li>类型:创建型</li></ul><br><h2 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>创建对象需要大量重复的代码</li><li>客户端(应用层)不依赖于产品类实例如何被创建、实现等细节</li><li>一个类通过其子类来指定创建哪个对象</li></ul><br><h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><ul><li>用户只需要关心所需产品对应的工厂，无须关心创建细节</li><li>加入新产品符合开闭原则，提高可扩展性</li></ul><br><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><ul><li>类的个数容易过多，增加复杂度</li><li>增加了系统的抽象性和理解难度</li></ul><br><h2 id="Coding-1"><a href="#Coding-1" class="headerlink" title="Coding"></a>Coding</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Coder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">coding</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Gopher</span> <span class="keyword">extends</span> <span class="title class_">Coder</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">coding</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m a Go programmer，I can use Go programming .&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Javaer</span> <span class="keyword">extends</span> <span class="title class_">Coder</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">coding</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m a Java programmer，I can use Java programming .&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CoderFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Coder <span class="title function_">createCoder</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GopherFactory</span> <span class="keyword">extends</span> <span class="title class_">CoderFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coder <span class="title function_">createCoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Gopher</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaerFactory</span> <span class="keyword">extends</span> <span class="title class_">CoderFactory</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coder <span class="title function_">createCoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Javaer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CoderFactory</span> <span class="variable">coderFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaerFactory</span>();</span><br><span class="line">        <span class="type">Coder</span> <span class="variable">coder</span> <span class="operator">=</span> coderFactory.createCoder();</span><br><span class="line">        coder.coding();</span><br><span class="line">        <span class="type">CoderFactory</span> <span class="variable">coderFactory2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GopherFactory</span>();</span><br><span class="line">        <span class="type">Coder</span> <span class="variable">coder2</span> <span class="operator">=</span> coderFactory2.createCoder();</span><br><span class="line">        coder2.coding();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h2><ul><li>jdk源码中的 Collection类 <code>Iterator&lt;E&gt; iterator();</code>，就使用了工厂方法，Iterator是抽象产品。ArrayList中有具体实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>jdk源码Luncher类中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Factory</span> <span class="keyword">implements</span> <span class="title class_">URLStreamHandlerFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">PREFIX</span> <span class="operator">=</span> <span class="string">&quot;sun.net.www.protocol&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Factory</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> URLStreamHandler <span class="title function_">createURLStreamHandler</span><span class="params">(String var1)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> PREFIX + <span class="string">&quot;.&quot;</span> + var1 + <span class="string">&quot;.Handler&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">var3</span> <span class="operator">=</span> Class.forName(var2);</span><br><span class="line">            <span class="keyword">return</span> (URLStreamHandler)var3.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ReflectiveOperationException var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">&quot;could not load &quot;</span> + var1 + <span class="string">&quot;system protocol handler&quot;</span>, var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><br><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><h2 id="定义与类型-1"><a href="#定义与类型-1" class="headerlink" title="定义与类型"></a>定义与类型</h2><ul><li>定义: 抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口</li><li>无须指定它们具体的类</li><li>类型:创建型</li></ul><br><h2 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>客户端(应用层)不依赖于产品类实例如何被创建、实现等细节</li><li>强调一系列相关的产品对象(属于同一产品族)一起使用创建对象需要大量重复的代码</li><li>提供一个产品类的库，所有的产品以同样的接口出现从而使客户端不依赖于具体实现</li></ul><br><h2 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h2><ul><li>具体产品在应用层代码隔离，无须关心创建细节</li><li>将一个系列的产品族统一到一起创建</li></ul><br><h2 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h2><ul><li>规定了所有可能被创建的产品集合，产品族中扩展新的产品困难需要修改抽象工厂的接口</li><li>增加了系统的抽象性和理解难度</li></ul><br><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="产品等级结构与产品族"><a href="#产品等级结构与产品族" class="headerlink" title="产品等级结构与产品族"></a>产品等级结构与产品族</h3><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/fdadc29cbe12236d1d5629647483893.26md45jh7ugw.webp" width="70%"><br><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/0c56cc305ffdc39902f3003fdf0e623.hqr3956keq8.webp" width="70%"><br><h2 id="Coding-2"><a href="#Coding-2" class="headerlink" title="Coding"></a>Coding</h2><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.6pduwxhaon80.webp" width="100%"><br><h2 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h2><ul><li>java.sql.connection</li></ul><br><br><br><h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><h2 id="定义与类型-2"><a href="#定义与类型-2" class="headerlink" title="定义与类型"></a>定义与类型</h2><ul><li>定义: 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</li><li>用户只需指定需要建造的类型就可以得到它们，建造过程及细节不需要知道</li><li>类型:创建型</li></ul><br><h2 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>如果一个对象有非常复杂的内部结构(很多属性)</li><li>想把复杂对象的创建和使用分离</li></ul><br><h2 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h2><ul><li>封装性好，创建和使用分离</li><li>扩展性好、建造类之间独立、一定程度上解耦</li></ul><br><h2 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h2><ul><li>产生多余的Builder对象</li><li>产品内部发生变化，建造者都要修改，成本较大</li></ul><br><h2 id="Coding-3"><a href="#Coding-3" class="headerlink" title="Coding"></a>Coding</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String ram;</span><br><span class="line">    <span class="keyword">private</span> String usbCount;</span><br><span class="line">    <span class="keyword">private</span> String keyboard;</span><br><span class="line">    <span class="keyword">private</span> String display;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Computer</span><span class="params">(ComputerBuilder computerBuilder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cpu = computerBuilder.cpu;</span><br><span class="line">        <span class="built_in">this</span>.ram = computerBuilder.ram;</span><br><span class="line">        <span class="built_in">this</span>.usbCount = computerBuilder.usbCount;</span><br><span class="line">        <span class="built_in">this</span>.keyboard = computerBuilder.keyboard;</span><br><span class="line">        <span class="built_in">this</span>.display = computerBuilder.display;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Computer&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, ram=&#x27;&quot;</span> + ram + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, usbCount=&#x27;&quot;</span> + usbCount + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, keyboard=&#x27;&quot;</span> + keyboard + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, display=&#x27;&quot;</span> + display + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ComputerBuilder</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String cpu;</span><br><span class="line">        <span class="keyword">private</span> String ram;</span><br><span class="line">        <span class="keyword">private</span> String usbCount;</span><br><span class="line">        <span class="keyword">private</span> String keyboard;</span><br><span class="line">        <span class="keyword">private</span> String display;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> ComputerBuilder <span class="title function_">buildCpu</span><span class="params">(String cpu)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.cpu=cpu;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> ComputerBuilder <span class="title function_">buildRam</span><span class="params">(String ram)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.ram=ram;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> ComputerBuilder <span class="title function_">buildUsbCount</span><span class="params">(String usbCount)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.usbCount=usbCount;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> ComputerBuilder <span class="title function_">buildKeyboard</span><span class="params">(String keyboard)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.keyboard=keyboard;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> ComputerBuilder <span class="title function_">buildDisplay</span><span class="params">(String display)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.display=display;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Computer <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>.ComputerBuilder().buildCpu(<span class="string">&quot;I7处理器&quot;</span>).buildCpu(<span class="string">&quot;三星125&quot;</span>).build();</span><br><span class="line">    System.out.println(computer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="源码分析-3"><a href="#源码分析-3" class="headerlink" title="源码分析"></a>源码分析</h2><ul><li>java.lang.StringBuilder</li><li>java.lang.StringBuffer</li><li>org.apache.ibatis.session.SqlSessionFactoryBuilder</li></ul><br><br><br><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="定义与类型-3"><a href="#定义与类型-3" class="headerlink" title="定义与类型"></a>定义与类型</h2><ul><li>定义: 指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</li><li>不需要知道任何创建的细节，不调用构造函数</li><li>类型:创建型</li></ul><br><h2 id="适用场景-4"><a href="#适用场景-4" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li></li></ul><br><h2 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h2><ul><li></li></ul><br><h2 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h2><ul><li></li></ul><br><h2 id="Coding-4"><a href="#Coding-4" class="headerlink" title="Coding"></a>Coding</h2><br><h2 id="源码分析-4"><a href="#源码分析-4" class="headerlink" title="源码分析"></a>源码分析</h2><ul><li></li></ul><br><br><br><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="定义与类型-4"><a href="#定义与类型-4" class="headerlink" title="定义与类型"></a>定义与类型</h2><ul><li></li></ul><br><h2 id="适用场景-5"><a href="#适用场景-5" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li></li></ul><br><h2 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h2><ul><li></li></ul><br><h2 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h2><ul><li></li></ul><br><h2 id="Coding-5"><a href="#Coding-5" class="headerlink" title="Coding"></a>Coding</h2><br><h2 id="源码分析-5"><a href="#源码分析-5" class="headerlink" title="源码分析"></a>源码分析</h2><ul><li></li></ul><br><br><br><h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><ol><li>源码分析这块是不是需要加强一下 ？</li><li>建造者模式这块还是要好好熟悉手写一下，是否面向对象的知识需要好好补充</li></ol></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简单工厂&quot;&gt;&lt;a href=&quot;#简单工厂&quot; class=&quot;headerlink&quot; title=&quot;简单工厂&quot;&gt;&lt;/a&gt;简单工厂&lt;/h1&gt;&lt;h2 id=&quot;类型与定义&quot;&gt;&lt;a href=&quot;#类型与定义&quot; class=&quot;headerlink&quot; title=&quot;类型与定义&quot;&gt;</summary>
      
    
    
    
    <category term="Design Pattern" scheme="https://ratears.github.io/dev.ratears.life/Categories/Design-Pattern/"/>
    
    
    <category term="Design Pattern" scheme="https://ratears.github.io/dev.ratears.life/Tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>《MySQL 必知必会》study notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/%E3%80%8AMySQL-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8Bstudy-notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/%E3%80%8AMySQL-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8Bstudy-notes/</id>
    <published>2023-02-13T07:45:40.000Z</published>
    <updated>2023-02-13T07:45:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="课前准备-2讲"><a href="#课前准备-2讲" class="headerlink" title="课前准备 (2讲)"></a>课前准备 (2讲)</h1><h2 id="开篇词-在实战中学习，是解锁MySQL技能的最佳方法"><a href="#开篇词-在实战中学习，是解锁MySQL技能的最佳方法" class="headerlink" title="开篇词 | 在实战中学习，是解锁MySQL技能的最佳方法"></a>开篇词 | 在实战中学习，是解锁MySQL技能的最佳方法</h2><br><br><br><h2 id="环境准备-带你安装MySQL和图形化管理工具Workbench"><a href="#环境准备-带你安装MySQL和图形化管理工具Workbench" class="headerlink" title="环境准备 | 带你安装MySQL和图形化管理工具Workbench"></a>环境准备 | 带你安装MySQL和图形化管理工具Workbench</h2><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><p>1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;课前准备-2讲&quot;&gt;&lt;a href=&quot;#课前准备-2讲&quot; class=&quot;headerlink&quot; title=&quot;课前准备 (2讲)&quot;&gt;&lt;/a&gt;课前准备 (2讲)&lt;/h1&gt;&lt;h2 id=&quot;开篇词-在实战中学习，是解锁MySQL技能的最佳方法&quot;&gt;&lt;a href=&quot;#开篇词</summary>
      
    
    
    
    <category term="DataBase" scheme="https://ratears.github.io/dev.ratears.life/Categories/DataBase/"/>
    
    <category term="MySQL" scheme="https://ratears.github.io/dev.ratears.life/Categories/DataBase/MySQL/"/>
    
    
    <category term="DataBase" scheme="https://ratears.github.io/dev.ratears.life/Tags/DataBase/"/>
    
    <category term="MySQL" scheme="https://ratears.github.io/dev.ratears.life/Tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>《高并发 高性能 高可用 MySQL 实战》study notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/%E3%80%8A%E9%AB%98%E5%B9%B6%E5%8F%91-%E9%AB%98%E6%80%A7%E8%83%BD-%E9%AB%98%E5%8F%AF%E7%94%A8-MySQL-%E5%AE%9E%E6%88%98%E3%80%8Bstudy-notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/%E3%80%8A%E9%AB%98%E5%B9%B6%E5%8F%91-%E9%AB%98%E6%80%A7%E8%83%BD-%E9%AB%98%E5%8F%AF%E7%94%A8-MySQL-%E5%AE%9E%E6%88%98%E3%80%8Bstudy-notes/</id>
    <published>2023-02-12T18:51:22.000Z</published>
    <updated>2023-02-12T18:51:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h1><h2 id="问卷调查"><a href="#问卷调查" class="headerlink" title="问卷调查"></a>问卷调查</h2><ol><li>你真的搞懂MySQL底层原理了吗?</li><li>你知道如何改善慢查询性能吗?</li><li>你知道如何架设高性能集群吗?</li><li>你知道未来数据库的发展趋势吗?</li></ol><br><ul><li>以上，这些问题很重要! 因为<ul><li>工作中: MySQL高性能集群越来越流行</li><li>面试中:深入考察MySQL原理、性能调优</li><li>职业规划:需要根据技术发展方向选择职业路径</li></ul></li></ul><br><h2 id="精通MySQL，应该怎么学"><a href="#精通MySQL，应该怎么学" class="headerlink" title="精通MySQL，应该怎么学"></a>精通MySQL，应该怎么学</h2><blockquote><ol><li>以技术原理作为坚实基础</li><li>以真实场景作为学习环境</li><li>以架构思维作为学习目标</li></ol></blockquote><blockquote><p>下面三点是课程主线：</p></blockquote><br><h3 id="（1）从理论到实战"><a href="#（1）从理论到实战" class="headerlink" title="（1）从理论到实战"></a>（1）从理论到实战</h3><ul><li>从数据表逻辑结构，到优化数据表的性能</li><li>从数据查询原理，到改善慢SQL性能</li><li>从事务原理，到优化事务执行效率</li></ul><br><h3 id="（2）从单点到集群"><a href="#（2）从单点到集群" class="headerlink" title="（2）从单点到集群"></a>（2）从单点到集群</h3><ul><li>从学习单点原理，到掌握集群原理</li><li>从高性能单点，到高性能集群</li><li>从单点快速部署，到集群快速部署</li></ul><br><h3 id="（3）从现在到未来"><a href="#（3）从现在到未来" class="headerlink" title="（3）从现在到未来"></a>（3）从现在到未来</h3><ul><li>从5.x版本，到8.0版本</li><li>从原生单体数据库，到原生分布式数据库</li><li>从学习技术原理，到理解技术趋势</li></ul><br><h2 id="什么是“三高”"><a href="#什么是“三高”" class="headerlink" title="什么是“三高”"></a>什么是“三高”</h2><ul><li>高并发：同时处理的事务数高</li><li>高性能：事务/SQL的执行速度高</li><li>高可用：系统可用时间高</li></ul><br><ul><li><strong>“三高”只是目的，不是手段。手段有：复制、扩展、切换</strong></li></ul><br><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul><li>目的:数据冗余</li><li>手段: binlog传送</li><li>收获:并发量提升、可用性提升</li><li>问题:占用更多硬件资源</li></ul><br><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul><li>目的:扩展数据库容量</li><li>手段:数据分片分库、分表</li><li>收获:性能、并发量的提升</li><li>问题:可能降低可用性</li></ul><br><h3 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h3><ul><li>目的:提高可用性</li><li>手段:主从身份切换</li><li>收获:并发量的提升</li><li>问题:丢失切换时期数据</li></ul><br><h2 id="“三高”的实现"><a href="#“三高”的实现" class="headerlink" title="“三高”的实现"></a>“三高”的实现</h2><ul><li>高并发:通过复制和拓展，将数据分散至多节点</li><li>高性能:复制提升速度，拓展提升容量</li><li>高可用:节点间身份切换保证随时可用</li></ul><br><ul><li><strong>“三高”的集群也是以单点的高性能作为保障的。学习“三高”之前，应该学习如何提高单点性能</strong></li></ul><br><h2 id="如何提升单点性能"><a href="#如何提升单点性能" class="headerlink" title="如何提升单点性能"></a>如何提升单点性能</h2><ul><li><strong>建表:表结构合理，索引高效</strong><ul><li>B+树的数据结构与InnoDB的存储结构</li><li>InnoDB行记录格式的历史与原理</li><li>索引、数据约束、视图的注意事项</li></ul></li><li><strong>查询:优化SQL语句，选择正确索引</strong><ul><li>覆盖索引、索引下推、松散索引的原理与实战</li><li>排序、随机选取、COUNT的优化方法</li><li>索引失效时的排查方向</li></ul></li><li><strong>更新:正确使用锁，合理优化事务</strong><ul><li>MySQL和InnoDB日志体系</li><li>全局锁、表锁、元数据锁、行锁、间隙锁</li><li>死锁的原理与优化方法</li><li>事务与MVCC的原理与性能优化</li></ul></li></ul><br><h2 id="未来数据库发展趋势"><a href="#未来数据库发展趋势" class="headerlink" title="未来数据库发展趋势"></a>未来数据库发展趋势</h2><ul><li>MySQL8.0新特性</li><li>NewSQL数据库</li><li>新一代分布式数据库CockroachDB</li></ul><br><br><br><h1 id="第2章-环境搭建"><a href="#第2章-环境搭建" class="headerlink" title="第2章 环境搭建"></a>第2章 环境搭建</h1><ul><li>准备CentOS7环境</li></ul><br><h2 id="安装MySQL-5-7"><a href="#安装MySQL-5-7" class="headerlink" title="安装MySQL 5.7"></a>安装MySQL 5.7</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cd /install</span><br><span class="line"></span><br><span class="line">wget https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.33-1.el7.x86_64.rpm-bundle.tar</span><br><span class="line"></span><br><span class="line">tar -xvf mysql-5.7.33-1.el7.x86_64.rpm-bundle.tar</span><br><span class="line"></span><br><span class="line">rpm -qa|grep  mariadb</span><br><span class="line">rpm -e --nodeps mariadb-libs-5.5.68-1.el7.x86_64</span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-common-5.7.33-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh --force --nodeps  mysql-community-libs-5.7.33-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-client-5.7.33-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh --force --nodeps  mysql-community-server-5.7.33-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">which mysql</span><br></pre></td></tr></table></figure><br><h2 id="MySQL的启停"><a href="#MySQL的启停" class="headerlink" title="MySQL的启停"></a>MySQL的启停</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl status mysqld.service</span><br><span class="line"></span><br><span class="line">systemctl start mysqld.service</span><br><span class="line"></span><br><span class="line">systemctl stop mysqld.service</span><br></pre></td></tr></table></figure><br><h2 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询安装后的初始化密码</span></span><br><span class="line">grep &#x27;temporary password&#x27; /var/log/mysqld.log</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set password=password(&quot;Happy2023@&quot;);</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set global validate_password_policy=LOW;</span><br><span class="line"></span><br><span class="line">set global validate_password_length=4;</span><br><span class="line"></span><br><span class="line">set password=password(&quot;root&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久打开防火墙3306端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class="line"></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;root&#x27; WITH GRANT OPTION;</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><br><br><br><h1 id="第3章-一个SQL语句如何执行"><a href="#第3章-一个SQL语句如何执行" class="headerlink" title="第3章 一个SQL语句如何执行"></a>第3章 一个SQL语句如何执行</h1><ul><li>有了电子表格，为什么还要数据库?</li></ul><blockquote><ol><li>数据库理论上没有行数上限。单机数据库若行数太多遇到性能问题，可以通过分库分表等技术解决</li><li>数据库有完备的结构化查询语言 (SQL)。Excel结构化查询功能不如数据库强大</li><li>数据库面向软件，提供软件接口。（Excel是文件级别的，直接面向终端用户）</li><li>数据库事务是关系型数据库的核心优势。（Excel没有事务，无法做到不同人的工作同时进行）</li><li>分布式 - 数据库的潜力巨大。数据库具有主备复制、高可用、分布式等形态。Excel天生是单体的，面向文件的</li></ol></blockquote><blockquote><p>电子表格面向个人，以文件为基础，拓展性差</p><p>数据库面向软件，支持事务、拓展性好</p></blockquote><br><h2 id="数据库软件的典型架构是怎样的"><a href="#数据库软件的典型架构是怎样的" class="headerlink" title="数据库软件的典型架构是怎样的?"></a>数据库软件的典型架构是怎样的?</h2><h2 id="常见软件架构"><a href="#常见软件架构" class="headerlink" title="常见软件架构"></a>常见软件架构</h2><h3 id="MVC-分层架构"><a href="#MVC-分层架构" class="headerlink" title="MVC 分层架构"></a>MVC 分层架构</h3><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.6ezeek610880.webp" width="60%"><br><h3 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a>事件驱动架构</h3><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.7ad2smjsads0.webp" width="60%"><br><h3 id="管道-过滤器架构"><a href="#管道-过滤器架构" class="headerlink" title="管道-过滤器架构"></a>管道-过滤器架构</h3><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.4r8jvxiitds0.webp" width="60%"><br><h3 id="微核架构"><a href="#微核架构" class="headerlink" title="微核架构"></a>微核架构</h3><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.jf0g5tzqe2o.webp" width="60%"><br><h2 id="MySQL软件架构是怎样的？"><a href="#MySQL软件架构是怎样的？" class="headerlink" title="MySQL软件架构是怎样的？"></a>MySQL软件架构是怎样的？</h2><ul><li>MySQL的软件架构</li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.7cr8et2ktx00.webp" width="70%"><br><ul><li>以分层架构看MySQL架构</li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.57w74vaulpw0.webp" width="70%"><br><ul><li>以管道过滤器-架构看MySQL架构</li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.32mzf6nvr1q0.webp" width="70%"><br><ul><li>以微核-架构看MySQL架构</li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.76a2jv90tok0.webp" width="70%"><br><ul><li>软件工程当中有很多经典的架构设计</li><li>大型软件往往不是使用单一的架构设计，而是多种混合</li><li>研究问题要有清晰的视野，分清楚微观和宏观</li><li>理论要灵活实践，不要死读书</li></ul><br><h2 id="客户端怎样连接MySQL数据库"><a href="#客户端怎样连接MySQL数据库" class="headerlink" title="客户端怎样连接MySQL数据库"></a>客户端怎样连接MySQL数据库</h2><h3 id="客户端与MySQL的连接方式"><a href="#客户端与MySQL的连接方式" class="headerlink" title="客户端与MySQL的连接方式"></a>客户端与MySQL的连接方式</h3><ul><li><strong>TCP/IP 连接</strong><ul><li>TCP/IP 连接是MySQL在任何平台上都提供的连接方法</li><li>TCP/IP是目前互联网最主流的网络连接方式</li></ul></li><li><strong>命名管道</strong><ul><li>命名管道:同一台服务器通讯 (Windows)</li><li>命名管道开启方式:–enable-named-pipe</li></ul></li><li><strong>共享内存</strong><ul><li>服务端:配置-shared-memory</li><li>客户端:配置-protocol=memory</li></ul></li><li><strong>UNIX套接字</strong><ul><li>服务端:配置-socket=/tmp/mysql.sock</li><li>客户端:配置-S =/tmp/mysql.sock</li></ul></li></ul><br><h3 id="MySQL-TCP通讯协议"><a href="#MySQL-TCP通讯协议" class="headerlink" title="MySQL TCP通讯协议"></a>MySQL TCP通讯协议</h3><ul><li><strong>三次握手建立TCP连接</strong></li><li><strong>认证连接</strong><ul><li>服务端-&gt;客户端:发送握手初始化包</li><li>客户端-&gt;服务端:发送验证</li><li>服务端-&gt;客户端:认证结果消息</li></ul></li><li><strong>认证通过之后，客户端开始与服务端之间交互</strong><ul><li>客户端-&gt;服务端:发送命令包(Command Packet)</li><li>服务端-&gt;客户端:发送回应包</li></ul></li><li><strong>断开MySQL连接</strong><ul><li>客户端-&gt;服务器:发送退出命令包</li></ul></li><li><strong>四次握手断开TCP连接</strong></li></ul><br><ul><li>MySQL TCP 报文格式<ul><li>消息头:3字节报文长度、1字节序号</li><li>消息体:1字节指令、其余为参数</li><li>指令举例: 切换数据库(0x02)、查询命令(0x03)</li></ul></li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.19gzatr3rmio.webp" width="70%"><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>TCP/IP 连接是MySQL最常用的连接方式</li><li>TCP/IP连接报文可以作为其他C/S架构的参考</li><li>其他连接方式均限于本机连接，使用范围有限</li></ul><br><h2 id="一个SQL语句是怎样执行的"><a href="#一个SQL语句是怎样执行的" class="headerlink" title="一个SQL语句是怎样执行的"></a>一个SQL语句是怎样执行的</h2><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/e9facc452b4200abad559eb2c9f4c39.380nurymdlm0.webp" width="70%"><br><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><ul><li>之前执行过的语句会KV的形式缓存在内存中</li><li>查询之前先查找之前执行过的相同语句</li><li>不推荐使用缓存:数据表修改后，会删除所有相关缓存</li></ul><br><h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><ul><li>分析器的作用是知道你要“干什么“</li><li>先做词法分析，识别SQL语句中的关键字</li><li>再做句法分析，判断SQL语句是否符合语法</li></ul><br><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><ul><li>优化器的作用是要知道“怎么做”</li><li>优化器的主要工作是决定如何使用索引</li></ul><br><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><ul><li>执行器的主要工作是校验权限、调用存储引擎</li><li>执行器首先校验此用户对目标数据有无权限</li><li>执行器会以行为粒度，调用存储引擎，执行SQL</li><li>在没有索引的情况下，执行器会循环查询所有行</li></ul><br><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><ul><li>存储引擎的任务是将执行器的指令落实在数据文件上</li><li>不同存储引擎的原理和执行方法有很大不同</li></ul><br><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>SQL语句执行的过程涉及到了MySQL几乎所有的模块</li><li>一个SQL语句是按照分析-优化-执行-落盘的步骤执行的</li><li>MySQL8.0之后已经停用了缓存功能</li></ul><br><h2 id="四种常见的MySQL存储引擎"><a href="#四种常见的MySQL存储引擎" class="headerlink" title="四种常见的MySQL存储引擎"></a>四种常见的MySQL存储引擎</h2><ul><li><strong>InnoDB</strong><ul><li>MySQL5.5.5之后的默认存储引擎</li><li>支持事务、外键</li><li>支持崩溃修复能力和并发控制</li></ul></li><li><strong>MyISAM</strong><ul><li>MySQL 5.5.5之前的默认存储引擎</li><li>插入数据快</li><li>空间利用率高</li><li>不支持事务</li></ul></li><li><strong>Memory</strong><ul><li>所有的数据都在内存中，速度快</li><li>数据安全性差</li></ul></li><li><strong>Archive</strong><ul><li>数据压缩、空间利用率高</li><li>插入速度快</li><li>不支持索引，查询性能差</li></ul></li></ul><br><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li>InnoDB是目前最主流的存储引擎，适合各种互联网业务</li><li>查询效率要求非常高的可以考虑MyISAM</li><li>日志信息归档可以考虑Archive</li><li>临时表可以考虑MEMORY</li></ul><br><br><br><h1 id="第4章-如何建表更符合业务"><a href="#第4章-如何建表更符合业务" class="headerlink" title="第4章 如何建表更符合业务"></a>第4章 如何建表更符合业务</h1><h2 id="索引组织表-Index-Organized-Table"><a href="#索引组织表-Index-Organized-Table" class="headerlink" title="索引组织表(Index Organized Table)"></a>索引组织表(Index Organized Table)</h2><ul><li>索引组织表不是一种“组织表“</li><li>索引组织表是由索引“组织起来的”表</li><li>InnoDB中，表都是根据主键顺序组织存放的</li></ul><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><ol><li>大多数情况下，都应该举一反三，比如课程中讲的mysql架构，应该好好熟悉。但是还有呢对应的课程专门讲解mysql架构，所以在本门课程中，我们只需要熟悉最核心的知识，或者熟悉本门课程的知识即可，其它重要的知识点在其它课程中好好学习即可。所以学习其它知识、课程亦是如此。（把握每个课程的重点，各个击破。达到系统掌握整体的目的）</li><li>注意识别课程中提到的知识，哪些是特别重要的，比如本门课程中，常见架构很重要，但是本门课并不专门讲解架构，所以应该后续找对应的课程，学习架构知识。</li><li>课程提到的mysql架构、tcp连接，都是很重要的知识，需要再深入理解。（一些底层基础知识很重要）</li></ol></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="50%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第1章-课程介绍&quot;&gt;&lt;a href=&quot;#第1章-课程介绍&quot; class=&quot;headerlink&quot; title=&quot;第1章 课程介绍&quot;&gt;&lt;/a&gt;第1章 课程介绍&lt;/h1&gt;&lt;h2 id=&quot;问卷调查&quot;&gt;&lt;a href=&quot;#问卷调查&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="DataBase" scheme="https://ratears.github.io/dev.ratears.life/Categories/DataBase/"/>
    
    <category term="MySQL" scheme="https://ratears.github.io/dev.ratears.life/Categories/DataBase/MySQL/"/>
    
    
    <category term="DataBase" scheme="https://ratears.github.io/dev.ratears.life/Tags/DataBase/"/>
    
    <category term="MySQL" scheme="https://ratears.github.io/dev.ratears.life/Tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux 常用基础操作</title>
    <link href="https://ratears.github.io/dev.ratears.life/Linux-%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
    <id>https://ratears.github.io/dev.ratears.life/Linux-%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</id>
    <published>2023-02-11T09:26:36.000Z</published>
    <updated>2023-02-11T09:26:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="SELinux"><a href="#SELinux" class="headerlink" title="SELinux"></a>SELinux</h1><ul><li>SELinux是Linux2.6以上版本捆绑的一个安全模块</li><li>SELinux配置复杂，容易跟其他程序冲突，所以建议关闭</li></ul><ul><li>关闭SELinux</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/selinux/config</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置SELINUX=disabled，重启系统</span></span><br></pre></td></tr></table></figure><br><br><br><h1 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h1><ul><li>替换yum源</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo mirrors.163.com/.help/CentOS7-Base-163.repo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新缓存</span></span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><br><br><br><h1 id="Linux防火墙"><a href="#Linux防火墙" class="headerlink" title="Linux防火墙"></a>Linux防火墙</h1><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><p>1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h1 id=&quot;SELinux&quot;&gt;&lt;a href=&quot;#SELinux&quot; class=&quot;headerlink&quot; title=&quot;SELinux&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="Linux" scheme="https://ratears.github.io/dev.ratears.life/Categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://ratears.github.io/dev.ratears.life/Tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>《阿里新零售数据库设计与实战》study notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/%E3%80%8A%E9%98%BF%E9%87%8C%E6%96%B0%E9%9B%B6%E5%94%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8Bstudy-notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/%E3%80%8A%E9%98%BF%E9%87%8C%E6%96%B0%E9%9B%B6%E5%94%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8Bstudy-notes/</id>
    <published>2023-02-06T00:18:07.000Z</published>
    <updated>2023-02-06T00:18:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>从设计到落地，提升数据库“技术&amp;业务”综合能力</li><li>相当于参与了真实项目的数据库设计[开发经验很难得]</li><li>具备设计完整数据库平台的能力[设计思想要跟上]</li><li>驾驭新零售数据库混合式集群[特别牛的技术]</li></ul><br><br><br><h1 id="新零售是什么"><a href="#新零售是什么" class="headerlink" title="新零售是什么"></a>新零售是什么</h1><ul><li>雷军：新零售是更高效率的零售，我们要从线上回到线下</li><li>马云：线下与线上零售将深度结合，加上现代物流平台，构成未来的新零售</li><li>商务部：以消费者为中心，以技术创新为驱动的零售模新式</li></ul><ul><li>新零售线上业务仅是电商吗？</li></ul><blockquote><p>线上业务不局限于电商，还包括了在线教育、医疗服务，以及金融业务等等</p></blockquote><ul><li>新零售的线下业务</li></ul><blockquote><p>利用云计算、大数据，以及人工智能技术，将客户分流到线下门店中，让用户体验到定制化的服务</p></blockquote><ul><li>新零售平台构成</li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.2hkwqsnfv780.webp" width="60%"><br><br><br><h1 id="前导知识"><a href="#前导知识" class="headerlink" title="前导知识"></a>前导知识</h1><h2 id="Linux环境准备"><a href="#Linux环境准备" class="headerlink" title="Linux环境准备"></a>Linux环境准备</h2><h3 id="关闭SELinux"><a href="#关闭SELinux" class="headerlink" title="关闭SELinux"></a>关闭SELinux</h3><ul><li>SELinux是Linux2.6以上版本捆绑的一个安全模块</li><li>SELinux配置复杂，容易跟其他程序冲突，所以建议关闭</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/selinux/config</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置SELINUX=disabled，重启系统</span></span><br></pre></td></tr></table></figure><br><h3 id="替换yum源"><a href="#替换yum源" class="headerlink" title="替换yum源"></a>替换yum源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo mirrors.163.com/.help/CentOS7-Base-163.repo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新缓存</span></span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><br><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><h3 id="在线安装MySQL"><a href="#在线安装MySQL" class="headerlink" title="在线安装MySQL"></a>在线安装MySQL</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载rpm文件</span></span><br><span class="line">yum localinstall https://repo.mysql.com//mysql80-community-release-el7-1.noarch.rpm</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装MySQL</span></span><br><span class="line">yum install mysal-community-server -y</span><br></pre></td></tr></table></figure><br><h3 id="本地安装MySQL"><a href="#本地安装MySQL" class="headerlink" title="本地安装MySQL"></a>本地安装MySQL</h3><ul><li>离线下载安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载MySQL压缩包文件，并上传到/root/mysql目录</span></span><br><span class="line">mysql-8.0.11-1.el7.x86 64.rpm-bundle.tar</span><br><span class="line"></span><br><span class="line">tar xvf mysgl-8.0.11-1.el7.x86 64.rpm-bundle.tar</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装第三方依赖包</span></span><br><span class="line">yum install perl -y</span><br><span class="line">yum install net-tools -y</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载系统自带的mariadb</span></span><br><span class="line">rpm -qa |grep mariadb</span><br><span class="line">rpm -e mariadb-libs-5.5.68-1.el7.x86_64 --nodeps</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装MySQL程序包</span></span><br><span class="line">rpm -ivh mysql-community-common-8.0.11-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-libs-8.0.11-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-client-8.0.11-1.el7.x86 64.rpm</span><br><span class="line">rpm -ivh mysql-community-server-8.0.11-1.el7.x86 64.rpm</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改/var/lib/mysql目录访问权限</span></span><br><span class="line">chmod -R 777 /var/lib/mysql/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化，初始化数据目录，生成必要的文件，生成root密码</span></span><br><span class="line">mysqld --initialize</span><br><span class="line">chmod -R 777 /var/lib/mysql/*</span><br></pre></td></tr></table></figure><ul><li>启动</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动数据库</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在线安装使用：</span></span><br><span class="line">service mysql start</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">离线本地安装使用：</span></span><br><span class="line">service mysqld start</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看初始化密码</span></span><br><span class="line">grep&#x27;temporary password’ /var/log/mysqld.log</span><br></pre></td></tr></table></figure><ul><li>修改root密码</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本地登录数据库</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改root密码</span></span><br><span class="line">alter user user)) identified by &quot;abc123456&quot;;</span><br></pre></td></tr></table></figure><ul><li>允许root远程登录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许远程使用root账户</span></span><br><span class="line">UPDATE user SET host = %&#x27; WHERE user =&#x27;root&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改/etc/my.cnf文件</span></span><br><span class="line">character set server = utf8</span><br><span class="line">bind-address = 0.0.0.0</span><br></pre></td></tr></table></figure><ul><li>系统防火墙开放3306端口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd--zone=public  --add-port=3306/tcp --permanent</span><br><span class="line"></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><br><h2 id="业务数据库设计流程"><a href="#业务数据库设计流程" class="headerlink" title="业务数据库设计流程"></a>业务数据库设计流程</h2><ul><li>需求分析：根据用户的需求，分析出需要记录的数据</li><li>概要设计：根据分析出的数据，设计ER图</li><li>详细设计：将ER图转换成数据库模型图和数据表</li></ul><br><h2 id="业务数据设计模型"><a href="#业务数据设计模型" class="headerlink" title="业务数据设计模型"></a>业务数据设计模型</h2><ul><li>瀑布模型</li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.3aas4yr220e0.webp" width="40%"><br><ul><li>螺旋模型</li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.66x4m6vejbk0.webp" width="40%"><br><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><p>1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;从设计到落地，提升数据库“技术&amp;amp;业务”综合能力&lt;/li&gt;
&lt;li&gt;相当于参与了真实项目的数据库设计[开发经验很难得]&lt;/</summary>
      
    
    
    
    <category term="DataBase" scheme="https://ratears.github.io/dev.ratears.life/Categories/DataBase/"/>
    
    <category term="MySQL" scheme="https://ratears.github.io/dev.ratears.life/Categories/DataBase/MySQL/"/>
    
    
    <category term="DataBase" scheme="https://ratears.github.io/dev.ratears.life/Tags/DataBase/"/>
    
    <category term="MySQL" scheme="https://ratears.github.io/dev.ratears.life/Tags/MySQL/"/>
    
  </entry>
  
</feed>
