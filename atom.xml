<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ratears</title>
  
  <subtitle>ratears&#39;s blog</subtitle>
  <link href="https://ratears.github.io/dev.ratears.life/atom.xml" rel="self"/>
  
  <link href="https://ratears.github.io/dev.ratears.life/"/>
  <updated>2023-05-29T03:11:38.000Z</updated>
  <id>https://ratears.github.io/dev.ratears.life/</id>
  
  <author>
    <name>ratears</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《MQ消息中间件之RabbitMQ以及整合SpringBoot2.x实战》Study Notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/%E3%80%8AMQ%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E4%BB%A5%E5%8F%8A%E6%95%B4%E5%90%88SpringBoot2-x%E5%AE%9E%E6%88%98%E3%80%8BStudy-Notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/%E3%80%8AMQ%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BRabbitMQ%E4%BB%A5%E5%8F%8A%E6%95%B4%E5%90%88SpringBoot2-x%E5%AE%9E%E6%88%98%E3%80%8BStudy-Notes/</id>
    <published>2023-05-29T03:11:38.000Z</published>
    <updated>2023-05-29T03:11:38.000Z</updated>
    
    <content type="html"><![CDATA[<br><h1 id="RabbitMQ-的引言"><a href="#RabbitMQ-的引言" class="headerlink" title="RabbitMQ 的引言"></a>RabbitMQ 的引言</h1><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p><code>官网</code>: <a class="link"   href="https://www.rabbitmq.com/" >https://www.rabbitmq.com/<i class="fas fa-external-link-alt"></i></a></p><p><code>官方教程</code>: <a class="link"   href="https://www.rabbitmq.com/#getstarted" >https://www.rabbitmq.com/#getstarted<i class="fas fa-external-link-alt"></i></a></p><ul><li>基于<code>AMQP</code>协议，erlang语言开发，是部署最广泛的开源消息中间件,是最受欢迎的开源消息中间件之一。</li></ul><ul><li>AMQP 协议</li></ul><blockquote><p>AMQP（advanced message queuing protocol）`在2003年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题。顾名思义，AMQP是一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。这使得实现了AMQP的provider天然性就是跨平台的。</p></blockquote><h2 id="RabbitMQ-的安装"><a href="#RabbitMQ-的安装" class="headerlink" title="RabbitMQ 的安装"></a>RabbitMQ 的安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.安装Erlang依赖包\</span></span><br><span class="line"><span class="language-bash">wget https://github.com/rabbitmq/erlang-rpm/releases/download/v22.0.7/erlang-22.0.7-1.el7.x86_64.rpm</span></span><br><span class="line">rpm -ivh erlang-22.0.7-1.el7.x86_64.rpm</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.安装RabbitMQ安装包</span></span><br><span class="line">yum install -y rabbitmq-server-3.7.18-1.el7.noarch.rpm</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意:默认安装完成后配置文件模板在:/usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example目录中,需要将配置文件复制到/etc/rabbitmq/目录中,并修改名称为rabbitmq.config</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4.复制配置文件</span></span><br><span class="line">cp /usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example /etc/rabbitmq/rabbitmq.config</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6.修改配置文件</span></span><br><span class="line">vim /etc/rabbitmq/rabbitmq.config</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">去掉注释，去掉行尾逗号</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">7.执行如下命令,启动rabbitmq中的插件管理</span></span><br><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">8.RabbitMQ的服务的管理</span></span><br><span class="line">systemctl start rabbitmq-server</span><br><span class="line">systemctl restart rabbitmq-server</span><br><span class="line">systemctl stop rabbitmq-server</span><br><span class="line">systemctl status rabbitmq-server</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭防火墙服务</span></span><br><span class="line">systemctl disable firewalld</span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">访问rabbit web管理界面</span></span><br><span class="line">http://ip:15672/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登录管理界面</span></span><br><span class="line">username:  guest</span><br><span class="line">password:  guest</span><br></pre></td></tr></table></figure><h1 id="RabiitMQ-配置"><a href="#RabiitMQ-配置" class="headerlink" title="RabiitMQ 配置"></a>RabiitMQ 配置</h1><h2 id="RabbitMQ-管理命令行"><a href="#RabbitMQ-管理命令行" class="headerlink" title="RabbitMQ 管理命令行"></a>RabbitMQ 管理命令行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.服务启动相关</span></span><br><span class="line">systemctl start|restart|stop|status rabbitmq-server</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.管理命令行  用来在不使用web管理界面情况下命令操作RabbitMQ</span></span><br><span class="line">rabbitmqctl  help  可以查看更多命令</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.插件管理命令行</span></span><br><span class="line">rabbitmq-plugins enable|list|disable </span><br></pre></td></tr></table></figure><h1 id="RabbitMQ-的第一个程序"><a href="#RabbitMQ-的第一个程序" class="headerlink" title="RabbitMQ 的第一个程序"></a>RabbitMQ 的第一个程序</h1><ul><li>引入依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="第一种模型-直连"><a href="#第一种模型-直连" class="headerlink" title="第一种模型(直连)"></a>第一种模型(直连)</h2><h3 id="开发生产者"><a href="#开发生产者" class="headerlink" title="开发生产者"></a>开发生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Provider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMessage</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建连接工程对象，并设置相关属性值</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        conn.setHost(<span class="string">&quot;192.168.61.223&quot;</span>);</span><br><span class="line">        conn.setPort(<span class="number">5672</span>);</span><br><span class="line">        conn.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        conn.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        conn.setVirtualHost(<span class="string">&quot;/ems&quot;</span>);</span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> conn.newConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;hello&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//向队列中发消息</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>,<span class="string">&quot;hello&quot;</span>, <span class="literal">null</span>,<span class="string">&quot;hello word rabbitmq&quot;</span>.getBytes());</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="开发消费者"><a href="#开发消费者" class="headerlink" title="开发消费者"></a>开发消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.61.223&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/ems&quot;</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">       <span class="comment">//创建通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//通道和绑定对象</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;hello&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//消费消息</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;hello&quot;</span>,<span class="literal">true</span>,<span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二种模型-work-quene"><a href="#第二种模型-work-quene" class="headerlink" title="第二种模型(work quene)"></a>第二种模型(work quene)</h2><p><code>Work queues</code>，也被称为（<code>Task queues</code>），任务模型。当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用work 模型：<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。队列中的消息一旦消费，就会消失，因此任务是不会被重复执行的。</p><h3 id="开发生产者-1"><a href="#开发生产者-1" class="headerlink" title="开发生产者"></a>开发生产者</h3><h3 id="开发消费者1"><a href="#开发消费者1" class="headerlink" title="开发消费者1"></a>开发消费者1</h3><h3 id="开发消费者2"><a href="#开发消费者2" class="headerlink" title="开发消费者2"></a>开发消费者2</h3><h3 id="消息自动确认机制"><a href="#消息自动确认机制" class="headerlink" title="消息自动确认机制"></a>消息自动确认机制</h3><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><p>1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;br&gt;





&lt;h1 id=&quot;RabbitMQ-的引言&quot;&gt;&lt;a href=&quot;#RabbitMQ-的引言&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ 的引言&quot;&gt;&lt;/a&gt;RabbitMQ 的引言&lt;/h1&gt;&lt;h2 id=&quot;RabbitMQ&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="MQ" scheme="https://ratears.github.io/dev.ratears.life/Categories/MQ/"/>
    
    <category term="RabbitMQ" scheme="https://ratears.github.io/dev.ratears.life/Categories/MQ/RabbitMQ/"/>
    
    
    <category term="MQ" scheme="https://ratears.github.io/dev.ratears.life/Tags/MQ/"/>
    
    <category term="RabbitMQ" scheme="https://ratears.github.io/dev.ratears.life/Tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>《Spring Security+OAuth2 精讲，打造企业级认证与授权》Study Notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/%E3%80%8ASpring-Security-OAuth2-%E7%B2%BE%E8%AE%B2%EF%BC%8C%E6%89%93%E9%80%A0%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E3%80%8BStudy-Notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/%E3%80%8ASpring-Security-OAuth2-%E7%B2%BE%E8%AE%B2%EF%BC%8C%E6%89%93%E9%80%A0%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E3%80%8BStudy-Notes/</id>
    <published>2023-05-28T16:20:08.000Z</published>
    <updated>2023-05-28T16:20:08.000Z</updated>
    
    <content type="html"><![CDATA[<br><h1 id="第1章-关于这门课，你需要知道的"><a href="#第1章-关于这门课，你需要知道的" class="headerlink" title="第1章 关于这门课，你需要知道的"></a>第1章 关于这门课，你需要知道的</h1><h2 id="认证授权的重要"><a href="#认证授权的重要" class="headerlink" title="认证授权的重要"></a>认证授权的重要</h2><ul><li>普遍性：几乎所有企业级业务场景中都有各种各样的权限需求</li><li>必要性：认证和授权作为整体架构的基础建设部分直接决定了产品的安全性，稳定性</li><li>可持续性：针对系统的攻击随着技术和机器性能的发展也不断进步，同时也催生了不断进化的安全技术和策略</li><li>面试求职：对于后端技术人员面试中，安全几乎是必不可少的一个考点</li></ul><h2 id="为什么选择-Spring-Security"><a href="#为什么选择-Spring-Security" class="headerlink" title="为什么选择 Spring Security"></a>为什么选择 Spring Security</h2><ol><li>竞争框架的流行度</li><li>Spring 全家桶重要成员</li><li>丰富全面的安全特性，业务隔离度好</li></ol><h2 id="学习内容和学习路线"><a href="#学习内容和学习路线" class="headerlink" title="学习内容和学习路线"></a>学习内容和学习路线</h2><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.2y959ihgaaw0.png" width="70%"><br><h2 id="学习成果"><a href="#学习成果" class="headerlink" title="学习成果"></a>学习成果</h2><ul><li>独立设计一个安全的单体应用</li><li>为微服务开发 UAA 或集成第三方</li><li>前后端配合时常见的问题处理</li></ul><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="代码环境"><a href="#代码环境" class="headerlink" title="代码环境"></a>代码环境</h3><ul><li>Spring Security 5.x</li><li>Java 11和 Spring Boot 2.x</li></ul><h3 id="前端开发环境"><a href="#前端开发环境" class="headerlink" title="前端开发环境"></a>前端开发环境</h3><ul><li>node、npm/cnpm、vue cli</li></ul><blockquote><p>安装node.js的目的是使用npm管理项目依赖的软件包<br>由于网络环境的原因，cnpm 作为替代的包管理工具<br>使用Vue CLI 使我们无须理会复杂的配置，更专注Vue.js</p></blockquote><h3 id="后端开发环境搭建"><a href="#后端开发环境搭建" class="headerlink" title="后端开发环境搭建"></a>后端开发环境搭建</h3><ul><li>OpenJDK11</li><li>使用Maven进行项目依赖和工程管理</li><li>使用IntellijIDEA 进行开发<ul><li>IDEA的推荐拓展：EnvFile、Lombok</li><li>IDEA的热启动配置</li></ul></li></ul><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><p>1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;br&gt;

&lt;h1 id=&quot;第1章-关于这门课，你需要知道的&quot;&gt;&lt;a href=&quot;#第1章-关于这门课，你需要知道的&quot; class=&quot;headerlink&quot; title=&quot;第1章 关于这门课，你需要知道的&quot;&gt;&lt;/a&gt;第1章 关于这门课，你需要知道的&lt;/h1&gt;&lt;h2 id=&quot;认证授</summary>
      
    
    
    
    <category term="Spring Security" scheme="https://ratears.github.io/dev.ratears.life/Categories/Spring-Security/"/>
    
    
    <category term="Spring Security" scheme="https://ratears.github.io/dev.ratears.life/Tags/Spring-Security/"/>
    
    <category term="OAuth2" scheme="https://ratears.github.io/dev.ratears.life/Tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>《Spring Cloud / Alibaba 微服务架构实战》Study Notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/%E3%80%8ASpring-Cloud-Alibaba-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E3%80%8BStudy-Notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/%E3%80%8ASpring-Cloud-Alibaba-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E3%80%8BStudy-Notes/</id>
    <published>2023-05-25T17:07:46.000Z</published>
    <updated>2023-05-25T17:07:46.000Z</updated>
    
    <content type="html"><![CDATA[<br><h1 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h1><h2 id="Spring体系概述"><a href="#Spring体系概述" class="headerlink" title="Spring体系概述"></a>Spring体系概述</h2><ul><li>SpringCloud是基于Spring构建分布式系统的工具集</li><li>Spring是以Bean为中心提供AOP、IOC等功能</li><li>SpringBoot是以Application为中心提供自动配置、监控等功能</li><li>SpringCloud是以Service为中心提供服务的注册与发现、服务的调用与负载均衡等功能</li><li>SpringCloud提供了很强大的功能，但并不提供具体实现。而是通过SpringCloud Common子项目定义了统一的抽象API。不同厂商会有不同的实现</li></ul><h2 id="课程目标"><a href="#课程目标" class="headerlink" title="课程目标"></a>课程目标</h2><ol><li>直面微服务落地过程中的各种问题，制定解决方案</li><li>深究微服务架构设计，提高代码复用性</li><li>落地企业级开发实战，透视微服务思想</li></ol><h2 id="通过工程架构图俯视课程核心知识点"><a href="#通过工程架构图俯视课程核心知识点" class="headerlink" title="通过工程架构图俯视课程核心知识点"></a>通过工程架构图俯视课程核心知识点</h2><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.40fb5l9hr2g0.webp" width="70%"><br><h2 id="课程收获"><a href="#课程收获" class="headerlink" title="课程收获"></a>课程收获</h2><ol><li>掌握微服务开发框架及企业级常用组件的集成与应用</li><li>掌握微服务工程架构设计原则、业务拆分思想</li><li>具备制定和实施微服务工程解决方案的能力</li></ol><h2 id="学习方法论"><a href="#学习方法论" class="headerlink" title="学习方法论"></a>学习方法论</h2><ol><li>不要着急编码，先搞清楚套路和原则</li><li>主动思考，提出更好的解决方案</li><li>学以致用，站在巨人的肩膀上</li><li>合理利用资源，课程的知识点多种多样</li></ol><br><br><br><h1 id="第2章-理解微服务架构，清楚微服务设计原则"><a href="#第2章-理解微服务架构，清楚微服务设计原则" class="headerlink" title="第2章 理解微服务架构，清楚微服务设计原则"></a>第2章 理解微服务架构，清楚微服务设计原则</h1><h2 id="微服务架构的演进过程"><a href="#微服务架构的演进过程" class="headerlink" title="微服务架构的演进过程"></a>微服务架构的演进过程</h2><h3 id="最早的系统架构设计：单体架构"><a href="#最早的系统架构设计：单体架构" class="headerlink" title="最早的系统架构设计：单体架构"></a>最早的系统架构设计：单体架构</h3><ul><li>单体架构设计：将整个业务功能实现写在一个工程中<ul><li>优点：开发、部署、上线非常简单</li><li>缺点：代码耦合严重，牵一发而动全身</li></ul></li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.3nbo0t1njzc0.webp" width="70%"><br><h3 id="单体架构的升级改进：垂直应用架构"><a href="#单体架构的升级改进：垂直应用架构" class="headerlink" title="单体架构的升级改进：垂直应用架构"></a>单体架构的升级改进：垂直应用架构</h3><ul><li>垂直：指单一的业务场景</li><li>垂直应用架构的思想<ul><li>从单体应用按照功能业务垂直拆分出多个应用</li><li>每一个应用都会独立的部署</li><li>每一个应用都有独立的数据库</li><li>每一个应用有自己独立的域名</li></ul></li><li>优点：服务、部署独立，水平扩展容易</li><li>缺点：搭建复杂，服务之间关系错综复杂，维护困难</li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.5b568vziwqo0.webp" width="70%"><br><h3 id="垂直应用架构的升级改进：SOA架构"><a href="#垂直应用架构的升级改进：SOA架构" class="headerlink" title="垂直应用架构的升级改进：SOA架构"></a>垂直应用架构的升级改进：SOA架构</h3><ul><li>SOA（Service-Oriented Architecture，面向服务的架构）</li><li>SOA架构是微服务出现前应用比较广泛的架构</li><li>思想：在企业计算领域，将耦合的系统划分为面向业务的、粗粒度、松耦合、无状态服务，服务发布出来，供其它服务去调用。一组互相依赖的系统就构成了SOA架构下的系统</li><li>SAO不是某一具体的技术实现，而是系统架构思想</li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.tss5d4tsels.webp" width="70%"><br><h3 id="业界最流行的软件开发架构：微服务架构"><a href="#业界最流行的软件开发架构：微服务架构" class="headerlink" title="业界最流行的软件开发架构：微服务架构"></a>业界最流行的软件开发架构：微服务架构</h3><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.5ryj362wtvk0.webp" width="70%"><br><h2 id="微服务架构需要遵循的原则"><a href="#微服务架构需要遵循的原则" class="headerlink" title="微服务架构需要遵循的原则"></a>微服务架构需要遵循的原则</h2><h3 id="微服务架构能够带来的收益（合理正确的将单体应用迁移到微服务）"><a href="#微服务架构能够带来的收益（合理正确的将单体应用迁移到微服务）" class="headerlink" title="微服务架构能够带来的收益（合理正确的将单体应用迁移到微服务）"></a>微服务架构能够带来的收益（合理正确的将单体应用迁移到微服务）</h3><ul><li>单个服务，可以选择一门开发人员擅长的语言去开发，扩展性强</li><li>对于整个应用而言，代码不再耦合，不会出现大量冲突</li><li>微服务可以重用，应用发布时间可控性更强</li><li>通过故障隔离，让错误在微服务中降级，不会影响到整个应用（或其它应用）</li></ul><h3 id="不遵循微服务架构原则会出现巨大的问题"><a href="#不遵循微服务架构原则会出现巨大的问题" class="headerlink" title="不遵循微服务架构原则会出现巨大的问题"></a>不遵循微服务架构原则会出现巨大的问题</h3><ul><li>微服务之间的依赖错综复杂，难以维护</li><li>开发过程[互相纠缠]，开发、上线时间严重影响</li></ul><h3 id="最佳实践：微服务架构需要遵循的原则"><a href="#最佳实践：微服务架构需要遵循的原则" class="headerlink" title="最佳实践：微服务架构需要遵循的原则"></a>最佳实践：微服务架构需要遵循的原则</h3><ul><li>职责独立:每个微服务只做自己功能范围内的事，微服务之间的依赖链不要[过长]（建议单个微服务的依赖链路不要超过3）</li><li>使用熔断器实现快速的故障容错和线程隔离，例如Hystrix、Sentinel</li><li>通过网关代理微服务请求，网关是微服务架构对外暴露的唯一入口</li><li>确保微服务API变更后能够向后兼容</li></ul><br><br><br><h1 id="第3章-设计电商工程，把握全局视角"><a href="#第3章-设计电商工程，把握全局视角" class="headerlink" title="第3章 设计电商工程，把握全局视角"></a>第3章 设计电商工程，把握全局视角</h1><h2 id="领域驱动设计（DDD）"><a href="#领域驱动设计（DDD）" class="headerlink" title="领域驱动设计（DDD）"></a>领域驱动设计（DDD）</h2><h3 id="DDD的相关概念"><a href="#DDD的相关概念" class="headerlink" title="DDD的相关概念"></a>DDD的相关概念</h3><ul><li>DDD是一种软件架构设计方法，它并不定义软件开发过程（DevOps）</li><li>DDD利用面向对象的特性，以业务为核心驱动。而不是传统的数据库（表）驱动开发</li></ul><h3 id="领域"><a href="#领域" class="headerlink" title="领域"></a>领域</h3><ul><li>领域即业务。领域是对功能需求的划分，大的领域下面还有许多小的子领域</li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.64796m8yqmo0.webp" width="70%"><br><h3 id="理解领域概念，学习领域知识，对领域建模"><a href="#理解领域概念，学习领域知识，对领域建模" class="headerlink" title="理解领域概念，学习领域知识，对领域建模"></a>理解领域概念，学习领域知识，对领域建模</h3><ol><li>分析领域模型，推演实体、值对象、领域服务</li><li>找出聚合边界(降低服务合)</li><li>为聚合配备存储仓库(数据持久化)</li><li>实践 DDD，并不断推倒和重构</li></ol><h2 id="电商工程业务解读"><a href="#电商工程业务解读" class="headerlink" title="电商工程业务解读"></a>电商工程业务解读</h2><ul><li>Tips:学习领域知识最好的方式就是参考和借鉴</li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.6ohd5xzmkco0.webp" width="70%"><br><h2 id="微服务模块拆分"><a href="#微服务模块拆分" class="headerlink" title="微服务模块拆分"></a>微服务模块拆分</h2><h3 id="工程入口及用户鉴权微服务"><a href="#工程入口及用户鉴权微服务" class="headerlink" title="工程入口及用户鉴权微服务"></a>工程入口及用户鉴权微服务</h3><ul><li>网关是微服务架构的唯一入口</li><li>鉴权：用户登录和注册</li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.621dbmex1700.webp" width="70%"><br><h2 id="电商功能微服务"><a href="#电商功能微服务" class="headerlink" title="电商功能微服务"></a>电商功能微服务</h2><ul><li>四大功能微服务模块:账户、商品、订单、物流</li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.30ejegjj6os0.webp" width="70%"><br><h2 id="创建电商项目工程"><a href="#创建电商项目工程" class="headerlink" title="创建电商项目工程"></a>创建电商项目工程</h2><ul><li><a class="link"   href="https://github.com/ratears/len_project_code_repo" >https://github.com/ratears/len_project_code_repo<i class="fas fa-external-link-alt"></i></a></li></ul><br><br><br><h1 id="第4章-Alibaba-Nacos：服务注册与配置中心"><a href="#第4章-Alibaba-Nacos：服务注册与配置中心" class="headerlink" title="第4章 Alibaba Nacos：服务注册与配置中心"></a>第4章 Alibaba Nacos：服务注册与配置中心</h1><h2 id="Alibaba-Nacos介绍"><a href="#Alibaba-Nacos介绍" class="headerlink" title="Alibaba Nacos介绍"></a>Alibaba Nacos介绍</h2><ul><li>服务注册中心:它是服务，实例及元数据的数据库，服务注册中心可能会调用服务实例的健康检查API来验证它是否能够处理请求</li><li>服务元数据:包括服务端点(endpoints)、服务标签、服务版本号、服务实例权重、路由规则安全策略等描述服务的数据</li><li>服务提供、消费方:提供可复用和可调用服务的应用方，会发起对某个服务调用的应用方</li><li>配置:在系统开发过程中通常会将一些需要变更的参数、变量等从代码中分离出来独立管理以独立的配置文件的形式存在</li></ul><h2 id="部署Alibaba-Nacos"><a href="#部署Alibaba-Nacos" class="headerlink" title="部署Alibaba Nacos"></a>部署Alibaba Nacos</h2><h3 id="单机部署Alibaba-Nacos"><a href="#单机部署Alibaba-Nacos" class="headerlink" title="单机部署Alibaba Nacos"></a>单机部署Alibaba Nacos</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src/</span><br><span class="line"></span><br><span class="line">wget https://github.com/alibaba/nacos/releases/download/2.0.0-bugfix/nacos-server-2.0.0.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf nacos-server-2.0.0.tar.gz</span><br><span class="line"></span><br><span class="line">mv nacos /usr/local/</span><br><span class="line"></span><br><span class="line">cd /usr/local/</span><br><span class="line"></span><br><span class="line">cd /usr/local/nacos/bin/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">单机模式启动(默认配置就可以):</span></span><br><span class="line">./startup.sh -m standalone</span><br></pre></td></tr></table></figure><h3 id="给Nacos-配置自定义的-MySQL-持久化"><a href="#给Nacos-配置自定义的-MySQL-持久化" class="headerlink" title="给Nacos 配置自定义的 MySQL 持久化"></a>给Nacos 配置自定义的 MySQL 持久化</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">（1）修改配置，指定 MySQL 地址、用户名、端口号</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">*************** Config Module Related Configurations ***************<span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## If use MySQL as datasource:</span></span></span><br><span class="line">spring.datasource.platform=mysql</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## Count of DB:</span></span></span><br><span class="line">db.num=1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## Connect URL of DB:</span></span></span><br><span class="line">db.url.0=jdbc:mysql://192.168.61.221:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">db.user.0=root</span><br><span class="line">db.password.0=root</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">（2）在连接的数据库中执行nacos的脚本</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">（3）重启nacos</span></span><br></pre></td></tr></table></figure><h3 id="集群部署Alibaba-Nacos"><a href="#集群部署Alibaba-Nacos" class="headerlink" title="集群部署Alibaba Nacos"></a>集群部署Alibaba Nacos</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里演示用伪集群方式（集群方式略同）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">（1）在cluster.conf文件中定义集群部署的ip 和端口，同时需要修改配置文件application.properties中的对外端口</span></span><br><span class="line">cd /usr/local/nacos/conf</span><br><span class="line"></span><br><span class="line">cp cluster.conf.example cluster.conf</span><br><span class="line"></span><br><span class="line">vim cluster.conf</span><br><span class="line"></span><br><span class="line">192.168.61.220:8848</span><br><span class="line">192.168.61.220:8858</span><br><span class="line">192.168.61.220:8868</span><br><span class="line"></span><br><span class="line">cd /usr/local/</span><br><span class="line"></span><br><span class="line">cp -R nacos/ nacos-8848</span><br><span class="line">cp -R nacos/ nacos-8858</span><br><span class="line">cp -R nacos/ nacos-8868</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">（2）集群必须要使用可以共同访问(例如 MySQL、PG等等)到的数据源作为持久化的方式,参考 给Nacos 配置自定义的 MySQL 持久化</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">（3）集群化启动没有额外的参数:./startup.sh</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Alibaba-Nacos-Client-服务注册与发现"><a href="#Alibaba-Nacos-Client-服务注册与发现" class="headerlink" title="Alibaba Nacos Client 服务注册与发现"></a>Alibaba Nacos Client 服务注册与发现</h2><ul><li><a class="link"   href="https://github.com/ratears/len_project_code_repo" >https://github.com/ratears/len_project_code_repo<i class="fas fa-external-link-alt"></i></a></li></ul><br><br><br><h1 id="第5章-SpringBoot-Admin-微服务应用监控"><a href="#第5章-SpringBoot-Admin-微服务应用监控" class="headerlink" title="第5章 SpringBoot Admin 微服务应用监控"></a>第5章 SpringBoot Admin 微服务应用监控</h1><h2 id="SpringBoot-Actuator"><a href="#SpringBoot-Actuator" class="headerlink" title="SpringBoot Actuator"></a>SpringBoot Actuator</h2><h3 id="Actuator-Endpoints"><a href="#Actuator-Endpoints" class="headerlink" title="Actuator Endpoints"></a>Actuator Endpoints</h3><ul><li>Endpoints 是 Actuator 的核心部分，它用来监视应用程序及交互;SpringBoot Actuator 内置了很多 Endpoints，并支持扩展</li><li>SpringBoot Actuator 提供的原生端点有三类：<ul><li>应用配置类:自动配置信息、Spring Bean 信息yml文件信息、环境信息等等</li><li>度量指标类:主要是运行期间的动态信息，例如堆栈、健康指标、metrics 信息等等</li><li>操作控制类:主要是指shutdown，用户可以发送一个请求将应用的监控功能关闭</li></ul></li></ul><h2 id="SpringBoot-Admin"><a href="#SpringBoot-Admin" class="headerlink" title="SpringBoot Admin"></a>SpringBoot Admin</h2><ul><li>搭建监控服务器的步骤<ul><li>添加SpringBoot Admin Starter 自动配置依赖</li><li>添加启动注解:@EnableAdminServer</li></ul></li></ul><h2 id="应用注册到-SpringBoot-Admin-Server"><a href="#应用注册到-SpringBoot-Admin-Server" class="headerlink" title="应用注册到 SpringBoot Admin Server"></a>应用注册到 SpringBoot Admin Server</h2><h3 id="被监控和管理的应用-微服务-，注册到Admin-Server-的两种方式"><a href="#被监控和管理的应用-微服务-，注册到Admin-Server-的两种方式" class="headerlink" title="被监控和管理的应用(微服务)，注册到Admin Server 的两种方式"></a>被监控和管理的应用(微服务)，注册到Admin Server 的两种方式</h3><ul><li>方式一:被监控和管理的应用程序，使用 SpringBoot Admin Client 库，通过HTTP调用注册到 SpringBoot Admin Server 上</li><li>方式二:首先，被监控和管理的应用程序，注册到 SpringCloud 集成的注册中心;然后SpringBoot Admin Server 通过注册中心获取到被监控和管理的应用程序</li></ul><h2 id="监控中心服务器添加安全访问控制"><a href="#监控中心服务器添加安全访问控制" class="headerlink" title="监控中心服务器添加安全访问控制"></a>监控中心服务器添加安全访问控制</h2><ul><li>略（见代码）</li><li>自定义监控告警<ul><li>邮件配置</li><li>其它配置（参考视频）</li></ul></li></ul><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><ol><li>某些spring的注解还不够熟悉</li><li>maven还需要加强</li><li>Security还需要认真学习，熟悉</li></ol></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;br&gt;

&lt;h1 id=&quot;第1章-课程介绍&quot;&gt;&lt;a href=&quot;#第1章-课程介绍&quot; class=&quot;headerlink&quot; title=&quot;第1章 课程介绍&quot;&gt;&lt;/a&gt;第1章 课程介绍&lt;/h1&gt;&lt;h2 id=&quot;Spring体系概述&quot;&gt;&lt;a href=&quot;#Spring体系概述&quot; c</summary>
      
    
    
    
    <category term="microservice" scheme="https://ratears.github.io/dev.ratears.life/Categories/microservice/"/>
    
    <category term="Spring Cloud" scheme="https://ratears.github.io/dev.ratears.life/Categories/microservice/Spring-Cloud/"/>
    
    <category term="Spring Cloud Alibaba" scheme="https://ratears.github.io/dev.ratears.life/Categories/microservice/Spring-Cloud-Alibaba/"/>
    
    
    <category term="microservice" scheme="https://ratears.github.io/dev.ratears.life/Tags/microservice/"/>
    
    <category term="Spring Cloud Alibaba" scheme="https://ratears.github.io/dev.ratears.life/Tags/Spring-Cloud-Alibaba/"/>
    
    <category term="Spring Cloud" scheme="https://ratears.github.io/dev.ratears.life/Tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>《分布式技术原理与算法解析》Study Notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/%E3%80%8A%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90%E3%80%8BStudy-Notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/%E3%80%8A%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90%E3%80%8BStudy-Notes/</id>
    <published>2023-05-18T11:16:47.000Z</published>
    <updated>2023-05-18T11:16:47.000Z</updated>
    
    <content type="html"><![CDATA[<br><h1 id="课前必读-3讲"><a href="#课前必读-3讲" class="headerlink" title="课前必读 (3讲)"></a>课前必读 (3讲)</h1><h2 id="开篇词-四纵四横，带你透彻理解分布式技术"><a href="#开篇词-四纵四横，带你透彻理解分布式技术" class="headerlink" title="开篇词 | 四纵四横，带你透彻理解分布式技术"></a>开篇词 | 四纵四横，带你透彻理解分布式技术</h2><ul><li><p>学习分布式可能遇到的问题：</p><ul><li>各种分布式概念、名词学了一大堆，但经常张冠李戴，傻傻分不清楚</li><li>做了多年技术，也参与了很多分布式技术实践，却无法回答工作中各种分布式技术、组件、框架选型背后的根源；</li><li>在一个分布式技术配套的典型场景往往能驾轻就熟，但一旦稍微变更考察业务场景、业务目标后，就变得毫无头绪。</li></ul></li><li><p>究其原因，主要是<strong>知识碎片化、不成体系、见树不见林</strong></p></li><li><p><strong>学好分布式通识课，掌握了分布式的核心技术、体系，你就会发现很多新技术、新框架、新组件只不过是‘新瓶装旧酒’，将分布式核心技术进行了再包装、再组合，至多也就是做了一点延伸而已</strong></p></li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.1bdevfdexqtc.webp" width="100%"><br><ul><li><strong>在一定资源上，进行一定通信，通过一定计算，完成一定数据的加工和处理，从而对外提供特定的服务</strong></li></ul><h2 id="01-分布式缘何而起：从单兵，到游击队，到集团军"><a href="#01-分布式缘何而起：从单兵，到游击队，到集团军" class="headerlink" title="01 | 分布式缘何而起：从单兵，到游击队，到集团军"></a>01 | 分布式缘何而起：从单兵，到游击队，到集团军</h2><h3 id="分布式起源"><a href="#分布式起源" class="headerlink" title="分布式起源"></a>分布式起源</h3><h4 id="单兵模式：单机模式"><a href="#单兵模式：单机模式" class="headerlink" title="单兵模式：单机模式"></a>单兵模式：单机模式</h4><ul><li><strong>单机模式</strong>：所有应用程序和数据均部署在一台电脑或服务器上，由一台计算机完成所有的处理<ul><li>优点：功能、代码和数据集中，便于维护、管理和执行</li><li>缺点：决定了CPU和内存等硬件的性能将成为单机模式的瓶颈</li><li><strong>性能受限、存在单点失效问题</strong></li></ul></li></ul><h4 id="游击队模式：数据并行或数据分布式"><a href="#游击队模式：数据并行或数据分布式" class="headerlink" title="游击队模式：数据并行或数据分布式"></a>游击队模式：数据并行或数据分布式</h4><ul><li>数据并行（也叫作数据分布式）模式：<strong>并行计算</strong>采用消息共享模式使用多台计算机并行运行或执行多项任务，核心原理是每台计算机上执行相同的程序，将数据进行拆分放到不同的计算机上进行计算。</li><li>并行计算强调的是对数据进行拆分，任务程序在每台机器上运行<ul><li>必须首先把单机模式中的应用和数据分离，才可能实现对数据的拆分</li><li>这里的应用就是执行任务的程序，任务就是提交的请求</li></ul></li><li>优点：可以利用多台计算机并行处理多个请求，使得我们可以在相同的时间内完成更多的请求处理，解决了单机模式的计算效率瓶颈问题</li><li>问题：<ul><li>如何负载均衡</li><li>IO瓶颈，如果采用读写分离，如何同步数据？如何保证数据一致性</li><li>需要引入缓存</li></ul></li><li>数据并行模式的主要问题是：<strong>对提升单个任务的执行性能及降低时延无效</strong></li></ul><h4 id="集团军模式：任务并行或任务分布式"><a href="#集团军模式：任务并行或任务分布式" class="headerlink" title="集团军模式：任务并行或任务分布式"></a>集团军模式：任务并行或任务分布式</h4><ul><li><strong>任务并行</strong>：将单个复杂的任务拆分为多个子任务，从而使得多个子任务可以在不同的计算机上并行执行。</li><li><strong>集团军模式在提供了更好的性能、扩展性、可维护性的同时，也带来了设计上的复杂性问题</strong></li></ul><h4 id="分布式是什么？"><a href="#分布式是什么？" class="headerlink" title="分布式是什么？"></a>分布式是什么？</h4><ul><li><strong>分布式其实就是将相同或相关的程序运行在多台计算机上，从而实现特定目标的一种计算方式</strong></li><li><strong>产生分布式的最主要驱动力量，是我们对于性能、可用性及可扩展性的不懈追求</strong></li></ul><h2 id="02-分布式系统的指标：啥是分布式的三围"><a href="#02-分布式系统的指标：啥是分布式的三围" class="headerlink" title="02 | 分布式系统的指标：啥是分布式的三围"></a>02 | 分布式系统的指标：啥是分布式的三围</h2><h3 id="分布式系统的指标"><a href="#分布式系统的指标" class="headerlink" title="分布式系统的指标"></a>分布式系统的指标</h3><ul><li>分布式的目的是<strong>用更多的机器，处理更多的数据和更复杂的任务</strong></li><li><strong>性能、资源、可用性和可扩展性</strong>是分布式系统的重要指标</li></ul><h3 id="性能（Performance）"><a href="#性能（Performance）" class="headerlink" title="性能（Performance）"></a>性能（Performance）</h3><ul><li>性能指标，主要用于衡量一个系统处理各种任务的能力</li></ul><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a><strong>吞吐量</strong></h4><ul><li>指的是，系统在一定时间内可以处理的任务数。常见的吞吐量指标有QPS（Queries Per Second）、TPS（Transactions Per Second）和BPS（Bits Per Second）<ul><li>QPS，即查询数每秒，用于衡量一个系统每秒处理的查询数。这个指标通常用于读操作，越高说明对读操作的支持越好。所以，我们在设计一个分布式系统的时候，如果应用主要是读操作，那么需要重点考虑如何提高QPS，来支持高频的读操作。</li><li>TPS，即事务数每秒，用于衡量一个系统每秒处理的事务数。这个指标通常对应于写操作，越高说明对写操作的支持越好。我们在设计一个分布式系统的时候，如果应用主要是写操作，那么需要重点考虑如何提高TPS，来支持高频写操作。</li><li>BPS，即比特数每秒，用于衡量一个系统每秒处理的数据量。对于一些网络系统、数据管理系统，我们不能简单地按照请求数或事务数来衡量其性能。因为请求与请求、事务与事务之间也存在着很大的差异，比方说，有的事务大需要写入更多的数据。那么在这种情况下，BPS更能客观地反应系统的吞吐量。</li></ul></li></ul><h4 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a><strong>响应时间</strong></h4><ul><li>系统响应一个请求或输入需要花费的时间</li></ul><h4 id="完成时间"><a href="#完成时间" class="headerlink" title="完成时间"></a><strong>完成时间</strong></h4><ul><li>系统真正完成一个请求或处理需要花费的时间</li></ul><h3 id="资源占用（Resource-Usage）"><a href="#资源占用（Resource-Usage）" class="headerlink" title="资源占用（Resource Usage）"></a>资源占用（Resource Usage）</h3><ul><li>一个系统提供正常能力需要占用的硬件资源，比如CPU、内存、硬盘等</li></ul><h3 id="可用性（Availability）"><a href="#可用性（Availability）" class="headerlink" title="可用性（Availability）"></a>可用性（Availability）</h3><ul><li>系统的可用性可以用<strong>系统停止服务的时间与总的时间之比衡量</strong></li><li>系统的可用性还可以用<strong>某功能的失败次数与总的请求次数之比来衡量</strong></li><li><strong>可靠性</strong>通常用来表示一个系统完全不出故障的概率，更多地用在硬件领域。而<strong>可用性</strong>则更多的是指在允许部分组件失效的情况下，一个系统对外仍能正常提供服务的概率。</li></ul><h3 id="可扩展性（Scalability）"><a href="#可扩展性（Scalability）" class="headerlink" title="可扩展性（Scalability）"></a>可扩展性（Scalability）</h3><ul><li>分布式系统通过扩展集群机器规模提高系统性能(吞吐、响应时间、 完成时间)、存储容量、计算能力的特性，是分布式系统的特有性质</li><li><strong>当任务的需求随着具体业务不断提高时，除了升级系统的性能做垂直/纵向扩展外，另一个做法就是通过增加机器的方式去水平/横向扩展系统规模</strong></li></ul><h3 id="不同场景下分布式系统的指标"><a href="#不同场景下分布式系统的指标" class="headerlink" title="不同场景下分布式系统的指标"></a>不同场景下分布式系统的指标</h3><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.2v3iobaanio0.webp" width="90%"><br><h1 id="第一站：分布式协调与同步-6讲"><a href="#第一站：分布式协调与同步-6讲" class="headerlink" title="第一站：分布式协调与同步 (6讲)"></a>第一站：分布式协调与同步 (6讲)</h1><h2 id="03-分布式互斥：有你没我，有我没你"><a href="#03-分布式互斥：有你没我，有我没你" class="headerlink" title="03 | 分布式互斥：有你没我，有我没你"></a>03 | 分布式互斥：有你没我，有我没你</h2><ul><li>在分布式系统里，排他性的资源访问方式，叫作分布式互斥（Distributed Mutual Exclusion），而这种被互斥访问的共享资源就叫作临界资源（Critical Resource）</li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.7l321dqdj1k0.webp" width="100%"><br><h2 id="04-分布式选举：国不可一日无君"><a href="#04-分布式选举：国不可一日无君" class="headerlink" title="04 | 分布式选举：国不可一日无君"></a>04 | 分布式选举：国不可一日无君</h2><h3 id="为什么要有分布式选举？"><a href="#为什么要有分布式选举？" class="headerlink" title="为什么要有分布式选举？"></a>为什么要有分布式选举？</h3><ul><li>选举的作用就是选出一个主节点，由它来协调和管理其他节点，以保证集群有序运行和节点间数据的一致性。</li></ul><h3 id="分布式选举的算法"><a href="#分布式选举的算法" class="headerlink" title="分布式选举的算法"></a>分布式选举的算法</h3><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.4idtb9gcp6g.png" width="100%"><br><h2 id="05-分布式共识：存异求同"><a href="#05-分布式共识：存异求同" class="headerlink" title="05 | 分布式共识：存异求同"></a>05 | 分布式共识：存异求同</h2><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.co77m5xvvso.png" width="100%"><br><h2 id="06-分布式事务：All-or-nothing"><a href="#06-分布式事务：All-or-nothing" class="headerlink" title="06 | 分布式事务：All or nothing"></a>06 | 分布式事务：All or nothing</h2><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><p>1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;br&gt;

&lt;h1 id=&quot;课前必读-3讲&quot;&gt;&lt;a href=&quot;#课前必读-3讲&quot; class=&quot;headerlink&quot; title=&quot;课前必读 (3讲)&quot;&gt;&lt;/a&gt;课前必读 (3讲)&lt;/h1&gt;&lt;h2 id=&quot;开篇词-四纵四横，带你透彻理解分布式技术&quot;&gt;&lt;a href=&quot;#开篇词</summary>
      
    
    
    
    <category term="distributed" scheme="https://ratears.github.io/dev.ratears.life/Categories/distributed/"/>
    
    
    <category term="distributed" scheme="https://ratears.github.io/dev.ratears.life/Tags/distributed/"/>
    
  </entry>
  
  <entry>
    <title>《MySQL 实战 45 讲》Study Notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/%E3%80%8AMySQL-%E5%AE%9E%E6%88%98-45-%E8%AE%B2%E3%80%8BStudy-Notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/%E3%80%8AMySQL-%E5%AE%9E%E6%88%98-45-%E8%AE%B2%E3%80%8BStudy-Notes/</id>
    <published>2023-05-14T14:38:36.000Z</published>
    <updated>2023-05-14T14:38:36.000Z</updated>
    
    <content type="html"><![CDATA[<br><h1 id="开篇词-1讲"><a href="#开篇词-1讲" class="headerlink" title="开篇词 (1讲)"></a>开篇词 (1讲)</h1><h2 id="开篇词-这一次，让我们一起来搞懂MySQL"><a href="#开篇词-这一次，让我们一起来搞懂MySQL" class="headerlink" title="开篇词 | 这一次，让我们一起来搞懂MySQL"></a>开篇词 | 这一次，让我们一起来搞懂MySQL</h2><ul><li>熟悉最佳实践，并明白为什么这么做</li><li>知道如何更快速、更准确地定位问题，甚至自己解决问题</li><li>原理先行，再实践验证</li><li><strong>从点到线，再到面，形成自己的MySQL知识网络</strong></li></ul><h1 id="基础篇-8讲"><a href="#基础篇-8讲" class="headerlink" title="基础篇 (8讲)"></a>基础篇 (8讲)</h1><h2 id="01-基础架构：一条SQL查询语句是如何执行的？"><a href="#01-基础架构：一条SQL查询语句是如何执行的？" class="headerlink" title="01 | 基础架构：一条SQL查询语句是如何执行的？"></a>01 | 基础架构：一条SQL查询语句是如何执行的？</h2><ul><li><strong>看一个事不要陷入细节里，应该先鸟瞰其全貌，这样才能帮助我们从高纬度理解问题</strong></li></ul><h3 id="MySQL基本架构"><a href="#MySQL基本架构" class="headerlink" title="MySQL基本架构"></a>MySQL基本架构</h3><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.417khgmj0880.png" width="70%"><br><ul><li><strong>MySQL可以分为Server层和存储引擎层两部分</strong><ul><li>Server层：包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</li><li>存储引擎层：负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。</li></ul></li></ul><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><p>1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;br&gt;

&lt;h1 id=&quot;开篇词-1讲&quot;&gt;&lt;a href=&quot;#开篇词-1讲&quot; class=&quot;headerlink&quot; title=&quot;开篇词 (1讲)&quot;&gt;&lt;/a&gt;开篇词 (1讲)&lt;/h1&gt;&lt;h2 id=&quot;开篇词-这一次，让我们一起来搞懂MySQL&quot;&gt;&lt;a href=&quot;#开篇词-这一</summary>
      
    
    
    
    <category term="DataBase" scheme="https://ratears.github.io/dev.ratears.life/Categories/DataBase/"/>
    
    <category term="MySQL" scheme="https://ratears.github.io/dev.ratears.life/Categories/DataBase/MySQL/"/>
    
    
    <category term="DataBase" scheme="https://ratears.github.io/dev.ratears.life/Tags/DataBase/"/>
    
    <category term="MySQL" scheme="https://ratears.github.io/dev.ratears.life/Tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>《新RabbitMQ精讲，提升工程实践能力，培养架构思维》Study Notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/%E3%80%8A%E6%96%B0RabbitMQ%E7%B2%BE%E8%AE%B2%EF%BC%8C%E6%8F%90%E5%8D%87%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E8%83%BD%E5%8A%9B%EF%BC%8C%E5%9F%B9%E5%85%BB%E6%9E%B6%E6%9E%84%E6%80%9D%E7%BB%B4%E3%80%8BStudy-Notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/%E3%80%8A%E6%96%B0RabbitMQ%E7%B2%BE%E8%AE%B2%EF%BC%8C%E6%8F%90%E5%8D%87%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E8%83%BD%E5%8A%9B%EF%BC%8C%E5%9F%B9%E5%85%BB%E6%9E%B6%E6%9E%84%E6%80%9D%E7%BB%B4%E3%80%8BStudy-Notes/</id>
    <published>2023-05-10T08:00:31.000Z</published>
    <updated>2023-05-10T08:00:31.000Z</updated>
    
    <content type="html"><![CDATA[<br><h1 id="思想纲领"><a href="#思想纲领" class="headerlink" title="思想纲领"></a>思想纲领</h1><h2 id="为什么要学习RabbitMQ？"><a href="#为什么要学习RabbitMQ？" class="headerlink" title="为什么要学习RabbitMQ？"></a>为什么要学习RabbitMQ？</h2><ul><li>使用广泛，市场占有率高。</li><li>工作中：RabbitMQ的使用越来越复杂</li><li>面试中：深入考察原理、源码、调优</li><li>基本功：消息化使得编码风格和思想变化</li></ul><h2 id="学习RabbitMQ的难点"><a href="#学习RabbitMQ的难点" class="headerlink" title="学习RabbitMQ的难点"></a>学习RabbitMQ的难点</h2><h3 id="难在，把知识应用在实际工作中"><a href="#难在，把知识应用在实际工作中" class="headerlink" title="难在，把知识应用在实际工作中"></a>难在，把知识应用在实际工作中</h3><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/1683705873262.38eckkinfoy0.webp" width="70%"><br><h3 id="难在，RabbitMQ知识纵向的深度认知"><a href="#难在，RabbitMQ知识纵向的深度认知" class="headerlink" title="难在，RabbitMQ知识纵向的深度认知"></a>难在，RabbitMQ知识纵向的深度认知</h3><ul><li><strong>了解</strong>：<ul><li>三种Exchange使用</li><li>命令行使用</li></ul></li><li><strong>掌握</strong>：<ul><li>使用基本方式快速完成项目</li><li>RabbitMQ单节点部署与配置</li></ul></li><li><strong>熟练</strong>：<ul><li>SpringBoot深度整合RabbitMQ</li><li>RabbitMQ高可用集群部署</li></ul></li><li><strong>精通</strong>：<ul><li>手写RabbitMQ分布式事务框架</li><li>精通SpringAMQP源码</li></ul></li></ul><h3 id="难在，枯燥零散学不下去"><a href="#难在，枯燥零散学不下去" class="headerlink" title="难在，枯燥零散学不下去"></a>难在，枯燥零散学不下去</h3><ul><li>实用：在项目中学，即学即用</li><li>深入：基于RabbitMQ开发分布式事务框架</li><li>平滑：不断分析项目目前不足，推动学习</li><li>浅出：从生活中的例子认识消息中间件</li></ul><ul><li>本课就是为解决上面三个难点而存在</li></ul><blockquote><p>基于同一个项目，多次迭代</p><p>以RabbitMQ为核心，讲深讲透</p><p>“扶上马，送一程”，提升工程思维与架构水平</p></blockquote><h2 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h2><ul><li><p><strong>战略上藐视：</strong>畏难情绪要不得</p></li><li><p><strong>战术上重视：</strong>问答区交流更加强他律</p></li></ul><br><br><br><h1 id="树立清晰的RabbitMQ初印象"><a href="#树立清晰的RabbitMQ初印象" class="headerlink" title="树立清晰的RabbitMQ初印象"></a>树立清晰的RabbitMQ初印象</h1><h2 id="理解消息中间件"><a href="#理解消息中间件" class="headerlink" title="理解消息中间件"></a>理解消息中间件</h2><ul><li><strong>消息：</strong>即信息的载体</li><li><strong>中间件</strong>：提供软件和软件之间连接的软件。以便于软件各部件之间的沟通</li></ul><h3 id="业务同步直接调用的问题"><a href="#业务同步直接调用的问题" class="headerlink" title="业务同步直接调用的问题"></a>业务同步直接调用的问题</h3><ul><li>业务调用链过长，用户等待时间长</li><li>部分组件故障会瘫痪整个业务</li><li>业务高峰期没有缓冲</li></ul><h3 id="异步线程直接调用的问题"><a href="#异步线程直接调用的问题" class="headerlink" title="异步线程直接调用的问题"></a>异步线程直接调用的问题</h3><ul><li>异步线程调用可以部分解决同步调用中的问题。</li><li>但是：业务高峰期时产生大量的异步线程，造成线程池不够用或者内存爆满</li></ul><h3 id="使用消息中间件的优势"><a href="#使用消息中间件的优势" class="headerlink" title="使用消息中间件的优势"></a>使用消息中间件的优势</h3><ul><li>业务调用链短，用户等待时间短</li><li>部分组件故障不会瘫痪整个业务</li><li>业务高峰期有缓冲</li><li>业务高峰期时不会产生大量的异步线程</li></ul><h3 id="使用消息中间件的作用"><a href="#使用消息中间件的作用" class="headerlink" title="使用消息中间件的作用"></a>使用消息中间件的作用</h3><ul><li>异步处理</li><li>系统解耦</li><li>流量削峰和流控</li><li>消息广播</li><li>消息收集</li><li>最终一致性</li></ul><h2 id="主流消息中间件技术选型"><a href="#主流消息中间件技术选型" class="headerlink" title="主流消息中间件技术选型"></a>主流消息中间件技术选型</h2><h3 id="ACTIVEMQ"><a href="#ACTIVEMQ" class="headerlink" title="ACTIVEMQ"></a>ACTIVEMQ</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol><li>由Apache 出品，Java开发，支持JMS1.1 协议和J2EE 1.4规范。</li><li>支持广泛的连接协议：OpenWire/STOMP/REST/XMPP/AMQP</li><li>支持多种语音客户端，支持插件</li><li>管理方便，便于配置集群代理</li></ol><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>基于JAVA，跨平台运行</li><li>可以用JDBC连接多种数据库</li><li>有完善的界面、监控、安全机制</li><li>自动重连和错误重试</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>社区活跃度不及 RabbitMQ</li><li>目前重心放到6.0产品Apollo，对5的Bug维护较少</li><li>不适合用于上千个队列的应用场景</li></ol><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ol><li>当前最主流的消息中间件</li><li>高可靠性，支持发送确认，投递确认等特性</li><li>高可用，支持镜像队列</li><li>支持插件</li></ol><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol><li>基于Erlang，支持高并发</li><li>支持多种平台，多种客户端，文档齐全</li><li>可靠性高</li><li>在互联网公司有较大规模的应用，社区活跃度高</li></ol><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol><li>Erlang语音较为小众，不利于二次开发</li><li>代理架构下，中央节点增加了延迟，影响性能</li><li>使用AMQP协议，使用起来有学习成本</li></ol><h3 id="Apache-RocketMQ"><a href="#Apache-RocketMQ" class="headerlink" title="Apache RocketMQ"></a>Apache RocketMQ</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><ol><li>阿里巴巴团队开发，经受双十一考验</li><li>能够保证严格的消息顺序</li><li>亿级消息堆积能力</li><li>丰富的消息拉取模式</li></ol><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ol><li>基于Java，方便二次开发</li><li>单机支持1万以上持久化队列</li><li>内存与磁盘都有一份数据，保证性能+高可用</li><li>开发度较活跃，版本更新很快</li></ol><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ol><li>客户端种类不多，较成熟的是 Java 及C++</li><li>没有 Web 管理界面，提供了一个 CLI(命令行界面)</li><li>社区关注度及成熟度不如RabbitMQ</li></ol><h3 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><ol><li>LinkedIn开发的分布式的日志提交系统</li><li>独特的分区特性，适用于大数据系统</li><li>性能高效、可扩展良好</li><li>可复制、可容错</li></ol><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ol><li>原生的分布式系统</li><li>零拷贝技术，减少IO 操作步骤，提高系统吞吐量</li><li>快速持久化:可以在O(1)的系统开销下进行消息持久化</li><li>支持数据批量发送和拉取</li></ol><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ol><li>单机超过 64 个队列/分区时，性能明显劣化</li><li>使用短轮询方式，实时性取决于轮询间隔时间</li><li>消费失败不支持重试</li><li>可靠性比较差</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>ActiveMQ最“老”，老牌，但维护较慢</li><li>RabbitMQ最“火”，适合大小公司，各种场景通杀</li><li>RocketMQ最“猛””，功能强，但考验公司运维能力</li><li>Kafka最“强”，支持超大量数据，但消息可靠性弱</li></ul><h2 id="RabbitMQ高性能的原因"><a href="#RabbitMQ高性能的原因" class="headerlink" title="RabbitMQ高性能的原因"></a>RabbitMQ高性能的原因</h2><ul><li><p>决定软件的运行效率的因素是：底层的语言和平台</p></li><li><p><strong>RabbitMQ底层使用Erlang实现，天生具有高性能基因</strong></p><ul><li><p><strong>ERLANG</strong></p><ul><li>由爱立信公司开发 (Ericsson Language)</li><li>一门为交换机软件开发诞生的编程语言</li></ul></li><li><p>Erlang的特点</p><ul><li>通用的面向并发的编程语言，适用于分布式系统</li><li>基于虚拟机解释运行，跨平台部署</li><li>进程间上下文切换效率远高于C语言</li><li>有着和原生Socket一样的延迟</li></ul></li></ul></li><li><p><strong>RabbitMQ在互联网和金融领域都有广泛的应用</strong></p></li></ul><h2 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h2><ul><li>AMQP协议作为RabbitMQ的规范，规定了RabbitMQ对外接口</li><li>学会了AMQP协议的使用，就基本掌握了RabbitMQ的使用</li><li>学会了AMQP协议的概念，就基本掌握了RabbitMQ的核心概念</li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/51e76dd95927d6e6399464c3a544197.6ld479n60mw0.webp" width="100%"><br><ul><li>Broker: 接收和分发消息的应用，RabbitMQ 就是MessageBroker</li><li>Virtual Host: 虚拟Broker，将多个单元隔离开</li><li>Connection: publisher / consumer和broker之间的TCP连接</li><li>Channel: connection内部建立的逻辑连接，通常每个线程创建单独的channel</li><li>Routing Key: 路由键，用来指示消息的路由转发相当于快递的地址</li><li>Exchange 交换机，相当于快递的分拨中心</li><li>Queue: 消息队列，消息最终被送到这里等待consumer取走</li><li>Binding: exchange和queue之间的虚拟连接用于message的分发依据</li></ul><h3 id="AMQP协议的核心概念-Exchange"><a href="#AMQP协议的核心概念-Exchange" class="headerlink" title="AMQP协议的核心概念-Exchange"></a>AMQP协议的核心概念-Exchange</h3><ul><li>在AMQP协议或者是RabbitMQ实现中，最核心的组件是 Exchange</li><li>Exchange承担RabbitMQ的核心功能——路由转发</li><li>Exchange有多个种类，配置多变，需要详细讲解</li></ul><h2 id="RabbitMQ的心脏——Exchange解析"><a href="#RabbitMQ的心脏——Exchange解析" class="headerlink" title="RabbitMQ的心脏——Exchange解析"></a>RabbitMQ的心脏——Exchange解析</h2><h3 id="Exchange的作用"><a href="#Exchange的作用" class="headerlink" title="Exchange的作用"></a>Exchange的作用</h3><ul><li>Exchange是AMQP协议和RabbitMQ的核心组件</li><li>Exchange的功能是根据绑定关系和路由键为消息提供路由，将消息转发至相应的队列</li><li>Exchange有4种类型: Direct / Topic / Fanout / Headers，其中Headers使用很少，以前三种为主</li></ul><h3 id="Direct-Exchange"><a href="#Direct-Exchange" class="headerlink" title="Direct Exchange"></a>Direct Exchange</h3><ul><li>Message中的Routing Key如果和Binding Key一致，Direct Exchange则将message发到对应的queue中</li></ul><h3 id="Fanout-Exchange"><a href="#Fanout-Exchange" class="headerlink" title="Fanout Exchange"></a>Fanout Exchange</h3><ul><li>每个发到Fanout Exchange的message都会分发到所有绑定的queue上去</li></ul><h3 id="Topit-Exchange"><a href="#Topit-Exchange" class="headerlink" title="Topit Exchange"></a>Topit Exchange</h3><ul><li>根据Routing Key及通配规则，Topic Exchange将消息分发到目标Queue中</li><li>全匹配:与Direct类似</li><li>Binding Key中的#:匹配任意个数的word</li><li>Binding Key中的*:匹配任意1个word</li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>AMQP协议直接决定了RabbitMQ的内部结构和外部行为</li><li>对于发送者来说，将消息发给特定的Exchange</li><li>消息经过Exchange路由后，到达具体队列</li><li>消费者将消息从监听的队列中取走</li><li>Exchange主要有3种类型: Direct / Topic / Fanout</li><li>Direct (直接路由): Routing Key = Binding Key，容易配置和使用</li><li>Direct (直接路由): Routing Key = Binding Key，容易配置和使用</li><li>Fanout (广播路由): 群发绑定的所有队列，适用于消息广播</li><li>Topic (话题路由):功能较为复杂，但能降级为Direct，建议优先使用，为以后拓展留余地</li></ul><h2 id="RabbitMQ安装"><a href="#RabbitMQ安装" class="headerlink" title="RabbitMQ安装"></a>RabbitMQ安装</h2><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>RabbitMQ是基于Erlang的跨平台应用，Windows / Linux/Macos 都可以安装</li><li>生产环境绝大多数都是Linux操作系统，Windows /MacOS一般作为本地开发使用</li><li>一定要在官网或官方渠道下载安装，一旦有后门的应用进入生产环境后果不堪设想</li></ul><h3 id="Windows-安装"><a href="#Windows-安装" class="headerlink" title="Windows 安装"></a>Windows 安装</h3><ul><li><p>下载并安装Erlang OTP (Open Telecom Platform)：</p><ul><li><a class="link"   href="https://www.erlang.org/downloads" >https://www.erlang.org/downloads<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://www.erlang-solutions.com/resources/download.html" >https://www.erlang-solutions.com/resources/download.html<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><p>下载并安装RabbitMQ: <a class="link"   href="https://www.rabbitmq.com/" >https://www.rabbitmq.com/<i class="fas fa-external-link-alt"></i></a></p><ul><li>“Get Started”&gt;“Download +Installation”WindowsInstaller”“Using the official installer“</li><li>安装完成后，查看系统服务中会出现RabbitMQ</li></ul></li></ul><h3 id="Linux-安装-Docker"><a href="#Linux-安装-Docker" class="headerlink" title="Linux 安装(Docker)"></a>Linux 安装(Docker)</h3><ul><li>docker run -it –rm –name rabbitmg -p 5672:5672 -p15672:15672 rabbitmq:3-management</li></ul><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><ol><li>作业：使用绘图工具，绘制本节中的AMQP协议结构图（推荐draw.io 绘图网站）</li><li>在tryrabbitmq.com 网站中，搭建本节中的三种Exchange模型</li><li>使用RabbitMQ管控台配置“Exchange解析”小节的三种Exchange</li></ol></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;br&gt;

&lt;h1 id=&quot;思想纲领&quot;&gt;&lt;a href=&quot;#思想纲领&quot; class=&quot;headerlink&quot; title=&quot;思想纲领&quot;&gt;&lt;/a&gt;思想纲领&lt;/h1&gt;&lt;h2 id=&quot;为什么要学习RabbitMQ？&quot;&gt;&lt;a href=&quot;#为什么要学习RabbitMQ？&quot; class=&quot;</summary>
      
    
    
    
    <category term="MQ" scheme="https://ratears.github.io/dev.ratears.life/Categories/MQ/"/>
    
    <category term="RabbitMQ" scheme="https://ratears.github.io/dev.ratears.life/Categories/MQ/RabbitMQ/"/>
    
    
    <category term="MQ" scheme="https://ratears.github.io/dev.ratears.life/Tags/MQ/"/>
    
    <category term="RabbitMQ" scheme="https://ratears.github.io/dev.ratears.life/Tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>《零基础入门 详解企业主流数据库MySQL8.0》Study Notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/%E3%80%8A%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E8%AF%A6%E8%A7%A3%E4%BC%81%E4%B8%9A%E4%B8%BB%E6%B5%81%E6%95%B0%E6%8D%AE%E5%BA%93MySQL8-0%E3%80%8BStudy-Notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/%E3%80%8A%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E8%AF%A6%E8%A7%A3%E4%BC%81%E4%B8%9A%E4%B8%BB%E6%B5%81%E6%95%B0%E6%8D%AE%E5%BA%93MySQL8-0%E3%80%8BStudy-Notes/</id>
    <published>2023-05-09T16:51:26.000Z</published>
    <updated>2023-05-09T16:51:26.000Z</updated>
    
    <content type="html"><![CDATA[<br><h1 id="第1章-开篇引导"><a href="#第1章-开篇引导" class="headerlink" title="第1章 开篇引导"></a>第1章 开篇引导</h1><br><br><br><h1 id="数据库选型"><a href="#数据库选型" class="headerlink" title="数据库选型"></a>数据库选型</h1><h2 id="SQL（关系型数据库）"><a href="#SQL（关系型数据库）" class="headerlink" title="SQL（关系型数据库）"></a>SQL（关系型数据库）</h2><ul><li><p><strong>常见的关系型数据库：</strong></p><ul><li>MysQL</li><li>Oracle</li><li>SQLServer</li><li>PostGreSQL</li></ul></li><li><p><strong>关系型数据库的特点：</strong></p><ul><li>数据结构化存储在二维表中</li><li>支持事务的原子性A,一致性C,隔离性I,持久性D 特性</li><li>支持使用SQL语言对存储在其中的数据进行操作</li></ul></li><li><p><strong>关系数据库的适用场景：</strong></p><ul><li>数据之间存在着一定关系，需要关联查询数据的场景</li><li>需要事务支持的业务场景</li><li>需要使用SQL语言灵活操作数据的场景</li></ul></li></ul><h2 id="NoSQL（非关系型数据库概述）"><a href="#NoSQL（非关系型数据库概述）" class="headerlink" title="NoSQL（非关系型数据库概述）"></a>NoSQL（非关系型数据库概述）</h2><ul><li><p><strong>常见的非关系型数据库：</strong></p><ul><li>HBase</li><li>MongoDB</li><li>Redis</li><li>Hadoop</li></ul></li><li><p><strong>非关系数据库的特点</strong></p><ul><li>存储结构灵活，没有固定的结构（在不考虑数据压缩的情况下，可能会占用更多的存储空间，因为存储了列名）</li><li>对事务的支持比较弱，但对数据的并发处理性能高</li><li>大多不使用SQL语言操作数据</li></ul></li><li><p><strong>非关系数据库的适用场景</strong></p><ul><li>数据结构不固定的场景</li><li>对事务要求不高，但读写并发比较大的场景</li><li>对数据的处理操作比较简单的场景</li></ul></li></ul><h2 id="关系数据库选型原则"><a href="#关系数据库选型原则" class="headerlink" title="关系数据库选型原则"></a>关系数据库选型原则</h2><ul><li><strong>数据库使用的广泛性</strong><ul><li>MySQL在数据库使用排行榜中名列前茅</li></ul></li><li><strong>数据库的可扩展性</strong><ul><li>支持基于二进制日志的逻辑复制</li><li>存在多种第三方数据库中间层，支持读写分离及分库分表</li></ul></li><li><strong>数据库的安全性和稳定性</strong><ul><li>MySQL主从复制集群可达到99%的可用性</li><li>配合主从复制高可用架构可以达到99.99%的可用性</li><li>支持对存储在MySQL的数据进行分级安全控制</li></ul></li><li><strong>数据库所支持的系统</strong><ul><li>支持Liunx系统</li><li>支持Windows系统</li></ul></li><li><strong>数据库的使用成本</strong><ul><li>社区版本免费</li><li>使用人员众多，可以方便的获取技术支持</li></ul></li></ul><h2 id="构建MySQL开发环境"><a href="#构建MySQL开发环境" class="headerlink" title="构建MySQL开发环境"></a>构建MySQL开发环境</h2><ol><li>环境准备：CentOS7</li><li>下载并解压mysql到服务器</li><li>配置mysql的配置文件my.cnf，（配置mysql的环境变量）</li><li>初始化mysql</li><li>启动mysql</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src/</span><br><span class="line"></span><br><span class="line">wget https://downloads.mysql.com/archives/get/p/23/file/mysql-8.0.15-linux-glibc2.12-x86_64.tar.xz</span><br><span class="line"></span><br><span class="line">xz -d mysql-8.0.15-linux-glibc2.12-x86_64.tar.xz</span><br><span class="line"></span><br><span class="line">tar xf mysql-8.0.15-linux-glibc2.12-x86_64.tar</span><br><span class="line"></span><br><span class="line">mv /usr/local/src/mysql-8.0.15-linux-glibc2.12-x86_64 /usr/local/</span><br><span class="line"></span><br><span class="line">cd /usr/local/</span><br><span class="line"></span><br><span class="line">ln -s mysql-8.0.15-linux-glibc2.12-x86_64/ mysql</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改mysql读取的配置文件</span></span><br><span class="line">vim /etc/my.cnf</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">port            = 3306</span><br><span class="line">socket          = /usr/local/mysql/data/mysql.sock</span><br><span class="line">[mysqld]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Skip <span class="comment">#</span></span></span><br><span class="line">skip_name_resolve              = 1</span><br><span class="line">skip_external_locking          = 1 </span><br><span class="line">skip_symbolic_links     = 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">GENERAL <span class="comment">#</span></span></span><br><span class="line">user = mysql</span><br><span class="line">default_storage_engine = InnoDB</span><br><span class="line">character-set-server = utf8</span><br><span class="line">socket  = /usr/local/mysql/data/mysql.sock</span><br><span class="line">pid_file = /usr/local/mysql/data/mysqld.pid</span><br><span class="line">basedir = /usr/local/mysql</span><br><span class="line">port = 3306</span><br><span class="line">bind-address = 0.0.0.0</span><br><span class="line">explicit_defaults_for_timestamp = off</span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">read_only=on</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">MyISAM <span class="comment">#</span></span></span><br><span class="line">key_buffer_size                = 32M</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">myisam_recover                 = FORCE,BACKUP</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">undo <span class="built_in">log</span> <span class="comment">#</span></span></span><br><span class="line">innodb_undo_directory = /usr/local/mysql/undo</span><br><span class="line">innodb_undo_tablespaces = 8</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SAFETY <span class="comment">#</span></span></span><br><span class="line">max_allowed_packet             = 100M</span><br><span class="line">max_connect_errors             = 1000000</span><br><span class="line">sysdate_is_now                 = 1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">innodb = FORCE</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">innodb_strict_mode = 1</span></span><br><span class="line">secure-file-priv=&#x27;/tmp&#x27;</span><br><span class="line">default_authentication_plugin=&#x27;mysql_native_password&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replice <span class="comment">#</span></span></span><br><span class="line"> server-id = 1001</span><br><span class="line"> relay_log = mysqld-relay-bin</span><br><span class="line"> gtid_mode = on</span><br><span class="line"> enforce-gtid-consistency</span><br><span class="line"> log-slave-updates = on</span><br><span class="line"> master_info_repository =TABLE</span><br><span class="line"> relay_log_info_repository =TABLE</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">DATA STORAGE <span class="comment">#</span></span></span><br><span class="line"> datadir = /usr/local/mysql/data/</span><br><span class="line"> tmpdir = /tmp</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">BINARY LOGGING <span class="comment">#</span></span></span><br><span class="line"> log_bin = /usr/local/mysql/sql_log/mysql-bin</span><br><span class="line"> max_binlog_size = 1000M</span><br><span class="line"> binlog_format = row</span><br><span class="line"> binlog_expire_logs_seconds=86400</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sync_binlog = 1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">CACHES AND LIMITS <span class="comment">#</span></span></span><br><span class="line"> tmp_table_size                 = 32M</span><br><span class="line"> max_heap_table_size            = 32M</span><br><span class="line"> max_connections                = 4000</span><br><span class="line"> thread_cache_size              = 2048</span><br><span class="line"> open_files_limit               = 65535</span><br><span class="line"> table_definition_cache         = 4096</span><br><span class="line"> table_open_cache               = 4096</span><br><span class="line"> sort_buffer_size               = 2M</span><br><span class="line"> read_buffer_size               = 2M</span><br><span class="line"> read_rnd_buffer_size           = 2M</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">thread_concurrency             = 24</span></span><br><span class="line"> join_buffer_size = 1M</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">table_cache = 32768</span></span><br><span class="line"> thread_stack = 512k</span><br><span class="line"> max_length_for_sort_data = 16k</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">INNODB <span class="comment">#</span></span></span><br><span class="line"> innodb_flush_method            = O_DIRECT</span><br><span class="line"> innodb_log_buffer_size = 16M</span><br><span class="line"> innodb_flush_log_at_trx_commit = 2</span><br><span class="line"> innodb_file_per_table          = 1</span><br><span class="line"> innodb_buffer_pool_size        = 256M</span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">innodb_buffer_pool_instances = 8</span></span><br><span class="line"> innodb_stats_on_metadata = off</span><br><span class="line"> innodb_open_files = 8192</span><br><span class="line"> innodb_read_io_threads = 16</span><br><span class="line"> innodb_write_io_threads = 16</span><br><span class="line"> innodb_io_capacity = 20000</span><br><span class="line"> innodb_thread_concurrency = 0</span><br><span class="line"> innodb_lock_wait_timeout = 60</span><br><span class="line"> innodb_old_blocks_time=1000</span><br><span class="line"> innodb_use_native_aio = 1</span><br><span class="line"> innodb_purge_threads=1</span><br><span class="line"> innodb_change_buffering=all</span><br><span class="line"> innodb_log_file_size = 64M</span><br><span class="line"> innodb_log_files_in_group = 2</span><br><span class="line"> innodb_data_file_path  = ibdata1:256M:autoextend</span><br><span class="line"> </span><br><span class="line"> innodb_rollback_on_timeout=on</span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">LOGGING <span class="comment">#</span></span></span><br><span class="line"> log_error                      = /usr/local/mysql/sql_log/mysql-error.log</span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">log_queries_not_using_indexes  = 1</span></span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">slow_query_log                 = 1</span></span><br><span class="line">  slow_query_log_file            = /usr/local/mysql/sql_log/slowlog.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">TimeOut <span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">interactive_timeout = 30</span></span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">wait_timeout        = 30</span></span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">net_read_timeout = 60</span></span><br><span class="line"></span><br><span class="line">[mysqldump]</span><br><span class="line">quick</span><br><span class="line">max_allowed_packet = 100M</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">no-auto-rehash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Remove the next comment character <span class="keyword">if</span> you are not familiar with SQL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">safe-updates</span></span><br><span class="line"></span><br><span class="line">[myisamchk]</span><br><span class="line">key_buffer_size = 256M</span><br><span class="line">sort_buffer_size = 256M</span><br><span class="line">read_buffer = 2M</span><br><span class="line">write_buffer = 2M</span><br><span class="line"></span><br><span class="line">[mysqlhotcopy]</span><br><span class="line">interactive-timeout</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/mysql</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建需要的mysql目录，并改变属主、权限</span></span><br><span class="line">mkdir data sql_log undo</span><br><span class="line"></span><br><span class="line">chown -R mysql.mysql data/ sql_log/ undo/</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置mysql的环境变量</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">export PATH=$JAVA_HOME/bin:/usr/local/mysql/bin:$PATH</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化mysql8</span></span><br><span class="line">mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data</span><br><span class="line"></span><br><span class="line">cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/mysqld start</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看mysql的初始密码</span></span><br><span class="line">grep password /usr/local/mysql/sql_log/mysql-error.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改mysql的初始密码</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">alter user user() identified by <span class="string">&#x27;root&#x27;</span>;</span></span><br></pre></td></tr></table></figure><br><br><br><h1 id="数据库结构设计"><a href="#数据库结构设计" class="headerlink" title="数据库结构设计"></a>数据库结构设计</h1><h2 id="宽表模式"><a href="#宽表模式" class="headerlink" title="宽表模式"></a>宽表模式</h2><ul><li><p>宽表模式存在的问题</p><ul><li><p>数据几余:相同的数据在一个表中出现了多次</p></li><li><p>数据更新异常:修改一行中某列的值时，同时修改了多行数据</p></li><li><p>数据插入异常:部分数据由于缺失主键信息而无法写入表中</p></li><li><p>数据删除异常:删除某一数据时不得不删除另一数据</p></li></ul></li><li><p>宽表模式的应用场景</p><ul><li>配合列存储的数据报表应用</li></ul></li></ul><h2 id="数据库设计范式"><a href="#数据库设计范式" class="headerlink" title="数据库设计范式"></a>数据库设计范式</h2><ul><li><strong>第一范式：表中的所有字段都是不可再分的</strong><ul><li>符合第一范式的表全部都是二维表</li></ul></li><li><strong>第二范式：表中必须存在业务主键，并且非主键依赖于全部业务主键</strong><ul><li>第二范式是在第一范式的基础上定义的（也就是说第二范式的表一定是一个标准的二维表）</li></ul></li><li><strong>第三范式：表中的非主键列之间不能相互依赖</strong><ul><li>第三范式是在第一、第二范式的基础上定义的</li></ul></li></ul><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><p>1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;br&gt;

&lt;h1 id=&quot;第1章-开篇引导&quot;&gt;&lt;a href=&quot;#第1章-开篇引导&quot; class=&quot;headerlink&quot; title=&quot;第1章 开篇引导&quot;&gt;&lt;/a&gt;第1章 开篇引导&lt;/h1&gt;&lt;br&gt;

&lt;br&gt;

&lt;br&gt;

&lt;h1 id=&quot;数据库选型&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="DataBase" scheme="https://ratears.github.io/dev.ratears.life/Categories/DataBase/"/>
    
    <category term="MySQL" scheme="https://ratears.github.io/dev.ratears.life/Categories/DataBase/MySQL/"/>
    
    
    <category term="DataBase" scheme="https://ratears.github.io/dev.ratears.life/Tags/DataBase/"/>
    
    <category term="MySQL" scheme="https://ratears.github.io/dev.ratears.life/Tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>《MySQL面试指南 中高级开发者的晋升加薪利器》Study Notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/%E3%80%8AMySQL%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97-%E4%B8%AD%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E6%99%8B%E5%8D%87%E5%8A%A0%E8%96%AA%E5%88%A9%E5%99%A8%E3%80%8BStudy-Notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/%E3%80%8AMySQL%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97-%E4%B8%AD%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E6%99%8B%E5%8D%87%E5%8A%A0%E8%96%AA%E5%88%A9%E5%99%A8%E3%80%8BStudy-Notes/</id>
    <published>2023-05-02T16:05:45.000Z</published>
    <updated>2023-05-02T16:05:45.000Z</updated>
    
    <content type="html"><![CDATA[<br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><ul><li><strong>需要体察问题背后，面试官想考察的内容</strong></li><li>某些内容即使没有完全实践过，但是可以根据已有的实践经验扩展，结合实践来记忆、回答相关问题，是最好的</li></ul><h1 id="MySQL版本类问题"><a href="#MySQL版本类问题" class="headerlink" title="MySQL版本类问题"></a>MySQL版本类问题</h1><br><br><br><h1 id="学习备注-1"><a href="#学习备注-1" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><p>1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;br&gt;

&lt;h1 id=&quot;学习备注&quot;&gt;&lt;a href=&quot;#学习备注&quot; class=&quot;headerlink&quot; title=&quot;学习备注&quot;&gt;&lt;/a&gt;学习备注&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;需要体察问题背后，面试官想考察的内容&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;某些内容即</summary>
      
    
    
    
    <category term="DataBase" scheme="https://ratears.github.io/dev.ratears.life/Categories/DataBase/"/>
    
    <category term="MySQL" scheme="https://ratears.github.io/dev.ratears.life/Categories/DataBase/MySQL/"/>
    
    
    <category term="DataBase" scheme="https://ratears.github.io/dev.ratears.life/Tags/DataBase/"/>
    
    <category term="MySQL" scheme="https://ratears.github.io/dev.ratears.life/Tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>《从 0 开始学微服务》Study Notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/%E3%80%8A%E4%BB%8E-0-%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%BE%AE%E6%9C%8D%E5%8A%A1%E3%80%8BStudy-Notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/%E3%80%8A%E4%BB%8E-0-%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%BE%AE%E6%9C%8D%E5%8A%A1%E3%80%8BStudy-Notes/</id>
    <published>2023-04-24T08:52:04.000Z</published>
    <updated>2023-04-24T08:52:04.000Z</updated>
    
    <content type="html"><![CDATA[<br><br><br><h1 id="模块一-入门微服务-10讲"><a href="#模块一-入门微服务-10讲" class="headerlink" title="模块一 入门微服务 (10讲)"></a>模块一 入门微服务 (10讲)</h1><h2 id="01-到底什么是微服务？"><a href="#01-到底什么是微服务？" class="headerlink" title="01 | 到底什么是微服务？"></a>01 | 到底什么是微服务？</h2><ul><li>微服务的概念最早是在2014年由Martin Fowler和James Lewis共同提出</li><li><strong>微服务是由单一应用程序构成的小服务，拥有自己的进程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用HTTP API通讯。同时，服务会使用最小规模的集中管理 （例如Docker）技术，服务可以用不同的编程语言与数据库等。</strong></li></ul><h3 id="单体应用"><a href="#单体应用" class="headerlink" title="单体应用"></a>单体应用</h3><ul><li>LAMP或MVC，都是为单体应用架构设计的<ul><li>优点是学习成本低，开发上手快，测试、部署、运维也比较方便</li></ul></li><li>随着业务规模扩大，团队扩张。单体架构开始出现问题<ul><li><strong>部署效率低下</strong>：单体应用的代码越来越多，依赖的资源越来越多时，应用编译打包、部署测试一次，甚至需要10分钟以上</li><li><strong>团队协作开发成本高</strong>：一旦团队人员扩张，超过5人修改代码，然后一起打包部署，测试阶段只要有一块功能有问题，就得重新编译打包部署，然后重新预览测试，所有相关的开发人员又都得参与其中，效率低下，开发成本极高。</li><li><strong>系统高可用性差</strong>：因为所有的功能开发最后都部署到同一个WAR包里，运行在同一个Tomcat进程之中，一旦某一功能涉及的代码或者资源有问题，那就会影响整个WAR包中部署的功能。</li><li><strong>线上发布变慢</strong>：对于Java应用来说，一旦代码膨胀，服务启动的时间就会变长，有些甚至超过10分钟以上，如果机器规模超过100台以上，假设每次发布的步长为10%，单次发布需要就需要100分钟之久。因此，急需一种方法能够将应用的不同模块的解耦，降低开发和部署成本。</li></ul></li><li>针对单体架构带来的问题，服务化的思想应运而生</li></ul><h3 id="什么是服务化？"><a href="#什么是服务化？" class="headerlink" title="什么是服务化？"></a>什么是服务化？</h3><ul><li>服务化就是把传统的单机应用中通过JAR包依赖产生的本地方法调用，改造成通过RPC接口产生的远程方法调用。</li><li>通过服务化，可以解决单体应用膨胀、团队开发耦合度高、协作效率低下的问题</li></ul><h3 id="什么是微服务？"><a href="#什么是微服务？" class="headerlink" title="什么是微服务？"></a>什么是微服务？</h3><ul><li>从2014年开始，得益于以Docker为代表的容器化技术的成熟以及DevOps文化的兴起，服务化的思想进一步演化，演变为今天我们所熟知的微服务。</li><li>微服务相比于服务化又有什么不同呢？<ul><li><strong>服务拆分粒度更细</strong>：微服务可以说是更细维度的服务化，小到一个子模块，只要该模块依赖的资源与其他模块都没有关系，那么就可以拆分为一个微服务。</li><li><strong>服务独立部署</strong>：每个微服务都严格遵循独立打包部署的准则，互不影响。比如一台物理机上可以部署多个Docker实例，每个Docker实例可以部署一个微服务的代码。</li><li><strong>服务独立维护</strong>：每个微服务都可以交由一个小团队甚至个人来开发、测试、发布和运维，并对整个生命周期负责</li><li><strong>服务治理能力要求高</strong>：拆分为微服务之后，服务的数量变多，因此需要有统一的服务治理平台，来对各个服务进行管理</li></ul></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>微服务的发展由来：由单体应用进化到服务化拆分部署，后期随着移动互联网规模的不断扩大，敏捷开发、持续交付、DevOps理论的发展和实践，以及基于Docker容器化技术的成熟，微服务架构开始流行，逐渐成为应用架构的未来演进方向</li><li>微服务架构是将复杂臃肿的单体应用进行细粒度的服务化拆分，每个拆分出来的服务各自独立打包部署，并交由小团队进行开发和运维，从而极大地提高了应用交付的效率，并被各大互联网公司所普遍采用。</li></ul><br><br><br><h2 id="02-从单体应用走向服务化"><a href="#02-从单体应用走向服务化" class="headerlink" title="02 | 从单体应用走向服务化"></a>02 | 从单体应用走向服务化</h2><h3 id="什么时候进行服务化拆分？"><a href="#什么时候进行服务化拆分？" class="headerlink" title="什么时候进行服务化拆分？"></a>什么时候进行服务化拆分？</h3><ul><li>项目第一阶段的主要目标是快速开发和验证想法，证明产品思路是否可行。这个阶段功能设计一般不会太复杂，开发采取快速迭代的方式，架构也不适合过度设计。所以将所有功能打包部署在一起，集中地进行开发、测试和运维，对于项目起步阶段，是最高效也是最节省成本的方式。当可行性验证通过，功能进一步迭代，就可以加入越来越多的新特性。</li><li>一旦单体应用同时进行开发的人员超过10人。这个时候就该考虑进行服务化拆分了</li></ul><h3 id="服务化拆分的两种姿势"><a href="#服务化拆分的两种姿势" class="headerlink" title="服务化拆分的两种姿势"></a>服务化拆分的两种姿势</h3><h4 id="纵向拆分"><a href="#纵向拆分" class="headerlink" title="纵向拆分"></a><strong>纵向拆分</strong></h4><ul><li>从业务维度进行拆分。标准是按照业务的关联程度来决定，关联比较密切的业务适合拆分为一个微服务，而功能相对比较独立的业务适合单独拆分为一个微服务。</li></ul><h4 id="横向拆分"><a href="#横向拆分" class="headerlink" title="横向拆分"></a><strong>横向拆分</strong></h4><ul><li>从公共且独立功能维度拆分。标准是按照是否有公共的被多个其他服务调用，且依赖的资源独立不与其他业务耦合。</li></ul><h3 id="服务化拆分的前置条件"><a href="#服务化拆分的前置条件" class="headerlink" title="服务化拆分的前置条件"></a>服务化拆分的前置条件</h3><ul><li>一般情况下，业务系统引入新技术就必然会带来架构的复杂度提升，在具体决策前，你先要认识到新架构会带来哪些新的问题，这些问题你和你的团队是否能够解决？如何解决？是自己投入人力建设，还是采用业界开源方案？</li><li><strong>服务如何定义</strong>：服务之间的调用都通过接口描述来约定，约定内容包括接口名、接口参数以及接口返回值。</li><li><strong>服务如何发布和订阅</strong>：记录每个服务提供者的地址以供服务调用者查询，注册中心</li><li><strong>服务如何监控</strong>：需要一种通用的监控方案，能够覆盖业务埋点、数据收集、数据处理，最后到数据展示的全链路功能</li><li><strong>服务如何治理</strong>：熔断…</li><li><strong>故障如何定位</strong>：需要有一种解决方案能够将一次用户请求进行标记，并在多个依赖的服务系统中继续传递，以便串联所有路径，从而进行故障定位</li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>必须有可行的解决方案之后，才能进一步进行服务化拆分</li><li>无论是纵向拆分还是横向拆分，都是将单体应用庞杂的功能进行拆分，抽离成单独的服务部署。</li><li>并不是说功能拆分的越细越好，过度的拆分反而会让服务数量膨胀变得难以管理，因此找到符合自己业务现状和团队人员技术水平的拆分粒度才是可取</li><li>建议的标准是按照每个开发人员负责不超过3个大的服务为标准，毕竟每个人的精力是有限的，所以在拆分微服务时，可以按照开发人员的总人数来决定。</li></ul><br><br><br><h2 id="03-初探微服务架构"><a href="#03-初探微服务架构" class="headerlink" title="03 | 初探微服务架构"></a>03 | 初探微服务架构</h2><h3 id="微服务架构模块图"><a href="#微服务架构模块图" class="headerlink" title="微服务架构模块图"></a>微服务架构模块图</h3><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.adakifbsy7s.webp" width="80%"><br><h3 id="正常的服务调用的流程"><a href="#正常的服务调用的流程" class="headerlink" title="正常的服务调用的流程"></a>正常的服务调用的流程</h3><ol><li>服务提供者（就是提供服务的一方）按照一定格式的服务描述，向注册中心注册服务，声明自己能够提供哪些服务以及服务的地址是什么，完成服务发布</li><li>服务消费者（就是调用服务的一方）请求注册中心，查询所需要调用服务的地址，然后以约定的通信协议向服务提供者发起请求，得到请求结果后再按照约定的协议解析结果。</li><li>在服务的调用过程中，服务的请求耗时、调用量以及成功率等指标都会被记录下来用作监控，调用经过的链路信息会被记录下来，用于故障定位和问题追踪。在这期间，如果调用失败，可以通过重试等服务治理手段来保证成功率。</li></ol><ul><li>微服务架构下，服务调用主要依赖下面几个基本组件：<ul><li>服务描述</li><li>注册中心</li><li>服务框架</li><li>服务监控</li><li>服务追踪</li><li>服务治理</li></ul></li></ul><h3 id="服务描述"><a href="#服务描述" class="headerlink" title="服务描述"></a>服务描述</h3><ul><li><p>服务调用首先要解决的问题就是服务如何对外描述：比如，你对外提供了一个服务，那么这个服务的服务名叫什么？调用这个服务需要提供哪些信息？调用这个服务返回的结果是什么格式的？该如何解析？这些就是服务描述要解决的问题</p></li><li><p>常用的服务描述方式：RESTful API、XML配置以及IDL文件三种。</p><ul><li>RESTful API方式通常用于HTTP协议的服务描述，并且常用Wiki或者<a class="link"   href="http://swagger.io/" >Swagger<i class="fas fa-external-link-alt"></i></a>来进行管理</li><li>XML配置方式多用作RPC协议的服务描述，通过*.xml配置文件来定义接口名、参数以及返回值类型等</li><li>IDL文件方式通常用作Thrift和gRPC这类跨语言服务调用框架中，比如gRPC就是通过Protobuf文件来定义服务的接口名、参数以及返回值的数据结构</li></ul></li></ul><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><ul><li>有了服务的接口描述，下一步要解决的问题就是服务的发布和订阅：就是说你提供了一个服务，如何让外部想调用你的服务的人知道。这个时候就需要一个类似注册中心的角色，服务提供者将自己提供的服务以及地址登记到注册中心，服务消费者则从注册中心查询所需要调用的服务的地址，然后发起请求。</li></ul><h4 id="一般来讲，注册中心的工作流程是："><a href="#一般来讲，注册中心的工作流程是：" class="headerlink" title="一般来讲，注册中心的工作流程是："></a>一般来讲，注册中心的工作流程是：</h4><ol><li>服务提供者在启动时，根据服务发布文件中配置的发布信息向注册中心注册自己的服务。</li><li>服务消费者在启动时，根据消费者配置文件中配置的服务信息向注册中心订阅自己所需要的服务。</li><li>注册中心返回服务提供者地址列表给服务消费者。</li><li>当服务提供者发生变化，比如有节点新增或者销毁，注册中心将变更通知给服务消费者。</li></ol><h3 id="服务框架"><a href="#服务框架" class="headerlink" title="服务框架"></a>服务框架</h3><ul><li>在发起调用之前你还需要解决以下几个问题<ul><li>指标收集。就是要把每一次服务调用的请求耗时以及成功与否收集起来，并上传到集中的数据处理中心。</li><li>数据处理。有了每次调用的请求耗时以及成功与否等信息，就可以计算每秒服务请求量、平均耗时以及成功率等指标。</li><li>数据展示。数据收集起来，经过处理之后，还需要以友好的方式对外展示，才能发挥价值。通常都是将数据展示在Dashboard面板上，并且每隔10s等间隔自动刷新，用作业务监控和报警等</li></ul></li></ul><h3 id="服务追踪"><a href="#服务追踪" class="headerlink" title="服务追踪"></a>服务追踪</h3><ul><li>除了需要对服务调用情况进行监控之外，你还需要记录服务调用经过的每一层链路，以便进行问题追踪和故障定位。</li><li>服务追踪的工作原理大致如下：<ul><li>服务消费者发起调用前，会在本地按照一定的规则生成一个requestid，发起调用时，将requestid当作请求参数的一部分，传递给服务提供者。</li><li>服务提供者接收到请求后，记录下这次请求的requestid，然后处理请求。如果服务提供者继续请求其他服务，会在本地再生成一个自己的requestid，然后把这两个requestid都当作请求参数继续往下传递。</li></ul></li></ul><blockquote><p>以此类推，通过这种层层往下传递的方式，一次请求，无论最后依赖多少次服务调用、经过多少服务节点，都可以通过最开始生成的requestid串联所有节点，从而达到服务追踪的目的。</p></blockquote><h3 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h3><ul><li><p>服务治理就是通过一系列的手段来保证在各种意外情况下，服务调用仍然能够正常进行</p></li><li><p>生产环境中，你应该经常会遇到下面几种状况。</p><ul><li>单机故障。通常遇到单机故障，都是靠运维发现并重启服务或者从线上摘除故障节点。然而集群的规模越大，越是容易遇到单机故障，在机器规模超过一百台以上时，靠传统的人肉运维显然难以应对。而服务治理可以通过一定的策略，自动摘除故障节点，不需要人为干预，就能保证单机故障不会影响业务。</li><li>单IDC故障。你应该经常听说某某App，因为施工挖断光缆导致大批量用户无法使用的严重故障。而服务治理可以通过自动切换故障IDC的流量到其他正常IDC，可以避免因为单IDC故障引起的大批量业务受影响。</li><li>依赖服务不可用。比如你的服务依赖依赖了另一个服务，当另一个服务出现问题时，会拖慢甚至拖垮你的服务。而服务治理可以通过熔断，在依赖服务异常的情况下，一段时期内停止发起调用而直接返回。这样一方面保证了服务消费者能够不被拖垮，另一方面也给服务提供者减少压力，使其能够尽快恢复。</li></ul></li></ul><blockquote><p>还有一些其他服务治理的手段比如自动扩缩容，可以用来解决服务的容量问题。</p></blockquote><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul><li>在引入微服务架构之前，你的团队必须掌握这些基本组件的原理并具备相应的开发能力</li><li>实现方式上，可以引入开源方案</li><li>如果有充足的资深技术人员，也可以选择自行研发微服务架构的每个组件。</li><li>对于大部分中小团队来说，我认为采用开源实现方案是一个更明智的选择，一方面你可以节省相关技术人员的投入从而更专注于业务，另一方面也可以少走弯路少踩坑。不管你是采用开源方案还是自行研发，<strong>都必须吃透每个组件的工作原理并能在此基础上进行二次开发</strong>。</li></ul><br><br><br><h2 id="04-如何发布和引用服务？"><a href="#04-如何发布和引用服务？" class="headerlink" title="04 | 如何发布和引用服务？"></a>04 | 如何发布和引用服务？</h2><h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><ul><li>RESTful API的方式，主要被<strong>用作HTTP或者HTTPS协议的接口定义</strong></li><li>因为HTTP协议本身是一个公开的协议，对于服务消费者来说几乎没有学习成本，所以比较适合用作跨业务平台之间的服务协议。比如你有一个服务，不仅需要在业务部门内部提供服务，还需要向其他业务部门提供服务，甚至开放给外网提供服务，这时候采用HTTP协议就比较合适，也省去了沟通服务协议的成本。</li></ul><h3 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h3><ul><li><p>XML配置方式，这种方式的服务发布和引用主要分三个步骤：</p><ul><li>服务提供者定义接口，并实现接口。</li><li>服务提供者进程启动时，通过加载server.xml配置文件将接口暴露出去。</li><li>服务消费者进程启动时，通过加载client.xml配置文件来引入要调用的接口。</li></ul></li><li><p>一般是私有RPC框架会选择XML配置这种方式来描述接口，因为私有RPC协议的性能要比HTTP协议高，所以在对性能要求比较高的场景下，采用XML配置的方式比较合适。但这种方式对业务代码侵入性比较高，XML配置有变更的时候，服务消费者和服务提供者都要更新，所以适合公司内部联系比较紧密的业务之间采用。如果要应用到跨部门之间的业务调用，一旦有XML配置变更，需要花费大量精力去协调不同部门做升级工作。</p></li><li><p>对于XML配置方式的服务描述，一旦应用到多个部门之间的接口格式约定，如果有变更，最好是新增接口，不到万不得已不要对原有的接口格式做变更。</p></li></ul><h3 id="IDL文件"><a href="#IDL文件" class="headerlink" title="IDL文件"></a>IDL文件</h3><ul><li>IDL就是接口描述语言（interface description language）的缩写，通过一种中立的方式来描述接口，使得在不同的平台上运行的对象和不同语言编写的程序可以相互通信交流。</li><li>IDL主要是<strong>用作跨语言平台的服务之间的调用</strong>，有两种最常用的IDL：一个是Facebook开源的<strong>Thrift协议</strong>，另一个是Google开源的<strong>gRPC协议</strong>。无论是Thrift协议还是gRPC协议，它们的工作原理都是类似的。</li><li>gRPC协议的服务描述是通过proto文件来定义接口的，然后再使用protoc来生成不同语言平台的客户端和服务端代码，从而具备跨语言服务调用能力。</li><li>在描述接口定义时，IDL文件需要对接口返回值进行详细定义。如果接口返回值的字段比较多，并且经常变化时，采用IDL文件方式的接口定义就不太合适了。一方面可能会造成IDL文件过大难以维护，另一方面只要IDL文件中定义的接口返回值有变更，都需要同步所有的服务消费者都更新，管理成本就太高了。</li></ul><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.74wqnnt5ik00.webp" width="70%"><br><br><br><h2 id="05-如何注册和发现服务？"><a href="#05-如何注册和发现服务？" class="headerlink" title="05 | 如何注册和发现服务？"></a>05 | 如何注册和发现服务？</h2><h3 id="注册中心原理"><a href="#注册中心原理" class="headerlink" title="注册中心原理"></a>注册中心原理</h3><ul><li><p>在微服务架构下，主要有三种角色：</p><ul><li>服务提供者（RPC Server）</li><li>服务消费者（RPC Client）</li><li>服务注册中心（Registry）</li></ul></li><li><p>RPC Server提供服务，在启动时，根据服务发布文件server.xml中的配置的信息，向Registry注册自身服务，并向Registry定期发送心跳汇报存活状态</p></li><li><p>RPC Client调用服务，在启动时，根据服务引用文件client.xml中配置的信息，向Registry订阅服务，把Registry返回的服务节点列表缓存在本地内存中，并与RPC Sever建立连接</p></li><li><p>当RPC Server节点发生变更时，Registry会同步变更，RPC Client感知后会刷新本地内存中缓存的服务节点列表</p></li><li><p>RPC Client从本地缓存的服务节点列表中，基于负载均衡算法选择一台RPC Sever发起调用</p></li></ul><h2 id="注册中心实现方式"><a href="#注册中心实现方式" class="headerlink" title="注册中心实现方式"></a>注册中心实现方式</h2><ul><li><strong>注册中心的实现主要涉及几个问题：</strong><ul><li>注册中心需要提供哪些接口</li><li>该如何部署；</li><li>如何存储服务信息；</li><li>如何监控服务提供者节点的存活</li><li>如果服务提供者节点有变化如何通知服务消费者</li><li>如何控制注册中心的访问权限</li></ul></li></ul><h4 id="1-注册中心API"><a href="#1-注册中心API" class="headerlink" title="1. 注册中心API"></a><strong>1. 注册中心API</strong></h4><ul><li>服务注册接口：服务提供者通过调用服务注册接口来完成服务注册</li><li>服务反注册接口：服务提供者通过调用服务反注册接口来完成服务注销</li><li>心跳汇报接口：服务提供者通过调用心跳汇报接口完成节点存活状态上报</li><li>服务订阅接口：服务消费者通过调用服务订阅接口完成服务订阅，获取可用的服务提供者节点列表</li><li>服务变更查询接口：服务消费者通过调用服务变更查询接口，获取最新的可用服务节点列表</li><li>服务查询接口：查询注册中心当前注册了哪些服务信息。</li><li>服务修改接口：修改注册中心中某一服务的信息</li></ul><h4 id="2-集群部署"><a href="#2-集群部署" class="headerlink" title="2. 集群部署"></a><strong>2. 集群部署</strong></h4><ul><li><p><strong>注册中心一般都是采用集群部署来保证高可用性，并通过分布式一致性协议来确保集群中不同节点之间的数据保持一致</strong></p></li><li><p>以开源注册中心ZooKeeper为例，ZooKeeper集群中包含多个节点，服务提供者和服务消费者可以同任意一个节点通信，因为它们的数据一定是相同的</p></li><li><p>ZooKeeper的工作原理</p><ul><li>每个Server在内存中存储了一份数据，Client的读请求可以请求任意一个Server。</li><li>ZooKeeper启动时，将从实例中选举一个leader（Paxos协议）。</li><li>Leader负责处理数据更新等操作（ZAB协议）。</li><li>一个更新操作成功，当且仅当大多数Server在内存中成功修改 。</li></ul></li></ul><blockquote><p>通过上面这种方式，ZooKeeper保证了高可用性以及数据一致性。</p></blockquote><h4 id="3-目录存储"><a href="#3-目录存储" class="headerlink" title="3. 目录存储"></a><strong>3. 目录存储</strong></h4><ul><li>以ZooKeeper为例，注册中心存储服务信息一般采用层次化的目录结构：<ul><li>每个目录在ZooKeeper中叫作znode，并且其有一个唯一的路径标识。</li><li>znode可以包含数据和子znode。</li><li>znode中的数据可以有多个版本，比如某一个znode下存有多个数据版本，那么查询这个路径下的数据需带上版本信息。</li></ul></li></ul><h4 id="4-服务健康状态检测"><a href="#4-服务健康状态检测" class="headerlink" title="4. 服务健康状态检测"></a><strong>4. 服务健康状态检测</strong></h4><ul><li>必须具备对服务提供者节点的健康状态检测功能，这样才能保证注册中心里保存的服务节点都是可用的</li><li>以ZooKeeper为例，它是基于ZooKeeper客户端和服务端的长连接和会话超时控制机制，来实现服务健康状态检测的。</li></ul><blockquote><p>在ZooKeeper中，客户端和服务端建立连接后，会话也随之建立，并生成一个全局唯一的Session ID。服务端和客户端维持的是一个长连接，在SESSION_TIMEOUT周期内，服务端会检测与客户端的链路是否正常，具体方式是通过客户端定时向服务端发送心跳消息（ping消息），服务器重置下次SESSION_TIMEOUT时间。如果超过SESSION_TIMEOUT后服务端都没有收到客户端的心跳消息，则服务端认为这个Session就已经结束了，ZooKeeper就会认为这个服务节点已经不可用，将会从注册中心中删除其信息。</p></blockquote><h4 id="5-服务状态变更通知"><a href="#5-服务状态变更通知" class="headerlink" title="5. 服务状态变更通知"></a><strong>5. 服务状态变更通知</strong></h4><ul><li>一旦注册中心探测到有服务提供者节点新加入或者被剔除，就必须立刻通知所有订阅该服务的服务消费者，刷新本地缓存的服务节点信息，确保服务调用不会请求不可用的服务提供者节点。</li></ul><blockquote><p>以ZooKeeper为例，基于ZooKeeper的Watcher机制，来实现服务状态变更通知给服务消费者的。服务消费者在调用ZooKeeper的getData方法订阅服务时，还可以通过监听器Watcher的process方法获取服务的变更，然后调用getData方法来获取变更后的数据，刷新本地缓存的服务节点信息。</p></blockquote><h4 id="6-白名单机制"><a href="#6-白名单机制" class="headerlink" title="6. 白名单机制"></a><strong>6. 白名单机制</strong></h4><ul><li>注册中心需要提供一个保护机制，你可以把注册中心想象成一个带有门禁的房间，只有拥有门禁卡的RPC Server才能进入。在实际应用中，注册中心可以提供一个白名单机制，只有添加到注册中心白名单内的RPC Server，才能够调用注册中心的注册接口，这样的话可以避免测试环境中的节点意外跑到线上环境中去。</li></ul><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><ul><li>注册中心是实现微服务的关键</li><li>服务化之后，服务提供者和服务消费者不在同一个进程中运行，实现了解耦，这就需要一个纽带去连接服务提供者和服务消费者，而注册中心就正好承担了这一角色。</li><li>服务提供者可以任意伸缩即增加节点或者减少节点，通过服务健康状态检测，注册中心可以保持最新的服务节点信息，并将变化通知给订阅服务的服务消费者</li><li>注册中心一般采用分布式集群部署，来保证高可用性，并且为了实现异地多活，有的注册中心还采用多IDC部署，这就对数据一致性产生了很高的要求，这些都是注册中心在实现时必须要解决的问题。</li></ul><br><br><br><h2 id="06-如何实现RPC远程服务调用？"><a href="#06-如何实现RPC远程服务调用？" class="headerlink" title="06 | 如何实现RPC远程服务调用？"></a>06 | 如何实现RPC远程服务调用？</h2><h3 id="客户端和服务端如何建立网络连接？"><a href="#客户端和服务端如何建立网络连接？" class="headerlink" title="客户端和服务端如何建立网络连接？"></a>客户端和服务端如何建立网络连接？</h3><ul><li>客户端和服务端之间基于TCP协议建立网络连接最常用的途径有两种</li></ul><h4 id="1-HTTP通信"><a href="#1-HTTP通信" class="headerlink" title="1. HTTP通信"></a><strong>1. HTTP通信</strong></h4><ul><li>HTTP通信是基于应用层HTTP协议的，而HTTP协议又是基于传输层TCP协议的。</li><li>一次HTTP通信过程就是发起一次HTTP调用，而一次HTTP调用就会建立一个TCP连接，经历一次的“<a class="link"   href="http://condor.depaul.edu/jkristof/technotes/tcp.html" >三次握手<i class="fas fa-external-link-alt"></i></a>”的过程来建立连接。</li><li>完成请求后，再经历一次“四次挥手”的过程来断开连接。</li></ul><h4 id="2-Socket通信"><a href="#2-Socket通信" class="headerlink" title="2. Socket通信"></a><strong>2. Socket通信</strong></h4><ul><li>Socket通信是基于TCP/IP协议的封装，建立一次Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ；另一个运行于服务器端，称为ServerSocket 。</li><li>Socket通信的过程分为四个步骤：服务器监听、客户端请求、连接确认、数据传输。<ul><li>服务器监听：ServerSocket通过调用bind()函数绑定某个具体端口，然后调用listen()函数实时监控网络状态，等待客户端的连接请求。</li><li>客户端请求：ClientSocket调用connect()函数向ServerSocket绑定的地址和端口发起连接请求。</li><li>服务端连接确认：当ServerSocket监听到或者接收到ClientSocket的连接请求时，调用accept()函数响应ClientSocket的请求，同客户端建立连接。</li><li>数据传输：当ClientSocket和ServerSocket建立连接后，ClientSocket调用send()函数，ServerSocket调用receive()函数，ServerSocket处理完请求后，调用send()函数，ClientSocket调用receive()函数，就可以得到得到返回结果。</li></ul></li><li>当客户端和服务端建立网络连接后，就可以发起请求了。但网络不一定总是可靠的，经常会遇到网络闪断、连接超时、服务端宕机等各种异常，通常的处理手段有两种。<ul><li>链路存活检测：客户端需要定时地发送心跳检测消息（一般是通过ping请求）给服务端，如果服务端连续n次心跳检测或者超过规定的时间都没有回复消息，则认为此时链路已经失效，这个时候客户端就需要重新与服务端建立连接。</li><li>断连重试：通常有多种情况会导致连接断开，比如客户端主动关闭、服务端宕机或者网络故障等。这个时候客户端就需要与服务端重新建立连接，但一般不能立刻完成重连，而是要等待固定的间隔后再发起重连，避免服务端的连接回收不及时，而客户端瞬间重连的请求太多而把服务端的连接数占满。</li></ul></li></ul><h3 id="服务端如何处理请求？"><a href="#服务端如何处理请求？" class="headerlink" title="服务端如何处理请求？"></a>服务端如何处理请求？</h3><ul><li><strong>同步阻塞方式（BIO）</strong>：客户端每发一次请求，服务端就生成一个线程去处理。当客户端同时发起的请求很多时，服务端需要创建很多的线程去处理每一个请求，如果达到了系统最大的线程数瓶颈，新来的请求就没法处理了。</li><li>**同步非阻塞方式 (NIO)**：客户端每发一次请求，服务端并不是每次都创建一个新线程来处理，而是通过I/O多路复用技术进行处理。就是把多个I/O的阻塞复用到同一个select的阻塞上，从而使系统在单线程的情况下可以同时处理多个客户端请求。这种方式的优势是开销小，不用为每个请求创建一个线程，可以节省系统开销。</li><li><strong>异步非阻塞方式（AIO）</strong>：客户端只需要发起一个I/O操作然后立即返回，等I/O操作真正完成以后，客户端会得到I/O操作完成的通知，此时客户端只需要对数据进行处理就好了，不需要进行实际的I/O读写操作，因为真正的I/O读取或者写入操作已经由内核完成了。这种方式的优势是客户端无需等待，不存在阻塞等待问题。</li></ul><ul><li>BIO适用于连接数比较小的业务场景，这样的话不至于系统中没有可用线程去处理请求。这种方式写的程序也比较简单直观，易于理解。</li><li>NIO适用于连接数比较多并且请求消耗比较轻的业务场景，比如聊天服务器。这种方式相比BIO，相对来说编程比较复杂。</li><li>AIO适用于连接数比较多而且请求消耗比较重的业务场景，比如涉及I/O操作的相册服务器。这种方式相比另外两种，编程难度最大，程序也不易于理解。</li></ul><ul><li><strong>建议最为稳妥的方式是使用成熟的开源方案</strong>，比如Netty、MINA等</li></ul><h3 id="数据传输采用什么协议？"><a href="#数据传输采用什么协议？" class="headerlink" title="数据传输采用什么协议？"></a>数据传输采用什么协议？</h3><ul><li>HTTP协议</li><li>Dubbo协议</li></ul><h3 id="数据该如何序列化和反序列化？"><a href="#数据该如何序列化和反序列化？" class="headerlink" title="数据该如何序列化和反序列化？"></a>数据该如何序列化和反序列化？</h3><ul><li><p>一般数据在网络中进行传输前，都要先在发送方一端对数据进行编码，经过网络传输到达另一端后，再对数据进行解码，这个过程就是序列化和反序列化。</p></li><li><p>为什么要对数据进行序列化和反序列化呢？</p><ul><li>网络传输的耗时一方面取决于网络带宽的大小，另一方面取决于数据传输量。要想加快网络传输，要么提高带宽，要么减小数据传输量，而对数据进行编码的主要目的就是减小数据传输量。</li></ul></li><li><p>常用的序列化方式分为两类：文本类如XML/JSON等，二进制类如PB/Thrift等，而具体采用哪种序列化方式，主要取决于三个方面的因素。</p><ul><li>支持数据结构类型的丰富度。数据结构种类支持的越多越好，这样的话对于使用者来说在编程时更加友好，有些序列化框架如Hessian 2.0还支持复杂的数据结构比如Map、List等。</li><li>跨语言支持。序列化方式是否支持跨语言也是一个很重要的因素，否则使用的场景就比较局限，比如Java序列化只支持Java语言，就不能用于跨语言的服务调用了。</li><li>性能。主要看两点，一个是序列化后的压缩比，一个是序列化的速度。以常用的PB序列化和JSON序列化协议为例来对比分析，PB序列化的压缩比和速度都要比JSON序列化高很多，所以对性能和存储空间要求比较高的系统选用PB序列化更合适；而JSON序列化虽然性能要差一些，但可读性更好，更适合对外部提供服务。</li></ul></li></ul><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><ul><li><strong>通信框架</strong>。它主要解决客户端和服务端如何建立连接、管理连接以及服务端如何处理请求的问题。</li><li><strong>通信协议</strong>。它主要解决客户端和服务端采用哪种数据传输协议的问题。</li><li><strong>序列化和反序列化</strong>。它主要解决客户端和服务端采用哪种数据编解码的问题。</li></ul><blockquote><p>这三个部分就组成了一个完整的RPC调用框架，通信框架提供了基础的通信能力，通信协议描述了通信契约，而序列化和反序列化则用于数据的编/解码。一个通信框架可以适配多种通信协议，也可以采用多种序列化和反序列化的格式，比如服务化框架Dubbo不仅支持Dubbo协议，还支持RMI协议、HTTP协议等，而且还支持多种序列化和反序列化格式，比如JSON、Hession 2.0以及Java序列化等。</p></blockquote><br><br><br><h2 id="07-如何监控微服务调用？"><a href="#07-如何监控微服务调用？" class="headerlink" title="07 | 如何监控微服务调用？"></a>07 | 如何监控微服务调用？</h2><ul><li>讲述如何监控微服务调用前，首先你要搞清楚三个问题<ul><li>监控的对象是什么？</li><li>具体监控哪些指标？</li><li>从哪些维度进行监控？</li></ul></li></ul><h3 id="监控对象"><a href="#监控对象" class="headerlink" title="监控对象"></a>监控对象</h3><ul><li>对于微服务系统来说，监控对象可以分为四个层次，由上到下可归纳为：<ul><li>用户端监控。通常是指业务直接对用户提供的功能的监控。以微博首页Feed为例，它向用户提供了聚合关注的所有人的微博并按照时间顺序浏览的功能，对首页Feed功能的监控就属于用户端的监控。</li><li>接口监控。通常是指业务提供的功能所依赖的具体RPC接口的监控。继续以微博首页Feed为例，这个功能依赖于用户关注了哪些人的关系服务，每个人发过哪些微博的微博列表服务，以及每条微博具体内容是什么的内容服务，对这几个服务的调用情况的监控就属于接口监控。</li><li>资源监控。通常是指某个接口依赖的资源的监控。比如用户关注了哪些人的关系服务使用的是Redis来存储关注列表，对Redis的监控就属于资源监控。</li><li>基础监控。通常是指对服务器本身的健康状况的监控。主要包括CPU利用率、内存使用量、I/O读写量、网卡带宽等。对服务器的基本监控也是必不可少的，因为服务器本身的健康状况也是影响服务本身的一个重要因素，比如服务器本身连接的网络交换机上联带宽被打满，会影响所有部署在这台服务器上的业务。</li></ul></li></ul><h3 id="监控指标"><a href="#监控指标" class="headerlink" title="监控指标"></a>监控指标</h3><ul><li>通常有以下几个业务指标需要重点监控：<ul><li>请求量。请求量监控分为两个维度，一个是实时请求量，一个是统计请求量。<ul><li>实时请求量用QPS（Queries Per Second）即每秒查询次数来衡量，它反映了服务调用的实时变化情况。</li><li>统计请求量一般用PV（Page View）即一段时间内用户的访问量来衡量，比如一天的PV代表了服务一天的请求量，通常用来统计报表。</li></ul></li><li>响应时间。大多数情况下，可以用一段时间内所有调用的平均耗时来反映请求的响应时间。但它只代表了请求的平均快慢情况，有时候我们更关心慢请求的数量。</li><li>错误率。错误率的监控通常用一段时间内调用失败的次数占调用总次数的比率来衡量，</li></ul></li></ul><h3 id="监控维度"><a href="#监控维度" class="headerlink" title="监控维度"></a>监控维度</h3><ul><li>一般来说，要从多个维度来对业务进行监控，具体来讲可以包括下面几个维度：<ul><li>全局维度。从整体角度监控对象的的请求量、平均耗时以及错误率，全局维度的监控一般是为了让你对监控对象的调用情况有个整体了解。</li><li>分机房维度。一般为了业务的高可用性，服务通常部署在不止一个机房，因为不同机房地域的不同，同一个监控对象的各种指标可能会相差很大，所以需要深入到机房内部去了解。</li><li>单机维度。即便是在同一个机房内部，可能由于采购年份和批次的不同，位于不同机器上的同一个监控对象的各种指标也会有很大差异。一般来说，新采购的机器通常由于成本更低，配置也更高，在同等请求量的情况下，可能表现出较大的性能差异，因此也需要从单机维度去监控同一个对象。</li><li>时间维度。同一个监控对象，在每天的同一时刻各种指标通常也不会一样，这种差异要么是由业务变更导致，要么是运营活动导致。为了了解监控对象各种指标的变化，通常需要与一天前、一周前、一个月前，甚至三个月前做比较。</li><li>核心维度。根据我的经验，业务上一般会依据重要性程度对监控对象进行分级，最简单的是分成核心业务和非核心业务。核心业务和非核心业务在部署上必须隔离，分开监控，这样才能对核心业务做重点保障。</li></ul></li></ul><ul><li><strong>对于一个微服务来说，你必须明确要监控哪些对象、哪些指标，并且还要从不同的维度进行监控，才能掌握微服务的调用情况</strong></li></ul><h3 id="监控系统原理"><a href="#监控系统原理" class="headerlink" title="监控系统原理"></a>监控系统原理</h3><ul><li><strong>监控系统主要包括四个环节：数据采集、数据传输、数据处理和数据展示</strong></li></ul><h4 id="1-数据采集"><a href="#1-数据采集" class="headerlink" title="1. 数据采集"></a><strong>1. 数据采集</strong></h4><ul><li>通常有两种数据收集方式：<ul><li>服务主动上报，这种处理方式通过在业务代码或者服务框架里加入数据收集代码逻辑，在每一次服务调用完成后，主动上报服务的调用信息。</li><li>代理收集，这种处理方式通过服务调用后把调用的详细信息记录到本地日志文件中，然后再通过代理去解析本地日志文件，然后再上报服务的调用信息。</li></ul></li></ul><blockquote><p>无论哪种数据采集方式，首先要考虑的问题就是采样率，也就是采集数据的频率。采样率决定了监控的实时性与精确度，一般来说，采样率越高，监控的实时性就越高，精确度也越高。但采样对系统本身的性能也会有一定的影响，尤其是采集后的数据需要写到本地磁盘的时候，过高的采样率会导致系统写入磁盘的I/O过高，进而会影响到正常的服务调用。所以设置合理的采用率是数据采集的关键，最好是可以动态控制采样率，在系统比较空闲的时候加大采样率，追求监控的实时性与精确度；在系统负载比较高的时候减小采样率，追求监控的可用性与系统的稳定性。</p></blockquote><h4 id="2-数据传输"><a href="#2-数据传输" class="headerlink" title="2. 数据传输"></a><strong>2. 数据传输</strong></h4><ul><li><p>数据传输最常用的方式有两种：</p><ul><li>UDP传输，这种处理方式是数据处理单元提供服务器的请求地址，数据采集后通过UDP协议与服务器建立连接，然后把数据发送过去。</li><li>Kafka传输，这种处理方式是数据采集后发送到指定的Topic，然后数据处理单元再订阅对应的Topic，就可以从Kafka消息队列中读取到对应的数据。</li></ul></li><li><p>无论采用哪种传输方式，数据格式都十分重要，尤其是对带宽敏感以及解析性能要求比较高的场景，一般数据传输时采用的数据格式有两种：</p><ul><li>二进制协议，最常用的就是PB对象，它的优点是高压缩比和高性能，可以减少传输带宽并且序列化和反序列化效率特别高。</li><li>文本协议，最常用的就是JSON字符串，它的优点是可读性好，但相比于PB对象，传输占用带宽高，并且解析性能也要差一些。</li></ul></li></ul><h4 id="3-数据处理"><a href="#3-数据处理" class="headerlink" title="3. 数据处理"></a><strong>3. 数据处理</strong></h4><ul><li><p>数据处理是对收集来的原始数据进行聚合并存储。数据聚合通常有两个维度：</p><ul><li>接口维度聚合，这个维度是把实时收到的数据按照接口名维度实时聚合在一起，这样就可以得到每个接口的实时请求量、平均耗时等信息。</li><li>机器维度聚合，这个维度是把实时收到的数据按照调用的节点维度聚合在一起，这样就可以从单机维度去查看每个接口的实时请求量、平均耗时等信息。</li></ul></li><li><p>聚合后的数据需要持久化到数据库中存储，所选用的数据库一般分为两种：</p><ul><li>索引数据库，比如Elasticsearch，以倒排索引的数据结构存储，需要查询的时候，根据索引来查询。</li><li>时序数据库，比如OpenTSDB，以时序序列数据的方式存储，查询的时候按照时序如1min、5min等维度来查询。</li></ul></li></ul><h4 id="4-数据展示"><a href="#4-数据展示" class="headerlink" title="4. 数据展示"></a><strong>4. 数据展示</strong></h4><ul><li>数据展示是把处理后的数据以Dashboard的方式展示给用户。数据展示有多种方式，比如曲线图、饼状图、格子图展示等<ul><li>曲线图。一般是用来监控变化趋势的</li><li>饼状图。一般是用来监控占比分布的</li><li>格子图。主要做一些细粒度的监控，</li></ul></li></ul><h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><blockquote><p>服务监控在微服务改造过程中的重要性不言而喻，没有强大的监控能力，改造成微服务架构后，就无法掌控各个不同服务的情况，在遇到调用失败时，如果不能快速发现系统的问题，对于业务来说就是一场灾难。</p><p>搭建一个服务监控系统，涉及数据采集、数据传输、数据处理、数据展示等多个环节，每个环节都需要根据自己的业务特点选择合适的解决方案</p></blockquote><br><br><br><h2 id="08-如何追踪微服务调用？"><a href="#08-如何追踪微服务调用？" class="headerlink" title="08 | 如何追踪微服务调用？"></a>08 | 如何追踪微服务调用？</h2><ul><li>如果有一个系统，可以跟踪记录一次用户请求都发起了哪些调用，经过哪些服务处理，并且记录每一次调用所涉及的服务的详细信息，这时候如果发生调用失败，你就可以通过这个日志快速定位是在哪个环节出了问题，这个系统就是今天我要讲解的服务追踪系统</li></ul><h3 id="服务追踪的作用"><a href="#服务追踪的作用" class="headerlink" title="服务追踪的作用"></a>服务追踪的作用</h3><h4 id="第一，优化系统瓶颈。"><a href="#第一，优化系统瓶颈。" class="headerlink" title="第一，优化系统瓶颈。"></a><strong>第一，优化系统瓶颈。</strong></h4><ul><li>通过记录调用经过的每一条链路上的耗时，我们能快速定位整个系统的瓶颈点在哪里</li></ul><h4 id="第二，优化链路调用"><a href="#第二，优化链路调用" class="headerlink" title="第二，优化链路调用"></a><strong>第二，优化链路调用</strong></h4><ul><li>通过服务追踪可以分析调用所经过的路径，然后评估是否合理</li></ul><h4 id="第三，生成网络拓扑"><a href="#第三，生成网络拓扑" class="headerlink" title="第三，生成网络拓扑"></a><strong>第三，生成网络拓扑</strong></h4><ul><li>通过服务追踪系统中记录的链路信息，可以生成一张系统的网络调用拓扑图，它可以反映系统都依赖了哪些服务，以及服务之间的调用关系是什么样的，可以一目了然。除此之外，在网络拓扑图上还可以把服务调用的详细信息也标出来，也能起到服务监控的作用。</li></ul><h4 id="第四，透明传输数据"><a href="#第四，透明传输数据" class="headerlink" title="第四，透明传输数据"></a><strong>第四，透明传输数据</strong></h4><ul><li>除了服务追踪，业务上经常有一种需求，期望能把一些用户数据，从调用的开始一直往下传递，以便系统中的各个服务都能获取到这个信息</li></ul><h3 id="服务追踪系统原理"><a href="#服务追踪系统原理" class="headerlink" title="服务追踪系统原理"></a>服务追踪系统原理</h3><ul><li><p>服务追踪系统的实现原理核心理念就是<strong>调用链</strong>：通过一个全局唯一的ID将分布在各个服务节点上的同一次请求串联起来，从而还原原有的调用关系，可以追踪系统问题、分析调用数据并统计各种系统指标</p></li><li><p>后面的诞生各种服务追踪系统都是基于Dapper衍生出来的，比较有名的有Twitter的Zipkin、阿里的鹰眼、美团的MTrace等。</p></li><li><p>要理解服务追踪的原理，首先必须搞懂一些基本概念：traceId、spanId、annonation等</p></li><li><p>以MTrace为例</p><ul><li>traceId，用于标识某一次具体的请求ID。当用户的请求进入系统后，会在RPC调用网络的第一层生成一个全局唯一的traceId，并且会随着每一层的RPC调用，不断往后传递，这样的话通过traceId就可以把一次用户请求在系统中调用的路径串联起来。</li><li>spanId，用于标识一次RPC调用在分布式请求中的位置。当用户的请求进入系统后，处在RPC调用网络的第一层A时spanId初始值是0，进入下一层RPC调用B的时候spanId是0.1，继续进入下一层RPC调用C时spanId是0.1.1，而与B处在同一层的RPC调用E的spanId是0.2，这样的话通过spanId就可以定位某一次RPC请求在系统调用中所处的位置，以及它的上下游依赖分别是谁。</li><li>annotation，用于业务自定义埋点数据，可以是业务感兴趣的想上传到后端的数据，比如一次请求的用户UID。</li></ul></li></ul><h3 id="服务追踪系统实现"><a href="#服务追踪系统实现" class="headerlink" title="服务追踪系统实现"></a>服务追踪系统实现</h3><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.2ze7ekpge800.webp" width="70%"><br><ul><li>数据采集层，负责数据埋点并上报。</li><li>数据处理层，负责数据的存储与计算。</li><li>数据展示层，负责数据的图形化展示。</li></ul><br><br><br><h2 id="09-微服务治理的手段有哪些？"><a href="#09-微服务治理的手段有哪些？" class="headerlink" title="09 | 微服务治理的手段有哪些？"></a>09 | 微服务治理的手段有哪些？</h2><ul><li>一次服务调用，服务提供者、注册中心、网络这三者都可能会有问题，此时服务消费者应该如何处理才能确保调用成功呢？这就是服务治理要解决的问题。</li></ul><h3 id="节点管理"><a href="#节点管理" class="headerlink" title="节点管理"></a>节点管理</h3><ul><li><p>服务调用失败一般是由两类原因引起的</p><ul><li>一类是服务提供者自身出现问题，如服务器宕机、进程意外退出等</li><li>一类是网络问题，如服务提供者、注册中心、服务消费者这三者任意两者之间的网络出现问题</li></ul></li><li><p>有两种节点管理手段</p><ul><li><strong>1. 注册中心主动摘除机制</strong><ul><li>这种机制要求服务提供者定时的主动向注册中心汇报心跳，注册中心根据服务提供者节点最近一次汇报心跳的时间与上一次汇报心跳时间做比较，如果超出一定时间，就认为服务提供者出现问题，继而把节点从服务列表中摘除，并把最近的可用服务节点列表推送给服务消费者。</li></ul></li><li><strong>2. 服务消费者摘除机制</strong><ul><li>将存活探测机制用在服务消费者这一端更合理，如果服务消费者调用服务提供者节点失败，就将这个节点从内存中保存的可用服务提供者节点列表中移除</li></ul></li></ul></li></ul><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul><li>常用的负载均衡算法如下</li></ul><h4 id="1-随机算法"><a href="#1-随机算法" class="headerlink" title="1. 随机算法"></a><strong>1. 随机算法</strong></h4><ul><li>从可用的服务节点中随机选取一个节点。般情况下，随机算法是均匀的，也就是说后端服务节点无论配置好坏，最终得到的调用量都差不多。</li></ul><h4 id="2-轮询算法"><a href="#2-轮询算法" class="headerlink" title="2. 轮询算法"></a><strong>2. 轮询算法</strong></h4><ul><li>按照固定的权重，对可用服务节点进行轮询。如果所有服务节点的权重都是相同的，则每个节点的调用量也是差不多的。但可以给某些硬件配置较好的节点的权重调大些，这样的话就会得到更大的调用量，从而充分发挥其性能优势，提高整体调用的平均性能</li></ul><h4 id="3-最少活跃调用算法"><a href="#3-最少活跃调用算法" class="headerlink" title="3. 最少活跃调用算法"></a><strong>3. 最少活跃调用算法</strong></h4><ul><li>这种算法是在服务消费者这一端的内存里动态维护着同每一个服务节点之间的连接数，当调用某个服务节点时，就给与这个服务节点之间的连接数加1，调用返回后，就给连接数减1。然后每次在选择服务节点时，根据内存里维护的连接数倒序排列，选择连接数最小的节点发起调用，也就是选择了调用量最小的服务节点，性能理论上也是最优的。</li></ul><h4 id="4-一致性Hash算法"><a href="#4-一致性Hash算法" class="headerlink" title="4. 一致性Hash算法"></a><strong>4. 一致性Hash算法</strong></h4><ul><li>相同参数的请求总是发到同一服务节点。当某一个服务节点出现故障时，原本发往该节点的请求，基于虚拟节点机制，平摊到其他节点上，不会引起剧烈变动</li></ul><blockquote><p>这几种算法的实现难度也是逐步提升的，所以选择哪种节点选取的负载均衡算法要根据实际场景而定。如果后端服务节点的配置没有差异，同等调用量下性能也没有差异的话，选择随机或者轮询算法比较合适；如果后端服务节点存在比较明显的配置和性能差异，选择最少活跃调用算法比较合适。</p></blockquote><h3 id="服务路由"><a href="#服务路由" class="headerlink" title="服务路由"></a>服务路由</h3><ul><li>对于服务消费者而言，在内存中的可用服务节点列表中选择哪个节点不仅由负载均衡算法决定，还由路由规则确定</li></ul><h4 id="为什么要制定路由规则呢？"><a href="#为什么要制定路由规则呢？" class="headerlink" title="为什么要制定路由规则呢？"></a>为什么要制定路由规则呢？</h4><ul><li><strong>1. 业务存在灰度发布的需求</strong></li><li><strong>2. 多机房就近访问的需求</strong></li></ul><h4 id="路由规则该如何配置"><a href="#路由规则该如何配置" class="headerlink" title="路由规则该如何配置"></a>路由规则该如何配置</h4><ul><li><strong>1. 静态配置</strong></li><li><strong>2. 动态配置</strong></li></ul><h3 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h3><ul><li>FailOver：失败自动切换</li><li>FailBack：失败通知</li><li>FailCache：失败缓存</li><li>FailFast：快速失败</li></ul><br><br><br><h2 id="10-Dubbo框架里的微服务组件"><a href="#10-Dubbo框架里的微服务组件" class="headerlink" title="10 | Dubbo框架里的微服务组件"></a>10 | Dubbo框架里的微服务组件</h2><h3 id="服务发布与引用"><a href="#服务发布与引用" class="headerlink" title="服务发布与引用"></a>服务发布与引用</h3><br><br><br><h1 id="模块二-落地微服务-14讲"><a href="#模块二-落地微服务-14讲" class="headerlink" title="模块二 落地微服务 (14讲)"></a>模块二 落地微服务 (14讲)</h1><h2 id="11-服务发布和引用的实践"><a href="#11-服务发布和引用的实践" class="headerlink" title="11 | 服务发布和引用的实践"></a>11 | 服务发布和引用的实践</h2><br><br><br><h2 id="12-如何将注册中心落地？"><a href="#12-如何将注册中心落地？" class="headerlink" title="12 | 如何将注册中心落地？"></a>12 | 如何将注册中心落地？</h2><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><p>1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;br&gt;

&lt;br&gt;

&lt;br&gt;

&lt;h1 id=&quot;模块一-入门微服务-10讲&quot;&gt;&lt;a href=&quot;#模块一-入门微服务-10讲&quot; class=&quot;headerlink&quot; title=&quot;模块一 入门微服务 (10讲)&quot;&gt;&lt;/a&gt;模块一 入门微服务 (10讲)&lt;/h1&gt;&lt;h2 id=</summary>
      
    
    
    
    <category term="microservice" scheme="https://ratears.github.io/dev.ratears.life/Categories/microservice/"/>
    
    
    <category term="microservice" scheme="https://ratears.github.io/dev.ratears.life/Tags/microservice/"/>
    
  </entry>
  
  <entry>
    <title>《构建JVM知识体系 解决Java工程师必会的工作/面试难点》Study Notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/%E3%80%8A%E6%9E%84%E5%BB%BAJVM%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB-%E8%A7%A3%E5%86%B3Java%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%BF%85%E4%BC%9A%E7%9A%84%E5%B7%A5%E4%BD%9C-%E9%9D%A2%E8%AF%95%E9%9A%BE%E7%82%B9%E3%80%8BStudy-Notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/%E3%80%8A%E6%9E%84%E5%BB%BAJVM%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB-%E8%A7%A3%E5%86%B3Java%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%BF%85%E4%BC%9A%E7%9A%84%E5%B7%A5%E4%BD%9C-%E9%9D%A2%E8%AF%95%E9%9A%BE%E7%82%B9%E3%80%8BStudy-Notes/</id>
    <published>2023-04-23T09:28:58.000Z</published>
    <updated>2023-04-23T09:28:58.000Z</updated>
    
    <content type="html"><![CDATA[<br><h1 id="第1章-课程导学与准备工作"><a href="#第1章-课程导学与准备工作" class="headerlink" title="第1章 课程导学与准备工作"></a>第1章 课程导学与准备工作</h1><h2 id="JVM是什么"><a href="#JVM是什么" class="headerlink" title="JVM是什么"></a>JVM是什么</h2><ul><li>Java Virtual Machine</li><li>Java程序的运行环境</li><li>Java最核心的基础</li><li>Java开发必备技能</li></ul><br><h2 id="为什么要学JVM"><a href="#为什么要学JVM" class="headerlink" title="为什么要学JVM"></a>为什么要学JVM</h2><ul><li>面试需要</li><li>深入理解Java</li><li>排查解决故障</li><li>性能调优</li></ul><br><h2 id="学习收获"><a href="#学习收获" class="headerlink" title="学习收获"></a>学习收获</h2><ul><li>快速系统深入掌握JVM</li><li>面试中JVM相关问题通通变成加分项</li><li>应用JVM进行问题排查解决</li><li>应用JVM对应用调优</li><li>得到老师多年经验心得</li></ul><br><br><br><h1 id="第2章-认识JVM规范"><a href="#第2章-认识JVM规范" class="headerlink" title="第2章 认识JVM规范"></a>第2章 认识JVM规范</h1><h2 id="JVM概述"><a href="#JVM概述" class="headerlink" title="JVM概述"></a>JVM概述</h2><ul><li>JVM:Java Virtual Machine，也就是Java虚拟机</li><li>所谓虚拟机是指:通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的计算机系统</li><li>JVM是通过软件来模拟Java 字节码的指令集，是Java程序的运行环境</li></ul><h2 id="JVM主要功能"><a href="#JVM主要功能" class="headerlink" title="JVM主要功能"></a>JVM主要功能</h2><ol><li>通过ClassLoader 寻找和装载class文件</li><li>解释字节码成为指令并执行，提供class文件的运行环境</li><li>进行运行期间的内存分配和垃圾回收</li><li>提供与硬件交互的平台</li></ol><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.57uivl6zm6g0.webp" width="70%"><br><h2 id="虚拟机是Java平台无关的保障"><a href="#虚拟机是Java平台无关的保障" class="headerlink" title="虚拟机是Java平台无关的保障"></a>虚拟机是Java平台无关的保障</h2><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.jf0g8nuvlts.webp" width="70%"><br><h2 id="JVM规范"><a href="#JVM规范" class="headerlink" title="JVM规范"></a>JVM规范</h2><h3 id="JVM规范作用"><a href="#JVM规范作用" class="headerlink" title="JVM规范作用"></a>JVM规范作用</h3><ul><li>Java 虚拟机规范为不同的硬件平台提供了一种编译Java技术代码的规范</li><li>该规范使Java 软件独立于平台，因为编译是针对作为虚拟机的“一般机器”而做</li><li>这个“一般机器”可用软件模拟并运行于各种现存的计算机系统，也可用硬件来实现</li></ul><h3 id="JVM规范定义的主要内容"><a href="#JVM规范定义的主要内容" class="headerlink" title="JVM规范定义的主要内容"></a>JVM规范定义的主要内容</h3><ul><li>字节码指令集(相当于中央处理器CPU )</li><li>Class文件的格式</li><li>数据类型和值</li><li>运行时数据区</li><li>栈帧</li><li>特殊方法</li><li>类库</li><li>异常</li><li>虚拟机的启动、加载、链接和初始化</li></ul><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><p>1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;br&gt;

&lt;h1 id=&quot;第1章-课程导学与准备工作&quot;&gt;&lt;a href=&quot;#第1章-课程导学与准备工作&quot; class=&quot;headerlink&quot; title=&quot;第1章 课程导学与准备工作&quot;&gt;&lt;/a&gt;第1章 课程导学与准备工作&lt;/h1&gt;&lt;h2 id=&quot;JVM是什么&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="Java" scheme="https://ratears.github.io/dev.ratears.life/Categories/Java/"/>
    
    <category term="JVM" scheme="https://ratears.github.io/dev.ratears.life/Categories/Java/JVM/"/>
    
    
    <category term="JVM" scheme="https://ratears.github.io/dev.ratears.life/Tags/JVM/"/>
    
    <category term="Java" scheme="https://ratears.github.io/dev.ratears.life/Tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>《深度解密Java并发工具，精通JUC，成为并发多面手》Study Notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/%E3%80%8A%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%AF%86Java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%EF%BC%8C%E7%B2%BE%E9%80%9AJUC%EF%BC%8C%E6%88%90%E4%B8%BA%E5%B9%B6%E5%8F%91%E5%A4%9A%E9%9D%A2%E6%89%8B%E3%80%8BStudy-Notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/%E3%80%8A%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%AF%86Java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%EF%BC%8C%E7%B2%BE%E9%80%9AJUC%EF%BC%8C%E6%88%90%E4%B8%BA%E5%B9%B6%E5%8F%91%E5%A4%9A%E9%9D%A2%E6%89%8B%E3%80%8BStudy-Notes/</id>
    <published>2023-04-21T15:25:33.000Z</published>
    <updated>2023-04-21T15:25:33.000Z</updated>
    
    <content type="html"><![CDATA[<br><h1 id="第1章-开宗明义"><a href="#第1章-开宗明义" class="headerlink" title="第1章 开宗明义"></a>第1章 开宗明义</h1><h2 id="为什么要学习并发编程"><a href="#为什么要学习并发编程" class="headerlink" title="为什么要学习并发编程"></a>为什么要学习并发编程</h2><ol><li>招聘jd要求</li><li>面试常客</li><li>通往大牛必须掌握的内容</li><li>并发是众多框架的核心</li><li>J.U.C是Doug Lea 的灵魂力作，非常优秀经典</li></ol><br><br><br><h1 id="第2章-鸟瞰Java并发【上帝视角建立并发知识框架】"><a href="#第2章-鸟瞰Java并发【上帝视角建立并发知识框架】" class="headerlink" title="第2章 鸟瞰Java并发【上帝视角建立并发知识框架】"></a>第2章 鸟瞰Java并发【上帝视角建立并发知识框架】</h1><h2 id="并发工具分类"><a href="#并发工具分类" class="headerlink" title="并发工具分类"></a>并发工具分类</h2><ol><li>为了并发安全 : 互斥同步、非互斥同步、无同步方案<ol><li>为了线程安全（从底层原理来分）</li><li>为了线程安全（从使用者的角度来分类）</li><li>为了方便线程管理、提高效率</li><li>为了线程之间配合，来满足业务逻辑</li></ol></li><li>管理线程、提高效率</li><li>线程协作</li></ol><br><br><br><h1 id="第3章-线程池【治理线程的最大法宝】"><a href="#第3章-线程池【治理线程的最大法宝】" class="headerlink" title="第3章 线程池【治理线程的最大法宝】"></a>第3章 线程池【治理线程的最大法宝】</h1><h2 id="线程池介绍"><a href="#线程池介绍" class="headerlink" title="线程池介绍"></a>线程池介绍</h2><h3 id="线程池的重要性"><a href="#线程池的重要性" class="headerlink" title="线程池的重要性"></a>线程池的重要性</h3><ol><li>很多问题是没有用好线程池导致的</li><li>线程池是面试高频考点</li></ol><h3 id="为什么要使用线程"><a href="#为什么要使用线程" class="headerlink" title="为什么要使用线程"></a>为什么要使用线程</h3><ul><li><p>如果不使用线程池，每个任务都新开一个线程处理</p><ul><li><strong>Java中的线程会对应到操作系统的线程</strong></li><li><strong>线程的生命周期内存开销是很高的</strong></li><li>会导致两个问题：<ul><li>反复创建线程开销大</li><li>过多的线程会占用太多内存</li></ul></li></ul></li><li><p>但是，这样开销太大，而我们希望有固定数量的线程，来执行这N个线程，这样就避免了反复创建并销毁线程所带来的开销问题</p></li><li><p>解决上面两个问题的思路：</p><ul><li>用少量的线程一避免内存占用过多</li><li>让这部分线程都保持工作，且可以反复执行任务避免生命周期的损耗</li></ul></li></ul><h3 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h3><ul><li>加快响应速度</li><li>合理利用CPU和内存</li><li>统一管理、统计</li></ul><h3 id="线程池适合应用的场合"><a href="#线程池适合应用的场合" class="headerlink" title="线程池适合应用的场合"></a>线程池适合应用的场合</h3><ul><li>服务器接受到大量请求时，使用线程池技术是非常合适的，它可以大大减少线程的创建和销毁次数，提高服务器的工作效率</li><li>实际上，在开发中，如果需要创建5个以上的线程，那么就可以使用线程池来管理</li></ul><h2 id="线程池的创建与停止"><a href="#线程池的创建与停止" class="headerlink" title="线程池的创建与停止"></a>线程池的创建与停止</h2><h3 id="线程池构造函数的参数"><a href="#线程池构造函数的参数" class="headerlink" title="线程池构造函数的参数"></a>线程池构造函数的参数</h3><table><thead><tr><th align="center">参数名</th><th align="center">类型</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">corePoolSize</td><td align="center">int</td><td align="center">核心线程数</td></tr><tr><td align="center">maxPoolSize</td><td align="center">int</td><td align="center">最大线程数</td></tr><tr><td align="center">keepAliveTime</td><td align="center">long</td><td align="center">保持存活时间</td></tr><tr><td align="center">workQueue</td><td align="center">BlockingQueue</td><td align="center">任务存储队列</td></tr><tr><td align="center">threadFactory</td><td align="center">ThreadFactory</td><td align="center">当线程池需要新的线程的时候，会使用threadFactory来生成新的线程</td></tr><tr><td align="center">Handler</td><td align="center">RejectedExecutionHandler</td><td align="center">由于线程池无法接受所提交的任务的拒绝策略</td></tr></tbody></table><ul><li><strong>corePoolSize</strong>：指的是核心线程数:线程池在完成初始化后，默认情况下，线程池中并没有任何线程，线程池会等待有任务到来时再创建新线程去执行任务</li><li><strong>maxPoolSize</strong>：线程池有可能会在核心线程数的基础上，额外增加一些线程，但是这些新增加的线程数有一个上限</li></ul><h3 id="添加线程规则"><a href="#添加线程规则" class="headerlink" title="添加线程规则"></a>添加线程规则</h3><ul><li>如果线程数小于corePoolSize，即使其他工作线程处于空闲状态，也会创建一个新线程来运行新任务</li><li>如果线程数等于(或大于)corePoolSize但少于maximumPoolSize，则将任务放入队列</li><li>如果队列已满，并且线程数小于maxPoolSize，则创建个新线程来运行任务</li><li>如果队列已满，并且线程数大于或等于maxPoolSize则拒绝该任务。</li></ul><ul><li>是否需要增加线程的判断顺序是:<ul><li>corePoolSize</li><li>workQueue</li><li>maxPoolSize </li></ul></li></ul><h3 id="增减线程的特点"><a href="#增减线程的特点" class="headerlink" title="增减线程的特点"></a>增减线程的特点</h3><ol><li>通过设置corePoolSize和maximumPoolSize 相同，就可以创建固定大小的线程池</li><li>线程池希望保持较少的线程数，并且只有在负载变得很大时才增加它</li><li>通过设置maximumPoolSize为很高的值，例如IntegerMAX_VALUE，可以允许线程池容纳任意数量的并发任务</li><li>是只有在队列填满时才创建多于corePoolSize的线程，所以如果你使用的是无界队列(例如LinkedBlockingQueue)，那么线程数就不会超过corePoolSize</li></ol><h3 id="线程池应该手动创建还是自动创建"><a href="#线程池应该手动创建还是自动创建" class="headerlink" title="线程池应该手动创建还是自动创建"></a>线程池应该手动创建还是自动创建</h3><h3 id="线程池里的线程数量设定为多少比较合适"><a href="#线程池里的线程数量设定为多少比较合适" class="headerlink" title="线程池里的线程数量设定为多少比较合适?"></a>线程池里的线程数量设定为多少比较合适?</h3><h3 id="停止线程池的正确方法"><a href="#停止线程池的正确方法" class="headerlink" title="停止线程池的正确方法"></a>停止线程池的正确方法</h3><h2 id=""><a href="#" class="headerlink" title=""></a></h2><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><p>1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;br&gt;

&lt;h1 id=&quot;第1章-开宗明义&quot;&gt;&lt;a href=&quot;#第1章-开宗明义&quot; class=&quot;headerlink&quot; title=&quot;第1章 开宗明义&quot;&gt;&lt;/a&gt;第1章 开宗明义&lt;/h1&gt;&lt;h2 id=&quot;为什么要学习并发编程&quot;&gt;&lt;a href=&quot;#为什么要学习并发编程&quot; c</summary>
      
    
    
    
    <category term="Java" scheme="https://ratears.github.io/dev.ratears.life/Categories/Java/"/>
    
    <category term="Concurrency" scheme="https://ratears.github.io/dev.ratears.life/Categories/Java/Concurrency/"/>
    
    
    <category term="Java" scheme="https://ratears.github.io/dev.ratears.life/Tags/Java/"/>
    
    <category term="Concurrency" scheme="https://ratears.github.io/dev.ratears.life/Tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>《线程八大核心+Java并发原理及企业级并发解决方案》Study Notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/%E3%80%8A%E7%BA%BF%E7%A8%8B%E5%85%AB%E5%A4%A7%E6%A0%B8%E5%BF%83-Java%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%8BStudy-Notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/%E3%80%8A%E7%BA%BF%E7%A8%8B%E5%85%AB%E5%A4%A7%E6%A0%B8%E5%BF%83-Java%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%8BStudy-Notes/</id>
    <published>2023-04-13T04:31:09.000Z</published>
    <updated>2023-04-13T04:31:09.000Z</updated>
    
    <content type="html"><![CDATA[<br><h1 id="第1章-开宗明义"><a href="#第1章-开宗明义" class="headerlink" title="第1章 开宗明义"></a>第1章 开宗明义</h1><h2 id="为什么要学习并发编程"><a href="#为什么要学习并发编程" class="headerlink" title="为什么要学习并发编程"></a>为什么要学习并发编程</h2><ol><li><p>源于JD（job description）的硬性要求，尤其是大厂</p></li><li><p>并发痛点：（面试中高频出现、内容繁杂、做归纳整理耗时、网上文章水平参差不齐难辨真伪）</p></li><li><p>并发学习，是成为高级工程师的必经之路</p><p>①几乎所有的程序或多或少都需要并发和多线程；</p><p>②线上服务用户量过大，并发上万，如果不使用并发编程，性能很快成为瓶颈；</p><p>③我们在职场打怪升级的过程中，并发编程是绕不过去的内容</p></li><li><p>并发是众多框架的的原理和基础，学好后可以做到一通百通</p><p>①Spring中对线程池、单例的应用；</p><p>②数据库中的乐观锁思想；</p><p>③Log4j2对阻塞队列的应用</p></li></ol><br><h2 id="配套资料"><a href="#配套资料" class="headerlink" title="配套资料"></a>配套资料</h2><ul><li><a class="link"   href="https://docs.qq.com/doc/DSVNyZ2FNWWFkeFpO" >https://docs.qq.com/doc/DSVNyZ2FNWWFkeFpO<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://naotu.baidu.com/file/07f437ff6bc3fa7939e171b00f133e17?token=6744a1c6ca6860a0" >https://naotu.baidu.com/file/07f437ff6bc3fa7939e171b00f133e17?token=6744a1c6ca6860a0<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://naotu.baidu.com/file/60a0bdcaca7c6b92fcc5f796fe6f6bc9?token=bcdbae34bb3b0533" >https://naotu.baidu.com/file/60a0bdcaca7c6b92fcc5f796fe6f6bc9?token=bcdbae34bb3b0533<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://coding.imooc.com/class/chapter/362.html#Anchor" >https://coding.imooc.com/class/chapter/362.html#Anchor<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://shimo.im/docs/zdkyBdQb94H255A6" >https://shimo.im/docs/zdkyBdQb94H255A6<i class="fas fa-external-link-alt"></i></a></li></ul><br><br><br><h1 id="第2章-线程八大核心纵观全貌"><a href="#第2章-线程八大核心纵观全貌" class="headerlink" title="第2章 线程八大核心纵观全貌"></a>第2章 线程八大核心纵观全貌</h1><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.6lp13ul4qko0.webp" width="50%"><br><h2 id="线程八大核心基础"><a href="#线程八大核心基础" class="headerlink" title="线程八大核心基础"></a>线程八大核心基础</h2><ol><li>实现多线程的方法到底有1种还是2种还是4种 ?</li><li>怎样才是正确的线程启动方式?</li><li>上山容易下山难，如何正确停止线程 ?( 难点）</li><li>线程的一生6个状态(生命周期）</li><li>Thread和Obiect类中的重要方法详解</li><li>线程的各个属性</li><li>未捕获异常如何处理 ?</li><li>双刃剑: 多线程会导致的问题</li></ol><br><br><br><h1 id="第3章-核心1：实现多线程的正确姿势【解读官方文档】"><a href="#第3章-核心1：实现多线程的正确姿势【解读官方文档】" class="headerlink" title="第3章 核心1：实现多线程的正确姿势【解读官方文档】"></a>第3章 核心1：实现多线程的正确姿势【解读官方文档】</h1><h2 id="创建（实现）新线程的正确方法"><a href="#创建（实现）新线程的正确方法" class="headerlink" title="创建（实现）新线程的正确方法"></a>创建（实现）新线程的正确方法</h2><ul><li>oracle官方文档：<ul><li>方法一：继承Thread类</li><li>方法二：实现Runnable接口</li></ul></li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.3bqyazhh2dk.webp" width="60%"><br><h3 id="总结：创建新线程的方法-精确描述"><a href="#总结：创建新线程的方法-精确描述" class="headerlink" title="总结：创建新线程的方法-精确描述"></a>总结：创建新线程的方法-精确描述</h3><ul><li>通常我们可以分为两类，官网也是这么说的</li><li>准确的讲，创建线程只有一种方式那就是构造Thread类，而实现线程的执行单元有两种方式：<ul><li>方法一：重写Thread的run方法(继承Thread类)</li><li>方法二：实现Runnable接口的run 方法，并把Runnable实例传给Thread类</li></ul></li></ul><br><h2 id="两种创建线程方法的本质对比"><a href="#两种创建线程方法的本质对比" class="headerlink" title="两种创建线程方法的本质对比"></a>两种创建线程方法的本质对比</h2><ul><li>“实现Runnable接口并传入Thread类”和“继承Thread类然后重写run()方法”在实现多线程的本质上，并没有区别，都是最终调用了start()方法来新建线程。这两个方法的最主要区别在于run()方法的内容来源:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">           target.run();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>实现Runnable接口方式: 最终调用target.run ();</li><li>继承Thread类方式: run()整个都被重写</li></ul><br><h2 id="典型错误观点分析"><a href="#典型错误观点分析" class="headerlink" title="典型错误观点分析"></a>典型错误观点分析</h2><ul><li>“线程池创建线程也算是一种新建线程的方式”</li><li>“通过Callable和FutureTask创建线程，也算是一种新建线程的方式”</li><li>“无返回值是实现runnable接口，有返回值是实现callable接口，所以callable是新的实现线程的方式”</li><li>定时器</li><li>匿名内部类</li><li>Lambda表达式</li></ul><p><strong>多线程的实现方式，在代码中写法千变万化，但其本质万变不离其宗</strong></p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="同时用两种方法会怎么样"><a href="#同时用两种方法会怎么样" class="headerlink" title="同时用两种方法会怎么样"></a>同时用两种方法会怎么样</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BothRunnableThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我来自Runnable&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我来自Thread&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最终会执行 Thread 类的run方法，因为 run方法已被重写</li></ul><br><h2 id="实现多线程—常见面试问题"><a href="#实现多线程—常见面试问题" class="headerlink" title="实现多线程—常见面试问题"></a>实现多线程—常见面试问题</h2><h3 id="有多少种实现线程的方法？"><a href="#有多少种实现线程的方法？" class="headerlink" title="有多少种实现线程的方法？"></a>有多少种实现线程的方法？</h3><ol><li>从不同的角度（代码实现方法，本质实现方法）看，会有不同的答案</li><li>典型答案是两种，分别是实现Runnable接口和继承Thread类，然后具体展开说;各自的优势，劣势</li><li>但是，我们看原理，其实Thread类实现了Runnable接口，并且看Thread类的run方法，会发现其实那两种本质都是一样的</li></ol><blockquote><p>“实现Runnable接口并传入Thread类”和“继承Thread类然后重写run0”在实现多线程的本质上，并没有区别，都是最终调用了start (方法来新建线程。这两个方法的最主要区别在于run0方法的内容来源:</p><ul><li>方法一: 最终调用target.run ();</li><li>方法二:run()整个都被重写</li></ul></blockquote><ol start="4"><li>然后具体展开说其他方式:还有其他的实现线程的方法，例如线程池、定时器，它们也能新建线程，但是细看源码，从没有逃出过本质，也就是实现Runnable接口和继承Thread类。</li><li>结论:我们只能通过新建Thread类这一种方式来创建线程，但是类里面的run方法有两种方式来实现，第一种是重写run方法，第二种实现Runnable接口的run方法，然后再把该runnable实例传给Thread类。除此之外，从表面上看线程池、定时器等工具类也可以创建线程，但是它们的本质都逃不出刚才所说的范围。</li></ol><blockquote><p>以上这种描述比直接回答一种、两种、多种都更准确。</p></blockquote><br><h3 id="实现Runnable接口和继承Thread类哪种方式更好"><a href="#实现Runnable接口和继承Thread类哪种方式更好" class="headerlink" title="实现Runnable接口和继承Thread类哪种方式更好?"></a>实现Runnable接口和继承Thread类哪种方式更好?</h3><ul><li>实现Runnable接口更好</li></ul><ol><li>从代码架构角度，具体的任务 (run方法)应该和“创建和运行线程的机制(Thread类)”解耦。</li><li>使用继承Thread的方式的话，那么每次想新建一个任务，只能新建一个独立的线程，而这样做的损耗会比较大。如果使用Runnable和线程池，就可以大大减小这样的损耗。</li><li>继承Thread类以后，由于Java语言不支持双继承，这样就无法再继承其他的类，限制了可扩展性。</li></ol><br><br><br><h1 id="第4章-核心2：开启多线程启动的世界"><a href="#第4章-核心2：开启多线程启动的世界" class="headerlink" title="第4章 核心2：开启多线程启动的世界"></a>第4章 核心2：开启多线程启动的世界</h1><h2 id="start-方法含义"><a href="#start-方法含义" class="headerlink" title="start()方法含义"></a>start()方法含义</h2><ol><li>启动新线程</li><li>准备工作</li><li>不能重复调用start()</li></ol><br><h2 id="start-源码解析"><a href="#start-源码解析" class="headerlink" title="start()源码解析"></a>start()源码解析</h2><ol><li>启动新线程检查线程状态</li><li>加入线程组</li><li>调用start0()方法</li></ol><br><h2 id="启动线程—常见面试题问题"><a href="#启动线程—常见面试题问题" class="headerlink" title="启动线程—常见面试题问题"></a>启动线程—常见面试题问题</h2><h3 id="一个线程两次调用start-方法会出现什么情况-为什么"><a href="#一个线程两次调用start-方法会出现什么情况-为什么" class="headerlink" title="一个线程两次调用start()方法会出现什么情况? 为什么?"></a>一个线程两次调用start()方法会出现什么情况? 为什么?</h3><ul><li>从start()源码可以看出，start的时候会先检查线程状态，只有NEW状态下的线程才能继续执行，否则会抛IllegalThreadStateException(在运行中或者已结束的线程，都不能再次启动)。</li></ul><br><h3 id="既然-start-方法会调用-run-方法，为什么我们选择调用-start-方法而不是直接调用-run-方法呢"><a href="#既然-start-方法会调用-run-方法，为什么我们选择调用-start-方法而不是直接调用-run-方法呢" class="headerlink" title="既然 start()方法会调用 run()方法，为什么我们选择调用 start() 方法而不是直接调用 run()方法呢?"></a>既然 start()方法会调用 run()方法，为什么我们选择调用 start() 方法而不是直接调用 run()方法呢?</h3><ul><li>start()才是真正启动一个线程，而如果直接调用run()，那么run()只是一个普通的方法而已，和线程的生命周期没有任何关系</li></ul><br><br><br><h1 id="第5章-核心3：线程停止、中断之最佳实践【填“坑”式教学，从错误到正确】"><a href="#第5章-核心3：线程停止、中断之最佳实践【填“坑”式教学，从错误到正确】" class="headerlink" title="第5章 核心3：线程停止、中断之最佳实践【填“坑”式教学，从错误到正确】"></a>第5章 核心3：线程停止、中断之最佳实践【填“坑”式教学，从错误到正确】</h1><h2 id="如何正确停止线程"><a href="#如何正确停止线程" class="headerlink" title="如何正确停止线程"></a>如何正确停止线程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>原理介绍：使用interrupt来通知，而不是强制</p><ul><li><strong>使用interrupt优点：被中断的线程其自身拥有如何响应中断的权利（因为：有些线程的某些代码是非常重要的，我们必须要等待这些线程处理完之后或者其准备好之后，再由它们自己去主动终止或做其它处理。这样更加安全，完成了清理工作，数据的完整性也得到了保障）</strong></li></ul></li><li><p>线程通常在什么情况下停止：</p><ul><li>run方法运行完毕</li><li>有异常出现，且方法没有捕获</li></ul></li><li><p>线程的正确停止方法：interrupt</p><ul><li>通常情况下如何停止线程</li><li>线程可能阻塞</li><li>如果线程在每次迭代后都阻塞</li></ul></li></ul><h3 id="通常情况下中断（停止）线程"><a href="#通常情况下中断（停止）线程" class="headerlink" title="通常情况下中断（停止）线程"></a>通常情况下中断（停止）线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：一般情况（ run方法内没有sleep或wait方法时），正确停止线程的方式</span></span><br><span class="line"><span class="comment"> * 需要判断 Interrupt 标志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RightWayStopThreadWithoutSleep</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; num &lt; Integer.MAX_VALUE/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">10000</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(num+<span class="string">&quot; 是10000的倍数&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RightWayStopThreadWithoutSleep</span>());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程可能被阻塞情况下，正确停止线程"><a href="#线程可能被阻塞情况下，正确停止线程" class="headerlink" title="线程可能被阻塞情况下，正确停止线程"></a>线程可能被阻塞情况下，正确停止线程</h3><ul><li>正确中断线程，但也抛出错误</li><li>不需要判断Interrupt</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     带有sleep的中断线程的写法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RightWayStopThreadWithSleep</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程在每次迭代后都阻塞，正确停止线程"><a href="#线程在每次迭代后都阻塞，正确停止线程" class="headerlink" title="线程在每次迭代后都阻塞，正确停止线程"></a>线程在每次迭代后都阻塞，正确停止线程</h3><ul><li>正确中断线程，但也抛出错误</li><li>不需要每次迭代都检查线程是否已中断</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：   如果在执行过程中，每次循环都会调用sleep或wait等方法，那么不需要每次迭代都检查是否已中断，因为中断过程中就会检测到该异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RightWayStopThreadWithSleepEveryLoop</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> ()-&gt;&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (num &lt; Integer.MAX_VALUE / <span class="number">2</span> ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (num % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(num + <span class="string">&quot;是100的倍数&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    num++;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="while内try-catch的问题"><a href="#while内try-catch的问题" class="headerlink" title="while内try/catch的问题"></a>while内try/catch的问题</h2><ul><li>如果while里面放try/catch，会导致中断失效</li><li><strong>中断失效原因： Java语言的sleep设计中，一旦响应中断，便会把线程的interrupt标记给清除</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     如果while里面放try/catch，会导致中断失效</span></span><br><span class="line"><span class="comment"> * 中断失效原因： Java语言的sleep设计中，一旦响应中断，便会把线程的interrupt标记给清除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CantInterrupt</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> ()-&gt;&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (num &lt; Integer.MAX_VALUE/<span class="number">2</span> &amp;&amp; !Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                <span class="keyword">if</span> (num %<span class="number">100</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(num + <span class="string">&quot;是100的倍数&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">//这里响应中断，会打印出异常，但是线程中断失效</span></span><br><span class="line">                    <span class="comment">//中断失效原因：Java语言的sleep设计中，一旦响应中断，便会把线程的interrupt标记给清除</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实际开发中-两种（中断线程）最佳实践"><a href="#实际开发中-两种（中断线程）最佳实践" class="headerlink" title="实际开发中 - 两种（中断线程）最佳实践"></a>实际开发中 - 两种（中断线程）最佳实践</h2><ul><li>优先选择：传递中断</li><li>不想或无法传递中断：恢复中断</li><li>不应屏蔽中断</li></ul><h3 id="优先选择：传递该中断"><a href="#优先选择：传递该中断" class="headerlink" title="优先选择：传递该中断"></a>优先选择：传递该中断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     最佳实践：catch了InterruptedExcetion之后的优先选择：在方法签名中抛出异常 ,那么在run()就会强制try/catch</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RightWayStopThreadInProd</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * run 方法无法再抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span> &amp;&amp; !Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;go&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                useOtherMethod();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">//保存日志、或中断程序</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 描述：应该上报异常，让run函数决定如何处理异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">useOtherMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误方式：</span></span><br><span class="line"><span class="comment">     * 把异常处理在比较低级的层次，虽然响应中断，打印错误，但对上层方法无感知。相当于屏蔽了中断。结果线程中断失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    private void useOtherMethod() &#123;</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RightWayStopThreadInProd</span>());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="恢复中断"><a href="#恢复中断" class="headerlink" title="恢复中断"></a>恢复中断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：最佳实践2：在catch子语句中调用Thread.currentThread().interrupt()来恢复设置中断状态，以便于在后续的执行中，依然能够检查到刚才发生了中断</span></span><br><span class="line"><span class="comment"> * 回到刚才RightWayStopThreadInProd补上中断，让它跳出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RightWayStopThreadInProd2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Interrupted，程序运行结束&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            reInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">//恢复中断请求标志</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RightWayStopThreadInProd2</span>());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="响应中断的方法总结列表"><a href="#响应中断的方法总结列表" class="headerlink" title="响应中断的方法总结列表"></a>响应中断的方法总结列表</h2><ul><li><p><strong>响应中断是指：当中断信号到达的时候，是可以感知到响应中断信号的</strong></p></li><li><p>Object. wait()/ wait long)/ wait( long, int)</p></li><li><p>Thread. sleep( long) /sleep( long, int)</p></li><li><p>Thread. join0/ join( long)/join( long, int)</p></li><li><p>java. util. concurrent. BlockingQueue. take() /put( E)</p></li><li><p>java. util. concurrent. locks. Lock.lockInterruptibly()</p></li><li><p>java. util. concurrent. CountDownLatch. await()</p></li><li><p>java. util. concurrent. CyclicBarrier. await()</p></li><li><p>java.util. concurrent. Exchanger. exchange(V)</p></li><li><p>java.nio.channels.InterruptibleChannel相关方法</p></li><li><p>java.nio.channels.Selector的相关方法</p></li></ul><h2 id="错误停止线程的方法"><a href="#错误停止线程的方法" class="headerlink" title="错误停止线程的方法"></a>错误停止线程的方法</h2><ul><li>被弃用的stop,suspend和resume方法<ul><li>stop 它本版上是不安全的。停止线程会导致它解锁已锁定的所有监视器</li><li>suspend和resume：带着锁休息，会造成死锁</li></ul></li><li>用volatile设置boolean标记位</li></ul><h3 id="stop停止线程演示（错误方式）"><a href="#stop停止线程演示（错误方式）" class="headerlink" title="stop停止线程演示（错误方式）"></a>stop停止线程演示（错误方式）</h3><ul><li>无法完成基本单位操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     错误的停止方法：用stop()来停止线程，会导致线程运行一半突然停止，</span></span><br><span class="line"><span class="comment"> * 没办法完成一个基本单位的操作（一个连队），会造成脏数据（有的连队少领取装备）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//i表示连队编号 ，j表示人员编号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;连队 &quot;</span>+i +<span class="string">&quot; 开始领取武器&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;连队 &quot;</span>+i+<span class="string">&quot;的人员 &quot;</span>+j+<span class="string">&quot; 号领取了武器&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;连队 &quot;</span>+i +<span class="string">&quot; 领取武器完毕&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">StopThread</span>());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        thread.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用volatile设置boolean标记位-停止线程演示（错误方式）"><a href="#用volatile设置boolean标记位-停止线程演示（错误方式）" class="headerlink" title="用volatile设置boolean标记位 - 停止线程演示（错误方式）"></a>用volatile设置boolean标记位 - 停止线程演示（错误方式）</h3><h4 id="volatile：开上去可行"><a href="#volatile：开上去可行" class="headerlink" title="volatile：开上去可行"></a>volatile：开上去可行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     演示用volatile的局限：part1 看似可行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WrongWayVolatile</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">canceled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &lt; Integer.MAX_VALUE/<span class="number">2</span> &amp;&amp; !canceled)&#123;</span><br><span class="line">            <span class="keyword">if</span> (num %<span class="number">10</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(num + <span class="string">&quot; 是 10 的倍数&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">WrongWayVolatile</span> <span class="variable">wrongWayVolatile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WrongWayVolatile</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(wrongWayVolatile);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        wrongWayVolatile.canceled=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="volatile不能正确停止线程的情况演示"><a href="#volatile不能正确停止线程的情况演示" class="headerlink" title="volatile不能正确停止线程的情况演示"></a>volatile不能正确停止线程的情况演示</h4><ul><li>错误原因：实际阻塞位置在<code>blockingQueue.put(num);</code>。并未经过<code>while ( num &lt; 1000000 &amp;&amp; !canceled)</code>这个判断，所以能停止线程</li><li>所以我们应该使用interrupt来正确停止线程。即便遇到了上述情况，其也可以响应</li><li>修复：换成interrupt来中断线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     演示用volatile的局限part2 陷入阻塞时，volatile是无法线程的</span></span><br><span class="line"><span class="comment"> * 此例中，生产者的生产速度很快，消费者消费速度慢，</span></span><br><span class="line"><span class="comment"> * 所以阻塞队列满了以后，生产者会阻塞，等待消费者进一步消费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WrongWayVolatileCantStop</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ArrayBlockingQueue</span> <span class="variable">storage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(storage);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(producer);</span><br><span class="line">        producerThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(storage);</span><br><span class="line">        <span class="keyword">while</span> (consumer.needMoreNums()) &#123;</span><br><span class="line">            System.out.println(consumer.blockingQueue.take()+<span class="string">&quot;被消费了&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者不需要更多数据了。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一旦消费不需要更多数据了，我们应该让生产者也停下来，但是实际情况</span></span><br><span class="line">        producer.canceled=<span class="literal">true</span>;</span><br><span class="line">        System.out.println(producer.canceled);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    BlockingQueue blockingQueue;</span><br><span class="line">     <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">canceled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(BlockingQueue blockingQueue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//生产者在这里做检查</span></span><br><span class="line">            <span class="keyword">while</span> ( num &lt; <span class="number">1000000</span> &amp;&amp; !canceled)&#123;</span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">100</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(num +<span class="string">&quot;是100的倍数&quot;</span>);</span><br><span class="line">                        <span class="comment">//实际阻塞位置是这里</span></span><br><span class="line">                        blockingQueue.put(num);</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者结束运行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span>&#123;</span><br><span class="line">    BlockingQueue blockingQueue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(BlockingQueue blockingQueue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">needMoreNums</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.random() &gt; <span class="number">0.95</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="停止线程相关重要函数解析"><a href="#停止线程相关重要函数解析" class="headerlink" title="停止线程相关重要函数解析"></a>停止线程相关重要函数解析</h2><h3 id="判断是否已被中断相关方法"><a href="#判断是否已被中断相关方法" class="headerlink" title="判断是否已被中断相关方法"></a>判断是否已被中断相关方法</h3><ul><li>static boolean interrupted()<ul><li>判断线程是否中断，返回后会把线程的中断状态设置为false（唯一能清除线程状态的办法）</li><li>interrupted()方法的目标对象是“当前线程”（执行该方法的线程），而不管本方法来自于哪个对象</li></ul></li><li>boolean isInterrupted()<ul><li>判断线程是否中断。但是不会做线程状态清除</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     注意Thread.interrupted()方法的目标对象是“当前线程”（执行该方法的线程），而不管本方法来自于哪个对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RightWayInterrupted</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        threadOne.start();</span><br><span class="line">        <span class="comment">//设置中断标志</span></span><br><span class="line">        threadOne.interrupt();</span><br><span class="line">        <span class="comment">//获取中断标志</span></span><br><span class="line">        System.out.println(<span class="string">&quot;isInterrupted: &quot;</span> + threadOne.isInterrupted());<span class="comment">//true</span></span><br><span class="line">        <span class="comment">//获取中断标志并重置</span></span><br><span class="line">        System.out.println(<span class="string">&quot;isInterrupted: &quot;</span> + threadOne.interrupted());<span class="comment">//fasle</span></span><br><span class="line">        <span class="comment">//获取中断标志并重直</span></span><br><span class="line">        System.out.println(<span class="string">&quot;isInterrupted: &quot;</span> + Thread.interrupted());<span class="comment">//false</span></span><br><span class="line">        <span class="comment">//获取中断标志</span></span><br><span class="line">        System.out.println(<span class="string">&quot;isInterrupted: &quot;</span> + threadOne.isInterrupted());<span class="comment">//true</span></span><br><span class="line">        threadOne.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread is over.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="停止线程-—-面试常见问题"><a href="#停止线程-—-面试常见问题" class="headerlink" title="停止线程 — 面试常见问题"></a>停止线程 — 面试常见问题</h2><h3 id="如何停止线程"><a href="#如何停止线程" class="headerlink" title="如何停止线程"></a>如何停止线程</h3><ul><li>回答思路：<ul><li>原理:用interrupt来请求、好处</li><li>想停止线程，要请求方、被停止方、子方法被调用方相互配合</li><li>最后再说错误的方法:stop/suspend已废弃，volatile的boolean无法处理长时间阻塞的情况</li></ul></li></ul><blockquote><p>我们要用interrupt来请求中断（停止）线程，而那些stop或者是volatile。好处是可以保证数据安全和数据完整性。我们要把主动权交给被中断的线程</p><p>要想达到这样的效果，不仅让我们调用interrupt方法去中断它，还要被中断的线程配合，而且配合一共有三方配合，分别是请求方、被停止方、被调用方这三方。</p><p>首先作为请求方，我们非常简单发出一个请求信号，而被停止方案，它必须在每次循环中或者适当的时候去检查中断信号，并且在可能抛出interrupted exception的时候去处理这个信号。每一个县城他都应该去做这样的事情，以便于自己可以被停止。如果我们是去写子方法的，这个子方法是会被我们先生所调用的，那么我们有两点最佳实践，优先是在方法层抛出这个exception，以便于其他人去做进一步的处理，或者我们在收到中断信号之后，把它再次设为中断状态，这两种方法都可以，如果这三方配合合适配合默契的话，我们就可以利用我们的interrupt来非常完美来达到一个线程停止的效果。</p><p>stop/suspend的缺点，volatile的错误。它无法处理长时间阻塞的状态，而这种状态在生产环境很有可能发生，尤其是这一点一定会成为我们的一个亮点。因为这一点可能包括一些面试官在内都不知道它是一个错误的方法，我们可以用刚才代码给他演示一下，我相信如果这样解释一下如何正确停止线程是一个非常不错的答案。</p></blockquote><h3 id="如何处理不可中断的阻塞"><a href="#如何处理不可中断的阻塞" class="headerlink" title="如何处理不可中断的阻塞"></a>如何处理不可中断的阻塞</h3><blockquote><p>视频多看两遍</p></blockquote><blockquote><p>关于这个问题的描述是这样的，我们刚才讲过我们使用了interrupt方法，它不是万能的，之所以它能让我们及时的响应中断，那是由于我们的wait或者是sleep，我们也分析过源码，它是可以被我们所唤醒，但是有很多方法它不一定能够及时被我们唤醒。<br>比如说在执行socket io操作的时候，我们即便给他发出interrupt信号，他也无法及时的响应的，或者是reaction的loc方法的时候，他也无法响应，总有各种各样的方法它是无法及时响应的，这种叫做不可中断阻塞。那么这种阻塞我们如何去正确的处理答案是这样的。<br>首先我们要给一个结论叫做很遗憾，并没有一个通用的解决方案，通用的是不存在的，我们要针对某一些所或者某一些io给出不同的解决方案。<br>在这边我们给出一个例子，比如说关于engined loc，这个是可重入锁，如果我们真的使用了它的lock方法，并且在lock过程中把它阻塞，那么是没有办法让它及时响应的。但是与此同时类提供了一个lock interrupt这个方法，这个方法是可以响应中断的，所以这就要求我们在编写代码的过程中去使用那些可以响应中断的方法，这是一种解决方案。<br>针对于io的情况，普通的io或许没有办法及时响应，但是有一些io操作它是可以响应我们中断的，那么我们就用这些特定的方法，所以如果我们被面试官问到这个问题的话，我们的答案就是针对特定的情况，我们使用特定的方法，尽可能的让他做到能够响应中断，没有一个万能药。</p></blockquote><br><br><br><h1 id="第6章-核心4：图解线程生命周期【适用于面试】"><a href="#第6章-核心4：图解线程生命周期【适用于面试】" class="headerlink" title="第6章 核心4：图解线程生命周期【适用于面试】"></a>第6章 核心4：图解线程生命周期【适用于面试】</h1><h2 id="线程的生命周期（6个状态）"><a href="#线程的生命周期（6个状态）" class="headerlink" title="线程的生命周期（6个状态）"></a>线程的生命周期（6个状态）</h2><ul><li>New</li><li>Runnable</li><li>Blocked</li><li>Waiting</li><li>Timed Waiting</li><li>Terminated</li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.3o4t94nv50w0.png" width="70%"><br><h2 id="线程生命周期6种状态演示"><a href="#线程生命周期6种状态演示" class="headerlink" title="线程生命周期6种状态演示"></a>线程生命周期6种状态演示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     展示线程的NEW、RUNNABLE、Terminated状态。即使是正在运行，也是Runnable状态，而不是Running。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewRunnableTerminated</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">NewRunnableTerminated</span>());</span><br><span class="line">        <span class="comment">//打印出NEW的状态</span></span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印出RUNNABLE的状态，即使是正在运行，也是RUNNABLE，而不是RUNNING</span></span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印出TERMINATED状态</span></span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：     展示Blocked, Waiting, TimedWaiting</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockedWaitingTimedWaiting</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BlockedWaitingTimedWaiting</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlockedWaitingTimedWaiting</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印出Timed_Waiting状态，因为正在执行Thread.sleep(1000);</span></span><br><span class="line">        System.out.println(thread1.getState());</span><br><span class="line">        <span class="comment">//打印出BLOCKED状态，因为thread2想拿得到sync()的锁却拿不到</span></span><br><span class="line">        System.out.println(thread2.getState());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印出WAITING状态，因为执行了wait()</span></span><br><span class="line">        System.out.println(thread1.getState());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        syn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">syn</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h2><ul><li>一般习惯而言，把Blocked(被阻塞)、Waiting(等待 )、Timed_waiting(计时等待)都称为阻塞状态</li></ul><h2 id="线程生命周期-常见面试问题"><a href="#线程生命周期-常见面试问题" class="headerlink" title="线程生命周期 - 常见面试问题"></a>线程生命周期 - 常见面试问题</h2><ul><li>线程有哪几种状态？生命周期是什么？</li></ul><br><br><br><h1 id="第7章-核心5：趣解Thread和Object类中线程相关方法"><a href="#第7章-核心5：趣解Thread和Object类中线程相关方法" class="headerlink" title="第7章 核心5：趣解Thread和Object类中线程相关方法"></a>第7章 核心5：趣解Thread和Object类中线程相关方法</h1><br><br><br><h1 id="第8章-核心6：一网打尽线程属性"><a href="#第8章-核心6：一网打尽线程属性" class="headerlink" title="第8章 核心6：一网打尽线程属性"></a>第8章 核心6：一网打尽线程属性</h1><br><br><br><h1 id="第9章-核心7：线程异常处理知多少？"><a href="#第9章-核心7：线程异常处理知多少？" class="headerlink" title="第9章 核心7：线程异常处理知多少？"></a>第9章 核心7：线程异常处理知多少？</h1><h2 id="面试-思考题"><a href="#面试-思考题" class="headerlink" title="面试/思考题"></a>面试/思考题</h2><ul><li>画出Java异常体系图</li><li>实际工作中，如何全局处理异常？为什么要全局处理？不处理行不行？</li><li>run方法是否可以抛出异常?如果抛出异常，线程的状态会怎么样?</li><li>线程中如何处理某个未处理异常？</li></ul><h2 id="线程的未捕获异常（UncaughtException）应该如何处理"><a href="#线程的未捕获异常（UncaughtException）应该如何处理" class="headerlink" title="线程的未捕获异常（UncaughtException）应该如何处理 ?"></a>线程的未捕获异常（UncaughtException）应该如何处理 ?</h2><h3 id="为什么需要UncaughtExceptionHandler"><a href="#为什么需要UncaughtExceptionHandler" class="headerlink" title="为什么需要UncaughtExceptionHandler ?"></a>为什么需要UncaughtExceptionHandler ?</h3><ul><li>主线程可以轻松发现异常，子线程却不行<ul><li>即使子线程在运行过程中抛出了异常，但在茫茫日志中，却难以发现该异常</li></ul></li><li>子线程异常无法用传统方法捕获<ul><li>原因：传统的异常处理（try catch）只能捕获其代码块所在的线程内的异常</li></ul></li><li>不能直接捕获的后果、提高健壮性</li></ul><h2 id="两种解决方案"><a href="#两种解决方案" class="headerlink" title="两种解决方案"></a>两种解决方案</h2><h3 id="方案一-不推荐-手动在每个run方法里进行try-catch"><a href="#方案一-不推荐-手动在每个run方法里进行try-catch" class="headerlink" title="方案一(不推荐):手动在每个run方法里进行try catch"></a>方案一(不推荐):手动在每个run方法里进行try catch</h3><ul><li>在每一个线程的run方法中使用 （try catch）捕获异常 这样做，而我们不知道抛出的异常类型，且样太累了</li></ul><h3 id="方案二-推荐-利用UncaughtExceptionHandler"><a href="#方案二-推荐-利用UncaughtExceptionHandler" class="headerlink" title="方案二(推荐):利用UncaughtExceptionHandler"></a>方案二(推荐):利用UncaughtExceptionHandler</h3><ul><li>是Thread类提供的api，可以检测出线程因为异常而终止的情况，并且对此进行处理</li><li>UncaughtExceptionHandler接口：void uncaughtException(Thread t, Throwable e)</li></ul><ul><li>异常处理器的调用策略</li></ul><img src="" width="70%"><br><ul><li>自己实现<ul><li>给程序统一设置</li><li>给每个线程单独设置</li><li>给线程池设置</li></ul></li></ul><br><br><br><h1 id="第10章-核心8：追寻并发的崇高理想-线程安全【工作常用】"><a href="#第10章-核心8：追寻并发的崇高理想-线程安全【工作常用】" class="headerlink" title="第10章 核心8：追寻并发的崇高理想-线程安全【工作常用】"></a>第10章 核心8：追寻并发的崇高理想-线程安全【工作常用】</h1><h2 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h2><ul><li>《Java Concurrency In Practice》的作者Brian Goetz对“线程安全有一个比较恰当的定义:“当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。</li></ul><blockquote><p>我的翻译:不管业务中遇到怎样的多个线程访问某对象或某方法的情况而在编程这个业务逻辑的时候，都不需要额外做任何额外的处理(是可以像单线程编程一样)，程序也可以正常运行(不会因为多线程而出错)，就可以称为线程安全</p></blockquote><h2 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h2><ul><li><p>get同时set、额外同步</p></li><li><p>全都线程安全?: 运行速度、设计成本、trade off</p></li><li><p>完全不用于多线程:不过度设计</p></li></ul><h2 id="什么情况下会出现线程安全问题，怎么避免"><a href="#什么情况下会出现线程安全问题，怎么避免" class="headerlink" title="什么情况下会出现线程安全问题，怎么避免 ?"></a>什么情况下会出现线程安全问题，怎么避免 ?</h2><ul><li>数据争用</li><li></li></ul><br><br><br><h1 id="学习延伸"><a href="#学习延伸" class="headerlink" title="学习延伸"></a>学习延伸</h1><h2 id="学习编程知识的优质途径"><a href="#学习编程知识的优质途径" class="headerlink" title="学习编程知识的优质途径"></a>学习编程知识的优质途径</h2><h3 id="宏观上"><a href="#宏观上" class="headerlink" title="宏观上"></a>宏观上</h3><ul><li>并不是靠工作年限，有的人工作了5年技术却还是只懂皮毛</li><li>要有强大的责任心，不放过任何bug，找到原因并去解决，这就是提高</li><li>主动:永远不会觉得自己的时间多余，重构、优化、学习、总结等。</li><li>敢于承担:虽然这个技术难题以前没碰到过，但是在一定的了解调研后，敢于承担技术难题，让工作充满挑战，这一次次攻克难关的过程中，进步是飞速的</li><li>关心产品，关心业务，而不只是写代码</li></ul><br><h3 id="微观上（系统性学习）"><a href="#微观上（系统性学习）" class="headerlink" title="微观上（系统性学习）"></a>微观上（系统性学习）</h3><ul><li>看经典书籍(指外国人写的经典的中国译本，比如说Java并发编程实战、自页向下计算机网络)</li><li>看官方文档</li><li>英文搜google和stackoverflow</li><li>自己动手写，实践写demo，尝试用到项目里</li><li>不理解的参考该领域的多个书本，综合判断</li><li>学习开源项目，分析源码(学习synchronized原理，反编译看cpp代码)</li></ul><br><h2 id="如何了解技术领域的最新动态"><a href="#如何了解技术领域的最新动态" class="headerlink" title="如何了解技术领域的最新动态"></a>如何了解技术领域的最新动态</h2><ul><li>高质量固定途径:ohmyrss.com(信息源筛选，为我所用)</li><li>订阅技术网址的邮件 :InfoQ(每周都看 )</li><li>公众号不推荐作为技术知识来源，质量无法保证</li></ul><br><h2 id="如何在业务开发中成长"><a href="#如何在业务开发中成长" class="headerlink" title="如何在业务开发中成长"></a>如何在业务开发中成长</h2><ul><li>偏业务方向</li><li>偏技术方向</li><li>两个25%理论</li></ul><h2 id="Java-异常体系"><a href="#Java-异常体系" class="headerlink" title="Java 异常体系"></a>Java 异常体系</h2><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><ol><li>线程停止的面试题，还可以作为延伸和扩展去找相关资料继续学习</li></ol></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br><br><br><br><h1 id="学习备注-1"><a href="#学习备注-1" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><p>1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;br&gt;

&lt;h1 id=&quot;第1章-开宗明义&quot;&gt;&lt;a href=&quot;#第1章-开宗明义&quot; class=&quot;headerlink&quot; title=&quot;第1章 开宗明义&quot;&gt;&lt;/a&gt;第1章 开宗明义&lt;/h1&gt;&lt;h2 id=&quot;为什么要学习并发编程&quot;&gt;&lt;a href=&quot;#为什么要学习并发编程&quot; c</summary>
      
    
    
    
    <category term="Java" scheme="https://ratears.github.io/dev.ratears.life/Categories/Java/"/>
    
    <category term="Concurrency" scheme="https://ratears.github.io/dev.ratears.life/Categories/Java/Concurrency/"/>
    
    
    <category term="Java" scheme="https://ratears.github.io/dev.ratears.life/Tags/Java/"/>
    
    <category term="Concurrency" scheme="https://ratears.github.io/dev.ratears.life/Tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>《Spring 编程常见错误 50 例》Study Notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/%E3%80%8ASpring-%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF-50-%E4%BE%8B%E3%80%8BStudy-Notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/%E3%80%8ASpring-%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF-50-%E4%BE%8B%E3%80%8BStudy-Notes/</id>
    <published>2023-04-10T01:42:26.000Z</published>
    <updated>2023-04-10T01:42:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="课前必读-1讲"><a href="#课前必读-1讲" class="headerlink" title="课前必读 (1讲)"></a>课前必读 (1讲)</h1><h2 id="开篇词｜贴心“保姆”Spring罢工了怎么办？"><a href="#开篇词｜贴心“保姆”Spring罢工了怎么办？" class="headerlink" title="开篇词｜贴心“保姆”Spring罢工了怎么办？"></a>开篇词｜贴心“保姆”Spring罢工了怎么办？</h2><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><p>1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;课前必读-1讲&quot;&gt;&lt;a href=&quot;#课前必读-1讲&quot; class=&quot;headerlink&quot; title=&quot;课前必读 (1讲)&quot;&gt;&lt;/a&gt;课前必读 (1讲)&lt;/h1&gt;&lt;h2 id=&quot;开篇词｜贴心“保姆”Spring罢工了怎么办？&quot;&gt;&lt;a href=&quot;#开篇词｜贴心</summary>
      
    
    
    
    <category term="Spring" scheme="https://ratears.github.io/dev.ratears.life/Categories/Spring/"/>
    
    
    <category term="Spring" scheme="https://ratears.github.io/dev.ratears.life/Tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>《分布式协议与算法实战》Study Notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/%E3%80%8A%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%E3%80%8BStudy-Notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/%E3%80%8A%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%E3%80%8BStudy-Notes/</id>
    <published>2023-03-30T12:39:41.000Z</published>
    <updated>2023-03-30T12:39:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开篇词-2讲"><a href="#开篇词-2讲" class="headerlink" title="开篇词 (2讲)"></a>开篇词 (2讲)</h1><h2 id="开篇词-想成为分布式高手？那就先把协议和算法烂熟于心吧"><a href="#开篇词-想成为分布式高手？那就先把协议和算法烂熟于心吧" class="headerlink" title="开篇词 | 想成为分布式高手？那就先把协议和算法烂熟于心吧"></a>开篇词 | 想成为分布式高手？那就先把协议和算法烂熟于心吧</h2><ul><li>想真正搞懂分布式技术，开发出一个分布式系统，需要先掌握分布式协议和算法。分布式协议和算法是决定分布式系统如何运行的核心规则和步骤</li><li>分布式算法是分布式技术中的核心</li><li>分布式系统里，最重要的，是如何选择和设计合适的算法。解决一致性和可用性的问题。</li><li>InfluxDB系统：就是<strong>以分布式算法为核心的分布式集群能力</strong></li><li>掌握分布式算法，是面试架构师、技术专家等高端岗位的敲门砖</li><li>分布式算法难学的原因：<ul><li>算法本身抽象</li><li>资料参差不齐，大多以英文论文出现</li><li>很多资料没有站在用的角度，将理论和实践结合</li></ul></li></ul><ul><li>分布式协议与算法学习方法：<ul><li>理论篇：分布式架构设计核心的理论基础、典型分布式问题、特性</li><li>协议算法篇：掌握原理、特点、适用场景、常见误区</li><li>实战篇：知识落地，掌握分布式基础理论和分布式算法在工程实践中的应用<ul><li>掌握根据场景特点选择合适的分布式算法</li><li>使用分布式算法的实战技巧</li><li>举一反三</li></ul></li><li>剖析Hashicorp Raft的实现，并以一个分布式KV系统的开发实战为例，如何使用Raft算法实际开发一个分布式系统，全面拥有分布式算法的实战能力。</li></ul></li></ul><ul><li>收获<ul><li>破除你对分布式协议和算法的困惑，帮助你建立信心；</li><li>可落地的 4 大分布式基础理论；</li><li>8 个最常用的分布式协议和算法；</li><li>3 大实战案例手把手教学；</li><li>以实战为中心的分布式内容体系。</li></ul></li></ul><h2 id="学习路径-分布式协议与算法你应该这么学"><a href="#学习路径-分布式协议与算法你应该这么学" class="headerlink" title="学习路径 | 分布式协议与算法你应该这么学"></a>学习路径 | 分布式协议与算法你应该这么学</h2><h1 id="理论篇-5讲"><a href="#理论篇-5讲" class="headerlink" title="理论篇 (5讲)"></a>理论篇 (5讲)</h1><h2 id="01-拜占庭将军问题：有叛徒的情况下，如何才能达成共识？"><a href="#01-拜占庭将军问题：有叛徒的情况下，如何才能达成共识？" class="headerlink" title="01 | 拜占庭将军问题：有叛徒的情况下，如何才能达成共识？"></a>01 | 拜占庭将军问题：有叛徒的情况下，如何才能达成共识？</h2><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><p>1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;开篇词-2讲&quot;&gt;&lt;a href=&quot;#开篇词-2讲&quot; class=&quot;headerlink&quot; title=&quot;开篇词 (2讲)&quot;&gt;&lt;/a&gt;开篇词 (2讲)&lt;/h1&gt;&lt;h2 id=&quot;开篇词-想成为分布式高手？那就先把协议和算法烂熟于心吧&quot;&gt;&lt;a href=&quot;#开篇词-想成</summary>
      
    
    
    
    <category term="distributed" scheme="https://ratears.github.io/dev.ratears.life/Categories/distributed/"/>
    
    
    <category term="distributed" scheme="https://ratears.github.io/dev.ratears.life/Tags/distributed/"/>
    
  </entry>
  
  <entry>
    <title>Good Learning Method</title>
    <link href="https://ratears.github.io/dev.ratears.life/Good-Learning-Method/"/>
    <id>https://ratears.github.io/dev.ratears.life/Good-Learning-Method/</id>
    <published>2023-03-30T10:15:40.000Z</published>
    <updated>2023-03-30T10:15:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h1><ul><li><a class="link"   href="https://www.zhihu.com/topic/19566266/top-answers" >学习方法<i class="fas fa-external-link-alt"></i></a></li></ul><h2 id="如何戒掉手机去认真学习？"><a href="#如何戒掉手机去认真学习？" class="headerlink" title="如何戒掉手机去认真学习？"></a><a class="link"   href="https://www.zhihu.com/question/341554416/answer/848670278" >如何戒掉手机去认真学习？<i class="fas fa-external-link-alt"></i></a></h2><ul><li><strong>不得不说，我们绝大多数人，没有那么强烈的渴望改变，渴望有钱，渴望有地位，渴望有尊严，学习对我们来说，也没有那么重要的意义。</strong>所以，手机就成了学习的障碍，麻将成了学习的障碍，任何一件事都成为学习的障碍。</li></ul><ul><li><strong>第一阶段：向钱看齐，激发对金钱的渴望</strong><ul><li><strong>如果你没有动力，就把赚钱作为第一目的。</strong></li></ul></li><li><strong>第二阶段：逼自己，死读书（学习）</strong><ul><li>当你有了一个明确的目标时，你还静不下心学习时，这时候就需要死磕自己<strong>。死读书，我用的办法就是抄书，边读边抄书，就像小时候写家庭作业。</strong></li></ul></li><li><strong>第三阶段：向前看齐，寻找榜样的力量</strong><ul><li><strong>在你的领域寻找一个榜样。先模仿学习，然后在寻求超越。</strong></li><li>在心理学上有个专业的名词，叫“<a class="link"   href="https://www.zhihu.com/search?q=%E7%9F%A5%E8%AF%86%E7%9A%84%E8%AF%85%E5%92%92&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:848670278%7D" >知识的诅咒<i class="fas fa-external-link-alt"></i></a>”，说的是当我们知道一件事的时，很难想象不知道这件事的人，是怎样一种心理状态。其实就是默认，我们知道这件事，所以人也应该知道这件事。反过来就是说，如果我们不知道一件事，也很难想象出知道这件事对我们的好处。</li><li>为了打破这种知识诅咒，提高自己竞争力，也是为学习这件事加上催化剂。需要找到你所在领域里的一个标杆，也就是大家共识的牛人。以此为标准，去学习，向前看齐。</li></ul></li><li><strong>第四阶段：组队学习，或找一个私人教练</strong><ul><li>在学习之前压上赌注，也就是先付出一部分，你就想要得到回报，而继续坚持下去。</li><li><strong>你只有逼自己一次，达到顶峰体验过这种巅峰的感觉，你就不会允许自己失败，而有足够的动力，去克服学习障碍。包括玩手机、玩麻将、玩大烟枪等等。</strong></li></ul></li></ul><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><p>1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;学习方法&quot;&gt;&lt;a href=&quot;#学习方法&quot; class=&quot;headerlink&quot; title=&quot;学习方法&quot;&gt;&lt;/a&gt;学习方法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;link&quot;   href=&quot;https://www.zhihu.com/topic/1956</summary>
      
    
    
    
    <category term="Learning" scheme="https://ratears.github.io/dev.ratears.life/Categories/Learning/"/>
    
    <category term="Method" scheme="https://ratears.github.io/dev.ratears.life/Categories/Learning/Method/"/>
    
    
    <category term="Learning" scheme="https://ratears.github.io/dev.ratears.life/Tags/Learning/"/>
    
    <category term="Method" scheme="https://ratears.github.io/dev.ratears.life/Tags/Method/"/>
    
  </entry>
  
  <entry>
    <title>Spring 注解驱动开发</title>
    <link href="https://ratears.github.io/dev.ratears.life/Spring-%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    <id>https://ratears.github.io/dev.ratears.life/Spring-%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/</id>
    <published>2023-03-30T08:35:41.000Z</published>
    <updated>2023-03-30T08:35:41.000Z</updated>
    
    <content type="html"><![CDATA[<br><h1 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h1><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><ul><li>告诉Spring这是一个配置类</li><li>配置类 等价于 配置文件（springContext.xml）</li></ul><br><h2 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h2><ul><li>给容器中注册一个Bean;类型为返回值的类型，id默认是用方法名作为id</li><li>也可以指定id</li></ul><br><h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h2><ul><li>开启注解扫描；可以指定要扫描的包或规则</li></ul><br><h2 id="ComponentScans"><a href="#ComponentScans" class="headerlink" title="@ComponentScans"></a>@ComponentScans</h2><ul><li>可以包含多个 @ComponentScan</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScans(</span></span><br><span class="line"><span class="meta">value = &#123;</span></span><br><span class="line"><span class="meta">@ComponentScan(value=&quot;com.stu&quot;,includeFilters = &#123;</span></span><br><span class="line"><span class="meta">/*@Filter(type=FilterType.ANNOTATION,classes=&#123;Controller.class&#125;),</span></span><br><span class="line"><span class="meta">@Filter(type=FilterType.ASSIGNABLE_TYPE,classes=&#123;BookService.class&#125;),*/</span></span><br><span class="line"><span class="meta">@Filter(type=FilterType.CUSTOM,classes=&#123;MyTypeFilter.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;,useDefaultFilters = false)</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="comment">//@ComponentScan  value:指定要扫描的包</span></span><br><span class="line"><span class="comment">//excludeFilters = Filter[] ：指定扫描的时候按照什么规则排除那些组件</span></span><br><span class="line"><span class="comment">//includeFilters = Filter[] ：指定扫描的时候只需要包含哪些组件</span></span><br><span class="line"><span class="comment">//useDefaultFilters = false 禁用默认过滤规则</span></span><br><span class="line"><span class="comment">//FilterType.ANNOTATION：按照注解</span></span><br><span class="line"><span class="comment">//FilterType.ASSIGNABLE_TYPE：按照给定的类型；</span></span><br><span class="line"><span class="comment">//FilterType.ASPECTJ：使用ASPECTJ表达式</span></span><br><span class="line"><span class="comment">//FilterType.REGEX：使用正则指定</span></span><br><span class="line"><span class="comment">//FilterType.CUSTOM：使用自定义规则</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title class_">TypeFilter</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span></span><br><span class="line"><span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//获取当前类注解的信息</span></span><br><span class="line"><span class="type">AnnotationMetadata</span> <span class="variable">annotationMetadata</span> <span class="operator">=</span> metadataReader.getAnnotationMetadata();</span><br><span class="line"><span class="comment">//获取当前正在扫描的类的类信息</span></span><br><span class="line"><span class="type">ClassMetadata</span> <span class="variable">classMetadata</span> <span class="operator">=</span> metadataReader.getClassMetadata();</span><br><span class="line"><span class="comment">//获取当前类资源（类的路径）</span></span><br><span class="line"><span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> metadataReader.getResource();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> classMetadata.getClassName();</span><br><span class="line">System.out.println(<span class="string">&quot;---&gt;&quot;</span>+className);</span><br><span class="line"><span class="keyword">if</span>(className.contains(<span class="string">&quot;er&quot;</span>))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h2><ul><li>@Scope 调整（设置）组件作用域<ul><li>singleton：单实例的（默认值）：ioc容器启动会调用方法创建对象放到ioc容器中。以后每次获取就是直接从容器（map.get()）中拿</li><li>prototype：多实例的；ioc容器启动并不会去调用方法创建对象放在容器中，每次获取的时候才会调用方法创建对象；</li><li>request：同一次请求创建一个实例</li><li>session：同一个session创建一个实例</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="meta">@Bean(&quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;给容器中添加Person....&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h2><ul><li>懒加载</li><li>单实例bean：默认在容器启动的时候创建对象；</li><li>懒加载：容器启动不创建对象。第一次使用(获取)Bean创建对象，并初始化；</li></ul><br><h2 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h2><ul><li>类中组件统一设置。满足当前条件，这个类中配置的所有bean注册才能生效；</li><li>可以加在配置类上，也可以加在具体某个bean上</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinuxCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ConditionContext：判断条件能使用的上下文（环境）</span></span><br><span class="line"><span class="comment"> * AnnotatedTypeMetadata：注释信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line"><span class="comment">// TODO是否linux系统</span></span><br><span class="line"><span class="comment">//1、能获取到ioc使用的beanfactory</span></span><br><span class="line"><span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getBeanFactory();</span><br><span class="line"><span class="comment">//2、获取类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> context.getClassLoader();</span><br><span class="line"><span class="comment">//3、获取当前环境信息</span></span><br><span class="line"><span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> context.getEnvironment();</span><br><span class="line"><span class="comment">//4、获取到bean定义的注册类</span></span><br><span class="line"><span class="type">BeanDefinitionRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> context.getRegistry();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> environment.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以判断容器中的bean注册情况，也可以给容器中注册bean</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">definition</span> <span class="operator">=</span> registry.containsBeanDefinition(<span class="string">&quot;person&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(property.contains(<span class="string">&quot;linux&quot;</span>))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h2><ul><li>导入组件，id默认是组件的全类名</li></ul><br><h2 id="给容器中注册组件的方式"><a href="#给容器中注册组件的方式" class="headerlink" title="给容器中注册组件的方式"></a>给容器中注册组件的方式</h2><ul><li>1）、包扫描+组件标注注解（@Controller/@Service/@Repository/@Component）[自己写的类]</li><li>2）、@Bean[导入的第三方包里面的组件]</li><li>3）、@Import[快速给容器中导入一个组件]<ul><li>1）、@Import(要导入到容器中的组件)；容器中就会自动注册这个组件，id默认是全类名</li><li>2）、ImportSelector:返回需要导入的组件的全类名数组；</li><li>3）、ImportBeanDefinitionRegistrar:手动注册bean到容器中</li></ul></li><li>4）、使用Spring提供的 FactoryBean（工厂Bean）;<ul><li>1）、默认获取到的是工厂bean调用getObject创建的对象</li><li>2）、要获取工厂Bean本身，我们需要给id前面加一个&amp;</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;Red.class,Color.class,MyImportSelector.class,MyImportBeanDefinitionRegistrar.class&#125;)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义逻辑返回需要导入的组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值，就是到导入到容器中的组件全类名</span></span><br><span class="line"><span class="comment">//AnnotationMetadata:当前标注@Import注解的类的所有注解信息</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line"><span class="comment">//importingClassMetadata</span></span><br><span class="line"><span class="comment">//方法不要返回null值</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;com.stu.pojo.Yellow&quot;</span>,<span class="string">&quot;com.stu.pojo.Pink&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnnotationMetadata：当前类的注解信息</span></span><br><span class="line"><span class="comment"> * BeanDefinitionRegistry:BeanDefinition注册类；</span></span><br><span class="line"><span class="comment"> * 把所有需要添加到容器中的bean；调用</span></span><br><span class="line"><span class="comment"> * BeanDefinitionRegistry.registerBeanDefinition手工注册进来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line"><span class="comment">//指定Bean定义信息；（Bean的类型，Bean。。。）</span></span><br><span class="line"><span class="type">RootBeanDefinition</span> <span class="variable">beanDefinition</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(RainBow.class);</span><br><span class="line"><span class="keyword">if</span> (registry.containsBeanDefinition(<span class="string">&quot;com.stu.pojo.Red&quot;</span>) &amp;&amp; registry.containsBeanDefinition(<span class="string">&quot;com.stu.pojo.Yellow&quot;</span>)) &#123;</span><br><span class="line">registry.registerBeanDefinition(<span class="string">&quot;rainBow&quot;</span>, beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ColorFactoryBean <span class="title function_">colorFactoryBean</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ColorFactoryBean</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;&amp;colorFactoryBean&quot;</span>);</span><br><span class="line">System.out.println(obj.getClass());</span><br></pre></td></tr></table></figure><br><br><br><h1 id="组件（Bean）生命周期"><a href="#组件（Bean）生命周期" class="headerlink" title="组件（Bean）生命周期"></a>组件（Bean）生命周期</h1><h2 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h2><ul><li><p>bean的生命周期：bean创建—初始化—-销毁的过程</p></li><li><p>容器管理bean的生命周期：我们可以自定义初始化和销毁方法；容器在bean进行到当前生命周期的时候来调用我们自定义的初始化和销毁方法</p></li><li><p>构造（对象创建）</p><ul><li>单实例：在容器启动的时候创建对象</li><li>多实例：在每次获取的时候创建对象</li></ul></li></ul><h2 id="自定义Bean生命周期"><a href="#自定义Bean生命周期" class="headerlink" title="自定义Bean生命周期"></a>自定义Bean生命周期</h2><ul><li><p>1）、指定初始化和销毁方法；</p><ul><li>通过@Bean指定init-method和destroy-method；</li></ul></li><li><p>2）、通过让Bean实现InitializingBean（定义初始化逻辑），DisposableBean（定义销毁逻辑）;</p></li><li><p>可以使用JSR250；</p><ul><li>@PostConstruct：在bean创建完成并且属性赋值完成；来执行初始化方法</li><li>@PreDestroy：在容器销毁bean之前通知我们进行清理工作</li></ul></li><li><p>4）、BeanPostProcessor【interface】：bean的后置处理器，在bean初始化前后进行一些处理工作；</p><ul><li>postProcessBeforeInitialization:在初始化之前工作</li><li>postProcessAfterInitialization:在初始化之后工作</li></ul></li></ul><h2 id="Bean-指定初始化和销毁方法"><a href="#Bean-指定初始化和销毁方法" class="headerlink" title="Bean 指定初始化和销毁方法"></a>Bean 指定初始化和销毁方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(initMethod=&quot;init&quot;,destroyMethod=&quot;detory&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Car <span class="title function_">car</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Car</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;car constructor...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;car ... init...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detory</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;car ... detory...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="属性赋值"><a href="#属性赋值" class="headerlink" title="属性赋值"></a>属性赋值</h1><h2 id="使用-Value赋值"><a href="#使用-Value赋值" class="headerlink" title="使用@Value赋值"></a>使用@Value赋值</h2><ul><li>基本数值</li><li>可以写SpEL； #{}</li><li>可以写${}；取出配置文件【properties】中的值（在运行环境变量里面的值）</li></ul><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><p>1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;br&gt;

&lt;h1 id=&quot;组件注册&quot;&gt;&lt;a href=&quot;#组件注册&quot; class=&quot;headerlink&quot; title=&quot;组件注册&quot;&gt;&lt;/a&gt;组件注册&lt;/h1&gt;&lt;h2 id=&quot;Configuration&quot;&gt;&lt;a href=&quot;#Configuration&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Spring" scheme="https://ratears.github.io/dev.ratears.life/Categories/Spring/"/>
    
    
    <category term="Spring" scheme="https://ratears.github.io/dev.ratears.life/Tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>《Nacos 核心原理解读+高性能微服务系统实战》Study Notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/%E3%80%8ANacos-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E8%AF%BB-%E9%AB%98%E6%80%A7%E8%83%BD%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98%E3%80%8BStudy-Notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/%E3%80%8ANacos-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E8%AF%BB-%E9%AB%98%E6%80%A7%E8%83%BD%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98%E3%80%8BStudy-Notes/</id>
    <published>2023-03-28T12:16:59.000Z</published>
    <updated>2023-03-28T12:16:59.000Z</updated>
    
    <content type="html"><![CDATA[<br><h1 id="初识Nacos"><a href="#初识Nacos" class="headerlink" title="初识Nacos"></a>初识Nacos</h1><h2 id="Nacos是什么"><a href="#Nacos是什么" class="headerlink" title="Nacos是什么?"></a>Nacos是什么?</h2><ul><li>Nacos官方定义:<ul><li>Nacos 是 Dynamic Naming and Configuration Service的首字母简称</li><li>一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台</li><li>Nacos是一个微服务治理框架</li></ul></li></ul><h2 id="Nacos能干什么"><a href="#Nacos能干什么" class="headerlink" title="Nacos能干什么"></a>Nacos能干什么</h2><ul><li>注册微服务，将服务注册到管控中心</li><li>发现微服务，将服务暴露给其他服务</li><li>管理参数，提供配置参数池</li></ul><h2 id="Nacos由哪几部分组成"><a href="#Nacos由哪几部分组成" class="headerlink" title="Nacos由哪几部分组成"></a>Nacos由哪几部分组成</h2><ul><li>统一服务注册</li><li>统一服务发现</li><li>统一配置管理</li></ul><h2 id="Nacos发展前景"><a href="#Nacos发展前景" class="headerlink" title="Nacos发展前景"></a>Nacos发展前景</h2><ul><li>github 活跃</li><li>Nacos 应用广泛（很多知名大公司都在使用Nacos）</li></ul><h2 id="Eureka的引入"><a href="#Eureka的引入" class="headerlink" title="Eureka的引入"></a>Eureka的引入</h2><ul><li>Eureka 2012年左右被引入国内</li><li>Eureka是Netflix开发的服务发现框架，本身是一个基于REST的服务，主要用于定位运行在AWS城中的中间层服务，以达到负载均衡和中间层服务故障转移的目的。</li><li>Springcloud将它集成在其子项目spring-cloud-netflix中，以实现Springcloud的服务发现功能</li></ul><h2 id="Eureka的盛行"><a href="#Eureka的盛行" class="headerlink" title="Eureka的盛行"></a>Eureka的盛行</h2><ul><li>从2013年开始，被得到广泛使用</li><li>到2015年，几乎国内的互联网大厂均在使用Eureka</li></ul><h2 id="Eureka的陨落"><a href="#Eureka的陨落" class="headerlink" title="Eureka的陨落"></a>Eureka的陨落</h2><ul><li>2018年，Nacos第一个版本正式对外发布</li><li>Eureka只能提供服务注册、发现，不能提供配置管理。使用范围逐渐缩小</li></ul><h2 id="Nacos的崛起"><a href="#Nacos的崛起" class="headerlink" title="Nacos的崛起"></a>Nacos的崛起</h2><ul><li>2019年，Nacos第一个成熟版本正式对外发布（Nacos服务注册、发现效率高，并且提供统一配置管理。内存占用空间比Eureka少）</li><li>2020年，Nacos逐渐被国内互联网大厂使用</li><li>2021年，Eureka已经被国内互联网大厂停止使用，均移步Nacos</li></ul><h2 id="Nacos主要版本介绍"><a href="#Nacos主要版本介绍" class="headerlink" title="Nacos主要版本介绍"></a>Nacos主要版本介绍</h2><h3 id="Nacos-1-4-X版本（低版本的稳定版本）特性"><a href="#Nacos-1-4-X版本（低版本的稳定版本）特性" class="headerlink" title="Nacos 1.4.X版本（低版本的稳定版本）特性"></a>Nacos 1.4.X版本（低版本的稳定版本）特性</h3><ul><li>支持SpringBoot版本到 2.6.6</li><li>解决并完善Spring权限认证相关问题</li><li>重置JRaft协议集群无Leader操作</li><li>减少 DistroProtocol初始化中的内存成本以避免OutOfMemoryError</li><li>增加NamingProxy.serversFromEndpoint的内存可见性</li><li>修复ServerListManager的迭代器并发问题</li></ul><h3 id="Nacos-2-1-X版本（最新版本的稳定版本）特性"><a href="#Nacos-2-1-X版本（最新版本的稳定版本）特性" class="headerlink" title="Nacos 2.1.X版本（最新版本的稳定版本）特性"></a>Nacos 2.1.X版本（最新版本的稳定版本）特性</h3><ul><li>支持批量注册服务</li><li>暂时移除离开 nacos 服务器节点API</li><li>添加默认模糊搜索功能</li><li>将TRACE 事件添加到服务器</li><li>在历史列表中添加版本数据比较</li><li>增强默认身份验证插件性能</li></ul><h2 id="Nacos在Linux系统上单机安装"><a href="#Nacos在Linux系统上单机安装" class="headerlink" title="Nacos在Linux系统上单机安装"></a>Nacos在Linux系统上单机安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src/</span><br><span class="line"></span><br><span class="line">wget https://github.com/alibaba/nacos/releases/download/1.4.4/nacos-server-1.4.4.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf nacos-server-1.4.4.tar.gz</span><br><span class="line"></span><br><span class="line">mv nacos /usr/local/</span><br><span class="line"></span><br><span class="line">cd /usr/local/nacos/bin/</span><br><span class="line"></span><br><span class="line">./startup.sh -m standalone</span><br></pre></td></tr></table></figure><h1 id="Nacos基础核心特性"><a href="#Nacos基础核心特性" class="headerlink" title="Nacos基础核心特性"></a>Nacos基础核心特性</h1><h2 id="Nacos的架构"><a href="#Nacos的架构" class="headerlink" title="Nacos的架构"></a>Nacos的架构</h2><h3 id="Nacos地图"><a href="#Nacos地图" class="headerlink" title="Nacos地图"></a>Nacos地图</h3><ul><li>特性大图：要从功能特性，非功能特性，全面介绍我们要解的问题域的特性诉求</li><li>架构大图：通过清晰架构，让您快速进入 Nacos 世界</li><li>业务大图：利用当前特性可以支持的业务场景，及其最佳实践</li><li>生态大图：系统梳理 Nacos 和主流技术生态的关系</li><li>优势大图：展示 Nacos 核心竞争力</li><li>战略大图：要从战略到战术层面讲 Nacos 的宏观优势</li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.2ovbdtet3ia0.webp" width="70%"><br><h3 id="Nacos-生态图"><a href="#Nacos-生态图" class="headerlink" title="Nacos 生态图"></a>Nacos 生态图</h3><ul><li><p>如 Nacos 全景图所示，Nacos 无缝支持一些主流的开源生态，例如</p><ul><li><a class="link"   href="https://nacos.io/zh-cn/docs/v2/ecology/use-nacos-with-spring-cloud.html" >Spring Cloud<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://nacos.io/zh-cn/docs/v2/ecology/use-nacos-with-dubbo.html" >Apache Dubbo and Dubbo Mesh<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://nacos.io/zh-cn/docs/v2/quickstart/quick-start-kubernetes.html" >Kubernetes and CNCF<i class="fas fa-external-link-alt"></i></a></li></ul></li><li><p>使用 Nacos 简化服务发现、配置管理、服务治理及管理的解决方案，让微服务的发现、管理、共享、组合更加容易。</p></li></ul><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.17s14qggtbk0.webp" width="70%"><br><h3 id="Nacos的基本架构及概念"><a href="#Nacos的基本架构及概念" class="headerlink" title="Nacos的基本架构及概念"></a>Nacos的基本架构及概念</h3><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/image.66ugwucjt0k0.webp" width="70%"><br><h4 id="服务-Service"><a href="#服务-Service" class="headerlink" title="服务 (Service)"></a>服务 (Service)</h4><p>服务是指一个或一组软件功能（例如特定信息的检索或一组操作的执行），其目的是不同的客户端可以为不同的目的重用（例如通过跨进程的网络调用）。Nacos 支持主流的服务生态，如 Kubernetes Service、gRPC|Dubbo RPC Service 或者 Spring Cloud RESTful Service。</p><h4 id="服务注册中心-Service-Registry"><a href="#服务注册中心-Service-Registry" class="headerlink" title="服务注册中心 (Service Registry)"></a>服务注册中心 (Service Registry)</h4><p>服务注册中心，它是服务，其实例及元数据的数据库。服务实例在启动时注册到服务注册表，并在关闭时注销。服务和路由器的客户端查询服务注册表以查找服务的可用实例。服务注册中心可能会调用服务实例的健康检查 API 来验证它是否能够处理请求。</p><h4 id="服务元数据-Service-Metadata"><a href="#服务元数据-Service-Metadata" class="headerlink" title="服务元数据 (Service Metadata)"></a>服务元数据 (Service Metadata)</h4><p>服务元数据是指包括服务端点(endpoints)、服务标签、服务版本号、服务实例权重、路由规则、安全策略等描述服务的数据。</p><h4 id="服务提供方-Service-Provider"><a href="#服务提供方-Service-Provider" class="headerlink" title="服务提供方 (Service Provider)"></a>服务提供方 (Service Provider)</h4><p>是指提供可复用和可调用服务的应用方。</p><h4 id="服务消费方-Service-Consumer"><a href="#服务消费方-Service-Consumer" class="headerlink" title="服务消费方 (Service Consumer)"></a>服务消费方 (Service Consumer)</h4><p>是指会发起对某个服务调用的应用方。</p><h4 id="配置-Configuration"><a href="#配置-Configuration" class="headerlink" title="配置 (Configuration)"></a>配置 (Configuration)</h4><p>在系统开发过程中通常会将一些需要变更的参数、变量等从代码中分离出来独立管理，以独立的配置文件的形式存在。目的是让静态的系统工件或者交付物（如 WAR，JAR 包等）更好地和实际的物理运行环境进行适配。配置管理一般包含在系统部署的过程中，由系统管理员或者运维人员完成这个步骤。配置变更是调整系统运行时的行为的有效手段之一。</p><h4 id="配置管理-Configuration-Management"><a href="#配置管理-Configuration-Management" class="headerlink" title="配置管理 (Configuration Management)"></a>配置管理 (Configuration Management)</h4><p>在数据中心中，系统中所有配置的编辑、存储、分发、变更管理、历史版本管理、变更审计等所有与配置相关的活动统称为配置管理。</p><h4 id="名字服务-Naming-Service"><a href="#名字服务-Naming-Service" class="headerlink" title="名字服务 (Naming Service)"></a>名字服务 (Naming Service)</h4><p>提供分布式系统中所有对象(Object)、实体(Entity)的“名字”到关联的元数据之间的映射管理服务，例如 ServiceName -&gt; Endpoints Info, Distributed Lock Name -&gt; Lock Owner/Status Info, DNS Domain Name -&gt; IP List, 服务发现和 DNS 就是名字服务的2大场景。</p><h4 id="配置服务-Configuration-Service"><a href="#配置服务-Configuration-Service" class="headerlink" title="配置服务 (Configuration Service)"></a>配置服务 (Configuration Service)</h4><p>在服务或者应用运行过程中，提供动态配置或者元数据以及配置管理的服务提供者。</p><h2 id="Nacos特性：服务注册"><a href="#Nacos特性：服务注册" class="headerlink" title="Nacos特性：服务注册"></a>Nacos特性：服务注册</h2><h3 id="服务注册定义"><a href="#服务注册定义" class="headerlink" title="服务注册定义"></a>服务注册定义</h3><ul><li>将服务通过一定的技术手段，使其生成在或存在于某种统一的管理平台或云平台的过程</li></ul><h3 id="Nacos实现服务注册思路剖析"><a href="#Nacos实现服务注册思路剖析" class="headerlink" title="Nacos实现服务注册思路剖析"></a>Nacos实现服务注册思路剖析</h3><ul><li>用户发出服务注册请求</li><li>Nacos接收到该服务注册请求</li><li>Nacos构造服务元数据</li><li>Nacos向云平台发起注册</li><li>Nacos云平台持久化服务数据</li><li>Nacos返回服务注册结果</li></ul><h2 id="Ncos特性：服务发现"><a href="#Ncos特性：服务发现" class="headerlink" title="Ncos特性：服务发现"></a>Ncos特性：服务发现</h2><h3 id="服务发现的定义"><a href="#服务发现的定义" class="headerlink" title="服务发现的定义"></a>服务发现的定义</h3><ul><li>将存在于统一服务平台或云平台中服务列表中的服务，通过一定的对外暴露手段，将服务列表进行对外暴露的过程</li></ul><h3 id="Nacos-实现服务发现思路"><a href="#Nacos-实现服务发现思路" class="headerlink" title="Nacos 实现服务发现思路"></a>Nacos 实现服务发现思路</h3><ul><li>Nacos 云平台自我检测服务列表</li><li>Nacos内部对外暴露服务列表</li><li>Nacos 启动服务间通信机制</li><li>Nacos 启动服务间健康检查机制</li><li>Nacos 维护服务元数据</li></ul><h2 id="Nacos特性：配置发布与获取"><a href="#Nacos特性：配置发布与获取" class="headerlink" title="Nacos特性：配置发布与获取"></a>Nacos特性：配置发布与获取</h2><h3 id="什么是配置发布"><a href="#什么是配置发布" class="headerlink" title="什么是配置发布"></a>什么是配置发布</h3><ul><li>将一个或多个服务所需的配置参数通过一定的技术手段，进行统一发布，使其生效或不生效的过程</li></ul><h3 id="配置获取"><a href="#配置获取" class="headerlink" title="配置获取"></a>配置获取</h3><ul><li>通过一定的技术手段，从统一的配置管理中心获取一个或多个服务配置参数，并进行自我校验的过程</li></ul><h3 id="Nacos-实现配置发布与获取思路"><a href="#Nacos-实现配置发布与获取思路" class="headerlink" title="Nacos 实现配置发布与获取思路"></a>Nacos 实现配置发布与获取思路</h3><ul><li>用户发起配置发布请求</li><li>Nacos配置监听程序捕获该请求</li><li>Nacos 对该请求进行解析</li><li>Nacos 识别配置文件格式、参数</li><li>Nacos 与具体服务建立通信</li><li>Nacos更新具体服务配置参数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Nacos 配置发布</span></span><br><span class="line">curl-X POST &quot;http://127.0.0.1:8848/nacos/v1/cs/configs?datald=nacos.cfgdatald&amp;group=test&amp;content=HelloWorld&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Nacos 配置获取</span></span><br><span class="line">curl -X GET &quot;http://127.0.0.1:8848/nacos/v1/cs/configs?datald=nacos.cfgdatald&amp;group=test&quot;</span><br></pre></td></tr></table></figure><h1 id="Nacos与Spring的整合"><a href="#Nacos与Spring的整合" class="headerlink" title="Nacos与Spring的整合"></a>Nacos与Spring的整合</h1><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><p>1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;br&gt;

&lt;h1 id=&quot;初识Nacos&quot;&gt;&lt;a href=&quot;#初识Nacos&quot; class=&quot;headerlink&quot; title=&quot;初识Nacos&quot;&gt;&lt;/a&gt;初识Nacos&lt;/h1&gt;&lt;h2 id=&quot;Nacos是什么&quot;&gt;&lt;a href=&quot;#Nacos是什么&quot; class=&quot;he</summary>
      
    
    
    
    <category term="microservice" scheme="https://ratears.github.io/dev.ratears.life/Categories/microservice/"/>
    
    <category term="Nacos" scheme="https://ratears.github.io/dev.ratears.life/Categories/microservice/Nacos/"/>
    
    
    <category term="Nacos" scheme="https://ratears.github.io/dev.ratears.life/Tags/Nacos/"/>
    
    <category term="microservice" scheme="https://ratears.github.io/dev.ratears.life/Tags/microservice/"/>
    
  </entry>
  
  <entry>
    <title>《ZooKeeper分布式专题与Dubbo微服务入门》Study Notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/%E3%80%8AZooKeeper%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98%E4%B8%8EDubbo%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E3%80%8BStudy-Notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/%E3%80%8AZooKeeper%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98%E4%B8%8EDubbo%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E3%80%8BStudy-Notes/</id>
    <published>2023-03-27T12:06:45.000Z</published>
    <updated>2023-03-27T12:06:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第1章-分布式系统概念与ZooKeeper简介"><a href="#第1章-分布式系统概念与ZooKeeper简介" class="headerlink" title="第1章 分布式系统概念与ZooKeeper简介"></a>第1章 分布式系统概念与ZooKeeper简介</h1><h2 id="ZooKeeper简介"><a href="#ZooKeeper简介" class="headerlink" title="ZooKeeper简介"></a>ZooKeeper简介</h2><ul><li>中间件，提供协调服务</li><li>作用于分布式系统，发挥其优势，可以为大数据服务</li><li>支持Java，提供Java和C语言的客户端API</li></ul><br><h2 id="什么是分布式系统"><a href="#什么是分布式系统" class="headerlink" title="什么是分布式系统"></a>什么是分布式系统</h2><ul><li>很多台计算机组成一个整体，一个整体一致对外并且处理同一请求</li><li>内部的每台计算机都可以相互通信（rest/rpc）</li><li>客户端到服务端的一次请求到响应结束会经历很多台计算机</li></ul><br><h2 id="ZooKeeper的特性"><a href="#ZooKeeper的特性" class="headerlink" title="ZooKeeper的特性"></a>ZooKeeper的特性</h2><ul><li>一致性：数据一致性，数据按照顺序分批入库</li><li>原子性：事务要么成功要么失败，不会局部化</li><li>单一视图：客户端连接集群中的任一zk节点，数据都是一致的</li><li>可靠性：每次对zk的操作状态都会保存在服务端</li><li>实时性：客户端可以读取到zk服务端的最新数据</li></ul><br><br><br><h1 id="第2章-ZooKeeper安装"><a href="#第2章-ZooKeeper安装" class="headerlink" title="第2章 ZooKeeper安装"></a>第2章 ZooKeeper安装</h1><h2 id="Zookeeper主要目录结构"><a href="#Zookeeper主要目录结构" class="headerlink" title="Zookeeper主要目录结构"></a>Zookeeper主要目录结构</h2><ul><li>bin：主要的一些运行命令</li><li>conf：存放配置文件，其中我们需要修改zk.cfo</li><li>contrib：附加的一些功能</li><li>dist-maven：mvn编译后的目录</li><li>docs：文档</li><li>lib：需要依赖的jar包</li><li>recipes：案例demo代码</li><li>src：源码</li></ul><br><h2 id="ZooKeeper单机版安装、配置、启动"><a href="#ZooKeeper单机版安装、配置、启动" class="headerlink" title="ZooKeeper单机版安装、配置、启动"></a>ZooKeeper单机版安装、配置、启动</h2><ul><li>环境要求：安装jdk，并配置环境变量（zookeeper是需要java编译的。所以需要安装jdk）</li><li>下载与准备</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src/</span><br><span class="line"></span><br><span class="line">wget https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/zookeeper-3.4.11.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf zookeeper-3.4.11.tar.gz</span><br><span class="line"></span><br><span class="line">mv /usr/local/src/zookeeper-3.4.11 /usr/local/</span><br><span class="line"></span><br><span class="line">cd /usr/local/</span><br><span class="line"></span><br><span class="line">ln -s zookeeper-3.4.11/ zookeeper</span><br></pre></td></tr></table></figure><ul><li>配置文件调整</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/zookeeper/conf/</span><br><span class="line"></span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br><span class="line"></span><br><span class="line">vim zoo.cfg</span><br></pre></td></tr></table></figure><ul><li>配置文件参数说明与修改<ul><li>tickTime：用于计算的时间单元。比如如session超时:N* tickTime</li><li>initLimit：用于集群，允许从节点连接并同步到 master节点的初始化连接时间，以tickTime的倍数来表示</li><li>syncLimit：用于集群，master主节点与从节点之间发送消息请求和应答时间长度。(心跳机制)</li><li>dataDir：必须配置，数据文件目录</li><li>dataLogDir：日志目录，如果不配置会和dataDir公用</li><li>clientPort：连接服务器的端口，默认 2181</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The number of milliseconds of each tick</span></span><br><span class="line">tickTime=2000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The number of ticks that the initial</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">synchronization phase can take</span></span><br><span class="line">initLimit=10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The number of ticks that can pass between</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sending a request and getting an acknowledgement</span></span><br><span class="line">syncLimit=5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the directory <span class="built_in">where</span> the snapshot is stored.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">do</span> not use /tmp <span class="keyword">for</span> storage, /tmp here is just</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">example sakes.</span></span><br><span class="line">dataDir=/usr/local/zookeeper/dataDir/</span><br><span class="line">dataLogDir=/usr/local/zookeeper/dataLogDir/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the port at <span class="built_in">which</span> the clients will connect</span></span><br><span class="line">clientPort=2181</span><br></pre></td></tr></table></figure><ul><li>创建数据目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/local/zookeeper/dataDir /usr/local/zookeeper/dataLogDir</span><br></pre></td></tr></table></figure><ul><li>配置ZooKeeper的环境变量后，启动ZooKeeper</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/zookeeper/bin</span><br><span class="line"></span><br><span class="line">./zkServer.sh start</span><br><span class="line"></span><br><span class="line">./zkServer.sh status</span><br><span class="line"></span><br><span class="line">./zkServer.sh stop</span><br></pre></td></tr></table></figure><br><br><br><h1 id="第3章-ZooKeeper基本数据模型"><a href="#第3章-ZooKeeper基本数据模型" class="headerlink" title="第3章 ZooKeeper基本数据模型"></a>第3章 ZooKeeper基本数据模型</h1><h2 id="基本数据模型介绍"><a href="#基本数据模型介绍" class="headerlink" title="基本数据模型介绍"></a>基本数据模型介绍</h2><ul><li>ZooKeeper的数据模型是一个树形结构</li><li>ZooKeeper 的数据模型也可以理解为linux/unix的文件目录:/usr/local/…</li><li>每一个节点都称之为 znode，它可以有子节点，也可以有数据</li><li>每个节点分为临时节点和永久节点，临时节点在客户端断开后消失</li><li>每个zk节点都各自的版本号，可以通过命令行来显示节点信息</li><li>每当节点数据发生变化，那么该节点的版本号会累加(乐观锁）</li><li>删除/修改过时节点，版本号不匹配则会报错</li><li>每个zk节点存储的数据不宜过大，几K即可</li><li>节点可以设置权限acl，可以通过权限来限制用户的访问</li></ul><br><h2 id="Zookeeper命令行客户端基本操作"><a href="#Zookeeper命令行客户端基本操作" class="headerlink" title="Zookeeper命令行客户端基本操作"></a>Zookeeper命令行客户端基本操作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端连接</span></span><br><span class="line">cd /usr/local/zookeeper/bin/</span><br><span class="line"></span><br><span class="line">./zkCli.sh</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] help</span><br><span class="line">ZooKeeper -server host:port cmd args</span><br><span class="line">        stat path [watch]</span><br><span class="line">        set path data [version]</span><br><span class="line">        ls path [watch]</span><br><span class="line">        delquota [-n|-b] path</span><br><span class="line">        ls2 path [watch]</span><br><span class="line">        setAcl path acl</span><br><span class="line">        setquota -n|-b val path</span><br><span class="line">        history</span><br><span class="line">        redo cmdno</span><br><span class="line">        printwatches on|off</span><br><span class="line">        delete path [version]</span><br><span class="line">        sync path</span><br><span class="line">        listquota path</span><br><span class="line">        rmr path</span><br><span class="line">        get path [watch]</span><br><span class="line">        create [-s] [-e] path data acl</span><br><span class="line">        addauth scheme auth</span><br><span class="line">        quit</span><br><span class="line">        getAcl path</span><br><span class="line">        close</span><br><span class="line">        connect host:port</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><h2 id="zk的作用体现"><a href="#zk的作用体现" class="headerlink" title="zk的作用体现"></a>zk的作用体现</h2><ul><li>master节点选举，主节点挂了以后，从节点就会接手工作并且保证这个节点是唯一的，这也是所谓首脑模式，从而保证我们的集群是高可用的</li><li>统一配置文件管理，即只需要部署一台服务器，则可以把相同的配置文件同步更新到其他所有服务器，此操作在云计算中用的特别多(假设修改了redis统一配置)</li><li>发布与订阅，类似消息队列MQ(amg，rmg…),dubbo发布者把数据存在znode上，订阅者会读取这个数据</li><li>提供分布式锁，分布式环境中不同进程之间争夺资源，类似于多线程中的锁</li><li>集群管理，集群中保证数据的强一致性</li></ul><br><br><br><h1 id="第4章-ZK基本特性与基于Linux的ZK客户端命令行学习"><a href="#第4章-ZK基本特性与基于Linux的ZK客户端命令行学习" class="headerlink" title="第4章 ZK基本特性与基于Linux的ZK客户端命令行学习"></a>第4章 ZK基本特性与基于Linux的ZK客户端命令行学习</h1><h2 id="zk常用命令行操作"><a href="#zk常用命令行操作" class="headerlink" title="zk常用命令行操作"></a>zk常用命令行操作</h2><ul><li>进入zk终端</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/zookeeper/bin</span><br><span class="line"></span><br><span class="line">./zkCli.sh</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] help</span><br><span class="line">ZooKeeper -server host:port cmd args</span><br><span class="line">        stat path [watch]</span><br><span class="line">        # 修改/设置，可以用来做分布式锁</span><br><span class="line">        set path data [version]</span><br><span class="line">        ls path [watch]</span><br><span class="line">        delquota [-n|-b] path</span><br><span class="line">        ls2 path [watch]</span><br><span class="line">        setAcl path acl</span><br><span class="line">        setquota -n|-b val path</span><br><span class="line">        history</span><br><span class="line">        redo cmdno</span><br><span class="line">        printwatches on|off</span><br><span class="line">        # 删除</span><br><span class="line">        delete path [version]</span><br><span class="line">        sync path</span><br><span class="line">        listquota path</span><br><span class="line">        rmr path</span><br><span class="line">        # watch 可以设置watcher</span><br><span class="line">        get path [watch]</span><br><span class="line">        # -s 顺序节点-e 临时节点path 路径data 数据acl 权限</span><br><span class="line">        create [-s] [-e] path data acl</span><br><span class="line">        addauth scheme auth</span><br><span class="line">        quit</span><br><span class="line">        getAcl path</span><br><span class="line">        close</span><br><span class="line">        connect host:port</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看某个路径（目录/节点）下的列表</span></span><br><span class="line">ls /</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看某个路径（目录/节点）下的状态</span></span><br><span class="line">stat /</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">相当于 <span class="built_in">ls</span> + <span class="built_in">stat</span></span></span><br><span class="line">ls2 /</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取出节点数据</span></span><br><span class="line">get /</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cZxid = 0x0# zk为节点分配的id</span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970# 节点创建时间</span><br><span class="line">mZxid = 0x0# 节点修改后分配的id</span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970# 节点修改时间</span><br><span class="line">pZxid = 0x6# 子节点id</span><br><span class="line">cversion = 0# 子节点version</span><br><span class="line">dataVersion = 0# 当前节点数据版本号，如果数据被修改了则会加1</span><br><span class="line">aclVersion = 0# 权限版本</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0# 数据长度</span><br><span class="line">numChildren = 2# 子节点个数</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br><h2 id="session的基本原理"><a href="#session的基本原理" class="headerlink" title="session的基本原理"></a>session的基本原理</h2><ul><li>客户端与服务端之间的连接存在会话</li><li>每个会话都会可以设置一个超时时间</li><li>心跳结束，session则过期</li><li>Session过期，则临时节点znode会被抛弃</li><li>心跳机制:客户端向服务端的ping包请求</li></ul><br><h2 id="watcher机制"><a href="#watcher机制" class="headerlink" title="watcher机制"></a>watcher机制</h2><ul><li>针对每个节点的操作，都会有一个监督者&gt; wathcer</li><li>当监控的某个对象(znode)发生了变化，则触发watcher事件</li><li>zk中的watcher是一次性的，触发后立即销毁（可以通过第三方开源客户端来设置成永久的）</li><li>父节点，子节点增删改都能够触发其watcher</li><li>针对不同类型的操作，触发的watcher事件也不同:<ul><li>(子)节点创建事件</li><li>(子)节点删除事件</li><li>(子)节点数据变化事件</li></ul></li></ul><br><h3 id="watcher命令"><a href="#watcher命令" class="headerlink" title="watcher命令"></a>watcher命令</h3><ul><li>通过get path [watch]设置watcher</li><li>父节点增删改操作触发 watcher</li><li>子节点增删改操作触发 watcher</li></ul><br><h3 id="watcher事件类型"><a href="#watcher事件类型" class="headerlink" title="watcher事件类型"></a>watcher事件类型</h3><h4 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h4><ul><li>创建父节点触发：NodeCreated</li><li>修改父节点数据触发:NodeDataChanged</li><li>删除父节点触发:NodeDeleted</li></ul><br><h4 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h4><ul><li>Is 为父节点设置watcher，创建子节点触发：NodeChildrenChanged</li><li>ls 为父节点设置watcher，删除子节点触发：NodeChildrenChanged</li><li>ls 为父节点设置watcher，修改子节点不触发事件（需要把子节点当成父节点来操作，即：给子节点设置watch ，才可以触发watcher事件）</li></ul><br><h3 id="watcher使用场景"><a href="#watcher使用场景" class="headerlink" title="watcher使用场景"></a>watcher使用场景</h3><ul><li>作为触发器，统一资源配置（当主机更新节点为新的配置信息，我们获取监听，可以更新客户端的配置信息）</li></ul><br><h2 id="ACL-access-control-lists-权限控制"><a href="#ACL-access-control-lists-权限控制" class="headerlink" title="ACL(access control lists)权限控制"></a>ACL(access control lists)权限控制</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>节点可以设置相关读写等权限，目的为了保障数据安全性</li><li>权限permissions可以指定不同的权限范围以及角色</li></ul><br><h3 id="ACL命令行"><a href="#ACL命令行" class="headerlink" title="ACL命令行"></a>ACL命令行</h3><ul><li>getAcl:获取某个节点的acl权限信息</li><li>setAcl:设置某个节点的acl权限信息</li><li>addauth: 输入认证授权信息，注册时输入明文密码(登录)但是在zk的系统里，密码是以加密的形式存在的</li></ul><br><h3 id="ACL的构成"><a href="#ACL的构成" class="headerlink" title="ACL的构成"></a>ACL的构成</h3><ul><li>zk的acl通过<code>[scheme:id:permissions]</code>来构成权限列表<ul><li>scheme:代表采用的某种权限机制<ul><li>world:world下只有一个id，即只有一个用户，也就是anyone，那么组合的写法就是 world:anyone:[permissions]</li><li>auth:代表认证登录，需要注册用户有权限就可以，形式为auth:user:password:[permissions]</li><li>digest:需要对密码加密才能访问，组合形式为digest: username:BASE64(SHA(password)) :[permissions]</li><li>super:代表超级管理员，拥有所有的权限</li></ul></li><li>id:代表允许访问的用户<ul><li>ip:当设置为ip指定的ip地址，此时限制ip进行访问，比如ip:192.168.1.1:[permissions]</li></ul></li><li>permissions:权限组合字符串（权限字符串缩写crdwa）<ul><li>CREATE:创建子节点</li><li>READ:获取节点/子节点</li><li>WRITE:设置节点数据</li><li>DELETE:删除子节点</li><li>ADMIN:设置权限</li></ul></li></ul></li></ul><blockquote><p>auth 与 digest的区别就是，前者明文，后者密文</p><p>setAcl /path auth:lee:lee:cdrwa 与 setAcl /path digest:lee:BASE64(SHA1(password))cdrwa 是等价的，在通过</p><p>addauth digest lee:lee 后都能操作指定节点的权限</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">world:anyone:cdrwa</span><br><span class="line"></span><br><span class="line">world:anyone:cdrwa</span><br><span class="line"></span><br><span class="line">auth:user:pwd:cdrwa</span><br><span class="line">digest: user:BASE64(SHA1(pwd)) :cdrwa</span><br><span class="line">addauth digest user:pwd</span><br><span class="line"></span><br><span class="line">ip:192.168.1.1: cdrwa</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">super</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1、修改 zkServer.sh 增加super管理员</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2、重启 zkServer.sh</span></span><br></pre></td></tr></table></figure><br><h3 id="ACL的常用使用场景"><a href="#ACL的常用使用场景" class="headerlink" title="ACL的常用使用场景"></a>ACL的常用使用场景</h3><ul><li>开发/测试环境分离，开发者无权操作测试库的节点，只能看</li><li>生产环境上控制指定ip的服务可以访问相关节点，防止混乱</li></ul><br><h2 id="zk四字命今-Four-Letter-Words"><a href="#zk四字命今-Four-Letter-Words" class="headerlink" title="zk四字命今 Four Letter Words"></a>zk四字命今 Four Letter Words</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul><li>zk可以通过它自身提供的简写命令来和服务器进行交互</li><li>需要使用到nc命令，安装:yum install nc</li><li>echo [commond] nc [ip] [port]</li></ul><br><h3 id="Zookeeper-四字命令"><a href="#Zookeeper-四字命令" class="headerlink" title="Zookeeper 四字命令"></a>Zookeeper 四字命令</h3><ul><li>[stat] 查看zk的状态信息，以及是否mode</li><li>[ruok] 查看当前zkserver是否启动，返回imok</li><li>[dump] 列出未经处理的会话和临时节点</li><li>[conf] 查看服务器配置</li><li>[cons] 展示连接到服务器的客户端信息</li><li>[envi] 环境变量</li><li>[mntr]监控zk健康信息</li><li>[wchs] 展示watch的信息</li><li>[wchc] 与 [wchp] session与watch 及 path与watch信息</li></ul><br><br><br><h1 id="第5章-选举模式和ZooKeeper的集群安装"><a href="#第5章-选举模式和ZooKeeper的集群安装" class="headerlink" title="第5章 选举模式和ZooKeeper的集群安装"></a>第5章 选举模式和ZooKeeper的集群安装</h1><h2 id="选举模式"><a href="#选举模式" class="headerlink" title="选举模式"></a>选举模式</h2><ul><li>zk集群，主从节点，心跳机制(选举模式)</li><li>配置数据文件 myid 1/2/3 对应 server.1/2/3</li><li>通过 zkCli.sh -server [ip]:[port] 检测集群是否配置成功</li></ul><br><h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先，保持单机的相关配置，再增加如下内容</span></span><br><span class="line"></span><br><span class="line">vim zoo.cfg</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果搭建三台zk的集群，配置格式如下。 第一个端口表示数据复制（同步）使用的端口，第二端口是zk间选举master使用的端口</span></span><br><span class="line">server.1=192.168.61.211:2888:3888</span><br><span class="line">server.2=192.168.61.212:2888:3888</span><br><span class="line">server.3=192.168.61.213:2888:3888</span><br><span class="line"></span><br><span class="line">cd dataDir</span><br><span class="line">touch myid</span><br><span class="line">vim myid</span><br><span class="line">1</span><br></pre></td></tr></table></figure><br><h2 id="选举测试"><a href="#选举测试" class="headerlink" title="选举测试"></a>选举测试</h2><ul><li>如果master宕机后，会重新选举出master，如果原宕机恢复后zk重启，此恢复后的zk只能作为flower</li></ul><br><br><br><h1 id="第6章-使用ZooKeeper原生Java-API进行客户端开发"><a href="#第6章-使用ZooKeeper原生Java-API进行客户端开发" class="headerlink" title="第6章 使用ZooKeeper原生Java API进行客户端开发"></a>第6章 使用ZooKeeper原生Java API进行客户端开发</h1><h2 id="Java客户端与zk服务端建立连接"><a href="#Java客户端与zk服务端建立连接" class="headerlink" title="Java客户端与zk服务端建立连接"></a>Java客户端与zk服务端建立连接</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: ZKConnectDemo.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span> com.imooc.zk.demo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: zookeeper 连接demo演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZKConnect</span> <span class="keyword">implements</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(ZKConnect.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//public static final String zkServerPath = &quot;192.168.1.110:2181&quot;;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">zkServerPath</span> <span class="operator">=</span> <span class="string">&quot;192.168.61.211:2181,192.168.61.212:2181,192.168.61.213:2181&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">timeout</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端和zk服务端链接是一个异步的过程</span></span><br><span class="line"><span class="comment"> * 当连接成功后后，客户端会收的一个watch通知</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 参数：</span></span><br><span class="line"><span class="comment"> * connectString：连接服务器的ip字符串，</span></span><br><span class="line"><span class="comment"> * 比如: &quot;192.168.1.1:2181,192.168.1.2:2181,192.168.1.3:2181&quot;</span></span><br><span class="line"><span class="comment"> * 可以是一个ip，也可以是多个ip，一个ip代表单机，多个ip代表集群</span></span><br><span class="line"><span class="comment"> * 也可以在ip后加路径</span></span><br><span class="line"><span class="comment"> * sessionTimeout：超时时间，心跳收不到了，那就超时</span></span><br><span class="line"><span class="comment"> * watcher：通知事件，如果有对应的事件触发，则会收到一个通知；如果不需要，那就设置为null</span></span><br><span class="line"><span class="comment"> * canBeReadOnly：可读，当这个物理机节点断开后，还是可以读到数据的，只是不能写，</span></span><br><span class="line"><span class="comment"> *        此时数据被读取到的可能是旧数据，此处建议设置为false，不推荐使用</span></span><br><span class="line"><span class="comment"> * sessionId：会话的id</span></span><br><span class="line"><span class="comment"> * sessionPasswd：会话密码当会话丢失后，可以依据 sessionId 和 sessionPasswd 重新获取会话</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ZooKeeper</span> <span class="variable">zk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(zkServerPath, timeout, <span class="keyword">new</span> <span class="title class_">ZKConnect</span>());</span><br><span class="line"></span><br><span class="line">log.warn(<span class="string">&quot;客户端开始连接zookeeper服务器...&quot;</span>);</span><br><span class="line">log.warn(<span class="string">&quot;连接状态：&#123;&#125;&quot;</span>, zk.getState());</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>().sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">log.warn(<span class="string">&quot;连接状态：&#123;&#125;&quot;</span>, zk.getState());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span> &#123;</span><br><span class="line">log.warn(<span class="string">&quot;接受到watch通知：&#123;&#125;&quot;</span>, event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><br><h1 id="第7章-Apache-Curator客户端的使用"><a href="#第7章-Apache-Curator客户端的使用" class="headerlink" title="第7章 Apache Curator客户端的使用"></a>第7章 Apache Curator客户端的使用</h1><h2 id="常用的zk-java客户端"><a href="#常用的zk-java客户端" class="headerlink" title="常用的zk java客户端"></a>常用的zk java客户端</h2><ul><li>zk原生api</li><li>zkclient</li><li>Apache curator</li></ul><h2 id="zk原生api的不足之处"><a href="#zk原生api的不足之处" class="headerlink" title="zk原生api的不足之处"></a>zk原生api的不足之处</h2><ul><li>超时重连，不支持自动，需要手动操作</li><li>Watch注册一次后会失效</li><li>不支持递归创建节点</li></ul><h2 id="Apache-curator"><a href="#Apache-curator" class="headerlink" title="Apache curator"></a>Apache curator</h2><ul><li>Apache的开源项目</li><li>解决watcher的注册一次就失效</li><li>Api更加简单易用</li><li>提供更多解决方案并且实现简单:比如 分布式锁</li><li>提供常用的ZooKeeper工具类</li><li>编程风格更爽</li></ul><br><br><br><h1 id="第8章-Dubbo入门到重构服务"><a href="#第8章-Dubbo入门到重构服务" class="headerlink" title="第8章 Dubbo入门到重构服务"></a>第8章 Dubbo入门到重构服务</h1><br><br><br><h1 id="第9章-分布式锁"><a href="#第9章-分布式锁" class="headerlink" title="第9章 分布式锁"></a>第9章 分布式锁</h1><br><br><br> <h1 id="第10章-课程总结"><a href="#第10章-课程总结" class="headerlink" title="第10章 课程总结"></a>第10章 课程总结</h1><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><p>1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第1章-分布式系统概念与ZooKeeper简介&quot;&gt;&lt;a href=&quot;#第1章-分布式系统概念与ZooKeeper简介&quot; class=&quot;headerlink&quot; title=&quot;第1章 分布式系统概念与ZooKeeper简介&quot;&gt;&lt;/a&gt;第1章 分布式系统概念与ZooKe</summary>
      
    
    
    
    <category term="ZooKeeper" scheme="https://ratears.github.io/dev.ratears.life/Categories/ZooKeeper/"/>
    
    
    <category term="microservice" scheme="https://ratears.github.io/dev.ratears.life/Tags/microservice/"/>
    
    <category term="ZooKeeper" scheme="https://ratears.github.io/dev.ratears.life/Tags/ZooKeeper/"/>
    
    <category term="Dubbo" scheme="https://ratears.github.io/dev.ratears.life/Tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>《技术面试官识人手册》Study Notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/%E3%80%8A%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E5%AE%98%E8%AF%86%E4%BA%BA%E6%89%8B%E5%86%8C%E3%80%8BStudy-Notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/%E3%80%8A%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E5%AE%98%E8%AF%86%E4%BA%BA%E6%89%8B%E5%86%8C%E3%80%8BStudy-Notes/</id>
    <published>2023-03-26T07:52:38.000Z</published>
    <updated>2023-03-26T07:52:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开篇词-1讲"><a href="#开篇词-1讲" class="headerlink" title="开篇词 (1讲)"></a>开篇词 (1讲)</h1><h2 id="开篇词-世事洞明皆学问，人情练达即文章：小面试，大道理"><a href="#开篇词-世事洞明皆学问，人情练达即文章：小面试，大道理" class="headerlink" title="开篇词 | 世事洞明皆学问，人情练达即文章：小面试，大道理"></a>开篇词 | 世事洞明皆学问，人情练达即文章：小面试，大道理</h2><ul><li>面试就是打造团队的第一道门槛，它可能短暂、直接地影响你一个项目的进度，也可能长期、潜在地左右你整个团队的战斗力。</li></ul><h3 id="晋升第一课，招募人才"><a href="#晋升第一课，招募人才" class="headerlink" title="晋升第一课，招募人才"></a>晋升第一课，招募人才</h3><ul><li>首先，去负责技术面试，帮助公司和团队招募人才，就是一个职业上升通道的必攻克项</li><li>面试还是一个预期和限制都很明确的快速学习机会，并且，是一个双向的学习机会<ul><li>预期：我们针对软件工程师这个特定岗位对于候选人的期待</li><li>限制：明确了双方需要在每轮短短几十分钟的时间内进行交流与合作，完成话题的讨论，或是问题的解决</li></ul></li><li>深度体验换位思考，让自己和市场保持同步</li></ul><h3 id="打造优秀团队，严把人才关"><a href="#打造优秀团队，严把人才关" class="headerlink" title="打造优秀团队，严把人才关"></a>打造优秀团队，严把人才关</h3><ul><li>总归要有一个环节把质量严格地把控好，否则就要让某个下游环节买单，下游环节不买单，那就要留给用户买单了</li></ul><h3 id="候选人成长空间"><a href="#候选人成长空间" class="headerlink" title="候选人成长空间"></a>候选人成长空间</h3><ul><li>长期看，你可以了解到哪些知识和能力是值得长期投入的；短期看，你可以了解对方的初衷和心态是怎样的。</li><li>我们还可以从中评估和强化自己的认识；面试没通过，你也不至于说挂得不明不白。</li></ul><h3 id="你的收获"><a href="#你的收获" class="headerlink" title="你的收获"></a>你的收获</h3><ul><li>面试前：我将介绍为什么要对软件工程师进行技术面试，应当覆盖哪些面试角度，以及我们该怎样去设计面试题</li><li>面试中：专栏的重中之重，我将结合实例探讨怎样主导技术面试。包括怎样把控流程，怎样进行算法和数据结构的考察，系统设计的考察，面向对象和测试能力的考察，基础知识的考察，以及行为面试的操作方法等等。</li><li>面试后：我将针对候选人的评估讨论会如何开展来介绍。包括怎样收集事实、提炼数据，怎样引导争辩、达成共识，以及最终怎样给出客观中肯的评估。</li></ul><br><br><br><h1 id="面试准备-计划篇-5讲"><a href="#面试准备-计划篇-5讲" class="headerlink" title="面试准备/计划篇 (5讲)"></a>面试准备/计划篇 (5讲)</h1><h2 id="01-评估体系：公司和团队到底需要怎样的技术人才？"><a href="#01-评估体系：公司和团队到底需要怎样的技术人才？" class="headerlink" title="01 | 评估体系：公司和团队到底需要怎样的技术人才？"></a>01 | 评估体系：公司和团队到底需要怎样的技术人才？</h2><ul><li><strong>胜兵先胜而后求战，败兵先战而后求胜</strong></li><li></li></ul><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><p>1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;开篇词-1讲&quot;&gt;&lt;a href=&quot;#开篇词-1讲&quot; class=&quot;headerlink&quot; title=&quot;开篇词 (1讲)&quot;&gt;&lt;/a&gt;开篇词 (1讲)&lt;/h1&gt;&lt;h2 id=&quot;开篇词-世事洞明皆学问，人情练达即文章：小面试，大道理&quot;&gt;&lt;a href=&quot;#开篇词-世事</summary>
      
    
    
    
    <category term="interview" scheme="https://ratears.github.io/dev.ratears.life/Categories/interview/"/>
    
    
    <category term="interview" scheme="https://ratears.github.io/dev.ratears.life/Tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>《面试现场》Study Notes</title>
    <link href="https://ratears.github.io/dev.ratears.life/%E3%80%8A%E9%9D%A2%E8%AF%95%E7%8E%B0%E5%9C%BA%E3%80%8BStudy-Notes/"/>
    <id>https://ratears.github.io/dev.ratears.life/%E3%80%8A%E9%9D%A2%E8%AF%95%E7%8E%B0%E5%9C%BA%E3%80%8BStudy-Notes/</id>
    <published>2023-03-24T14:17:30.000Z</published>
    <updated>2023-03-24T14:17:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开篇词-1讲"><a href="#开篇词-1讲" class="headerlink" title="开篇词 (1讲)"></a>开篇词 (1讲)</h1><h2 id="开篇词-面试，这样做会功到自然成"><a href="#开篇词-面试，这样做会功到自然成" class="headerlink" title="开篇词 | 面试，这样做会功到自然成"></a>开篇词 | 面试，这样做会功到自然成</h2><ul><li><p><strong>优点发挥得足够强，就可以弥补缺点，除非舞台不合适</strong></p><ul><li>面试官需要关注的，应该是应聘者的优点。缺点每个人都有，但是要把工作做好的话，首先凭的是优点。如果优点能发挥到位，缺点能够被其他的因素补足，那这个人就是合适的。</li></ul></li><li><p><strong>面试的核心，对于应聘者，是想方设法让面试官认可自己对职位有用的那些优点。</strong></p></li><li><p><strong>用真诚的态度，有效地表达自己的能力和价值，建立相互的信任和认可。</strong></p></li></ul><blockquote><p><strong>缺少发掘和表达自己能力的能力。</strong></p></blockquote><blockquote><p>竖一面放大镜，带你看清自己的能力结构（而不仅仅只是关注技术层面），明白培养这些能力的关键因素，并且启发你在自身经历中寻找反映这些能力的素材和故事。</p></blockquote><blockquote><p>搭一座桥，一座在面试官和求职者中间，让沟通更直接、更到位的桥。让你能够分析面试问题的意图，用有价值、有亮点的经历或观点去回答，让面试官轻而易举地看出你的能力和价值。</p></blockquote><blockquote><p>在“知彼篇”里，让应聘者明白面试官眼里的人才素质模型，这相当于面试的“考点大纲”；介绍公司整个招聘过程，带你了解面试中考查能力的一般方法，让你更容易理解面试官的意图。</p><p>在“知己篇”里，带你搞清楚什么是工作中决定个人发展的关键因素，进而明确自己该不该换工作；另一方面，明确自己的职业愿景和规划。准备一份详历，挖掘自己的能力、价值和亮点，并浓缩成一份受青睐的简历给面试官看。</p><p>在“问答篇”里，和你分析面试中常见的几类问题，包括如何解释清楚一个技术点，如何体现你在项目中的重要性等等，帮助你回答得更加精准到位。</p><p>在“贯通篇”里，重点分析几种能力：学习能力、精益能力、协作能力、管理和领导能力等等，这些能力都体现为解决问题的能力，目的是让你了解提高这些能力的关键因素，到详历中寻找合适的事例，全面精准地把你真实的能力水平展现给面试官。</p><p>在“综合篇”里，盘点面试官和应聘者的认知偏差，强调双向选择中，帮你明确该如何衡量新团队和新环境，如何处理和老东家的关系，以及从面试中学习，为长远的发展提供动力。</p></blockquote><ul><li>一个优秀的人，其职业发展的终极目标，是把自己变得更优秀</li><li>借着面试这个场景，和你聊聊一个优秀的人应该如何规划自己的职业。我希望这个专栏能让你更了解面试、更了解工作、更了解自己，并在自己的职业成熟度上有所启发，走出一条不同寻常的路。</li></ul><br><br><br><h1 id="基础：知彼篇-3讲"><a href="#基础：知彼篇-3讲" class="headerlink" title="基础：知彼篇 (3讲)"></a>基础：知彼篇 (3讲)</h1><h2 id="01-公司到底想要什么样的人？"><a href="#01-公司到底想要什么样的人？" class="headerlink" title="01 | 公司到底想要什么样的人？"></a>01 | 公司到底想要什么样的人？</h2><ul><li>公司到底想要什么样的人，面试到底在面什么?</li><li>要想提高自己通过面试的几率，你必须明确面试的内容范围和要求</li></ul><h3 id="公司眼中的好员工"><a href="#公司眼中的好员工" class="headerlink" title="公司眼中的好员工"></a>公司眼中的好员工</h3><ul><li><p>工作结果</p><ul><li>个人工作结果质量好，价值高</li><li>赋能别人做出成果</li></ul></li><li><p>看过程</p><ul><li>对工作内容、环境因素带来的工作复杂度的衡量，也体现了对个人的技能、态度的衡量</li></ul></li><li><p>面试官还要进一步看应聘者的行为是否可以被预测</p></li><li><p>信任感使你能预测对方将来的行为</p></li></ul><h3 id="应聘者的素质模型"><a href="#应聘者的素质模型" class="headerlink" title="应聘者的素质模型"></a>应聘者的素质模型</h3><img src="https://cdn.staticaly.com/gh/ratears/image-hosting@main/blog-img-bed/1679720662448.5vh94c0lz3c0.webp" width="70%"><br><h4 id="1-经验（Experience）"><a href="#1-经验（Experience）" class="headerlink" title="1. 经验（Experience）"></a>1. 经验（Experience）</h4><ul><li>经验是指工作经历的对象和产出，体现为专业相关的知识和思维结构（Idea），用来指导思考和行为。</li></ul><h4 id="2-技能（Skill）"><a href="#2-技能（Skill）" class="headerlink" title="2. 技能（Skill）"></a>2. 技能（Skill）</h4><ul><li>技能是做事的能力，体现一个人的专业性。</li><li>产生 idea 的技能：针对问题，基于经验，收集、理解、分析和制定新的方案（idea），涉及理解、思考、沟通等过程。</li><li>执行 idea 的技能：运用工具，把方案（idea）应用到实践，从而解决问题。除了用到理解、思考、沟通，还需要协作团队、管理资源，甚至领导和影响他人。</li></ul><h4 id="3-潜力（Potential）"><a href="#3-潜力（Potential）" class="headerlink" title="3. 潜力（Potential）"></a>3. 潜力（Potential）</h4><ul><li>增长经验和技能的能力</li><li>学习：从不会到会，掌握一项技能的过程</li><li>创新：针对特定场景创造新事物的技能</li><li>精益：把事情越做越好的技能</li></ul><blockquote><p>如果你承认潜力，那么就说明你有成长型思维，有成长思维的人认为：技能是可以通过努力获得的，关键是要保持好奇心，平时爱思考、总结、尝试，愿意接受挑战，不怕错误和失败。因此，要在潜力上为自己的面试效果加分，你就需要注意如何在言谈及简历描述中体现这些特质。</p></blockquote><h4 id="4-动机（Motivation）"><a href="#4-动机（Motivation）" class="headerlink" title="4. 动机（Motivation）"></a>4. 动机（Motivation）</h4><ul><li><strong>做事情的内心目标、意愿和态度</strong></li><li>自燃型，也就是自我驱动的员工，他们做事动机强烈，目标明确，明白任务的意义，甚至自己寻找有意义的事，满怀激情地投入，往往超出自己的工作范围，去推动进展，取得成果，然后又奔向下一个目标。</li><li>点燃型，这类员工需要一定的激励，需要他人帮助才能找到目标和意义，一旦“激活”就能像自燃型员工一样奋力工作。</li><li>阻燃型，这类员工当一天和尚撞一天钟，给多少钱，干多少活，按工作的最低标准和最后完成时间递交任务，跟同事合作差，不乐意分享，自我保护。</li></ul><blockquote><p>人格品质，比如诚实守信、认真负责、坚毅勇敢等。这些从底层决定我们的做事动机。</p><p>职业价值观，就是在工作中区分是非、明确轻重的观念。比如，有人喜欢轻松安稳的工作，有人喜欢冒险和竞争；有人喜欢照章办事，有人则喜欢灵活自主；有人追求个人利益，有人则喜欢分享和帮助他人。</p><p>职业性格，是长久的思维和行为习惯，受环境影响固化成的心态“定势”</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>公司到底想要什么样的人呢？我们从应聘者素质模型可以看出：</p><ul><li>动机方面，公司更想要人品好，职业价值观和团队文化一致，职业性格和职位匹配的候选人；</li><li>潜力方面，公司更想要学习、创新和精益能力好的候选人；</li><li>技能和经验方面，公司想要和职位需求匹配的，如果你资历过剩，就要看公司发展需要了，如果你资历不够，那就要看你的潜力和动机了。</li></ul></li><li><p>借助素质模型，对职位描述的理解，理解以下两点：</p><ul><li>了解面试官考查的各项内容和期待，做到“知彼”，不打无准备的仗；</li><li>从个人经历中挖掘素材，突出契合职位需要的内容，以满足面试官的预期。</li></ul></li><li><p><strong>搞清楚面试官的考查要素之后，在提高和表现这些能力上受到一些启发，有的放矢地把自己呈现给面试官。</strong></p></li></ul><br><br><br><h2 id="02-想要成功面试，先要弄懂面试过程"><a href="#02-想要成功面试，先要弄懂面试过程" class="headerlink" title="02 | 想要成功面试，先要弄懂面试过程"></a>02 | 想要成功面试，先要弄懂面试过程</h2><ul><li><p>需要清楚招聘过程，知道各个环节背后：有什么人在主导，目的是什么，要注意什么，该做什么，不该做什么，以及有什么风险</p></li><li><p>从一个招聘职位出现，到招聘结束，需要清楚整个过程发生了什么？需要注意什么？以面试官的视角，增加认知，充分准备，减少失误，为面试效果加分</p></li></ul><h3 id="看懂招聘全流程，不打无准备之仗"><a href="#看懂招聘全流程，不打无准备之仗" class="headerlink" title="看懂招聘全流程，不打无准备之仗"></a>看懂招聘全流程，不打无准备之仗</h3><h4 id="1-确定职位空缺，提前预知工作的难度"><a href="#1-确定职位空缺，提前预知工作的难度" class="headerlink" title="1. 确定职位空缺，提前预知工作的难度"></a>1. 确定职位空缺，提前预知工作的难度</h4><ul><li>填补空缺：因为有前任的工作样板，工作细节清楚、职责明确，确定性高，老板对这个职位的期待也很明确，双方都可以清楚地评价人和工作的匹配度。而且，应聘者完全可以复用前任的经验轻松上手，但是因为有前任的对比，需要超越前任的表现才能获得好评。</li><li>新增职位：工作难度和职责细节往往还不清晰，在团队中还没有和其他职位形成稳定的职责接口，甚至老板对这个职位的期待可能还说不清，新人做起工作来，需要很多的探索和磨合，较难上手。但是因为没有对比，你比较容易校正老板的期待，也容易获得好评。</li></ul><h4 id="2-了解简历收集渠道和筛选过程，有的放矢"><a href="#2-了解简历收集渠道和筛选过程，有的放矢" class="headerlink" title="2. 了解简历收集渠道和筛选过程，有的放矢"></a>2. 了解简历收集渠道和筛选过程，有的放矢</h4><ul><li>内推</li><li>公司网站</li><li>社交平台</li><li>招聘网站</li><li>线下招聘会</li><li>猎头公司</li></ul><ul><li>投递简历的注意事项<ul><li>简历邮件标题至少要写清应聘职位、姓名</li><li>简历附件尽量用 PDF 格式，保证跨平台阅读的一致性</li><li>用一些稍正式的个人邮箱地址投递简历</li></ul></li></ul><ul><li>不要给自己设限，你认为的，并不一定面试官也这么认为。</li></ul><h4 id="3-面试，是谁决定了你的去留"><a href="#3-面试，是谁决定了你的去留" class="headerlink" title="3. 面试，是谁决定了你的去留"></a>3. 面试，是谁决定了你的去留</h4><ul><li>谁来决定一个应聘者面试通过与否？</li><li>面试官可能来源于三类角色：HR、部门大牛、部门经理<ul><li>hr：重点考查人才的基本面：动机（价值观、职业性格）和潜力</li><li>部门大牛：最清楚工作细节，关注应聘者在这些细节上的经验和技能，也就是解决问题的能力</li><li>部门经理：两方面兼顾，既要保证此人能胜任岗位（或者通过学习能够很快胜任），还要验证他的动机和潜力，确保他能认可公司文化，融入团队，保持稳定长远的发展。</li></ul></li><li>部门经理对自己的职位人选负责。在评价应聘者的面试表现时，他会听取 HR 和部门大牛的反馈，结合自己的体会，做出以下几种决定：<ul><li>录用</li><li>不录用：不适合本职位（不排除推荐给其他匹配的职位）。</li><li>候选，留待与后面的人作比较：不是非常理想的人选，需要再看看后面有没有更合适的（如果时间允许的话）</li><li>再面试一次：没看清，拿不准。这往往是因为面试中应聘者没能充分表达自己的能力所致</li></ul></li></ul><blockquote><p>最终，高级经理可能做最后一轮面试，以便确定你确实是符合团队需要的人员。在这一轮对话中，你会得到更多关于公司和团队的信息，这时我建议你多问多了解，以便能够更好地判断这个职位是否满足你的预期，是否符合你的职业发展规划，甚至为你判断是否要加入这个公司提供信息支持。</p></blockquote><ul><li><strong>作为应聘者，在面试阶段你的任务就是，充分展示与职位相关的、能力素质模型的要素，同时了解公司团队，建立互信。</strong></li></ul><h4 id="4-签-Offer，定薪水"><a href="#4-签-Offer，定薪水" class="headerlink" title="4. 签 Offer，定薪水"></a>4. 签 Offer，定薪水</h4><ul><li>这个阶段不能闭口不提薪水</li><li>HR 负责提供公司级别的薪水标准范围，如果部门经理的薪水诉求超过了薪水范围，会被交给上一管理层审批</li></ul><h4 id="5-入职试用期，你还不能放松警惕"><a href="#5-入职试用期，你还不能放松警惕" class="headerlink" title="5. 入职试用期，你还不能放松警惕"></a>5. 入职试用期，你还不能放松警惕</h4><ul><li>需要尽快地承担起工作职责，用能力说话，持续建立和加强同团队的信任，推动个人和团队的发展。</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>HR 负责快速筛选简历，组织面试，确保为职位快速找到合适的人；</li><li>部门经理才是决定你面试结果的人，也是决定这份 Offer 薪资水平的人</li><li><strong>作为应聘者，你需要了解这些“利益干系人”的关注点，从而有针对性地、最大化地展示你的能力。</strong></li></ul><br><br><br><h2 id="03-面试官的面试逻辑是什么？"><a href="#03-面试官的面试逻辑是什么？" class="headerlink" title="03 | 面试官的面试逻辑是什么？"></a>03 | 面试官的面试逻辑是什么？</h2><br><br><br><h1 id="基础：知己篇-8讲"><a href="#基础：知己篇-8讲" class="headerlink" title="基础：知己篇 (8讲)"></a>基础：知己篇 (8讲)</h1><br><br><br><h1 id="学习备注"><a href="#学习备注" class="headerlink" title="学习备注"></a>学习备注</h1><blockquote><p>1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;emsp;</span><span class="symbol">&amp;emsp;</span></span><br></pre></td></tr></table></figure><img src="" width="70%"><br>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;开篇词-1讲&quot;&gt;&lt;a href=&quot;#开篇词-1讲&quot; class=&quot;headerlink&quot; title=&quot;开篇词 (1讲)&quot;&gt;&lt;/a&gt;开篇词 (1讲)&lt;/h1&gt;&lt;h2 id=&quot;开篇词-面试，这样做会功到自然成&quot;&gt;&lt;a href=&quot;#开篇词-面试，这样做会功到自然成&quot;</summary>
      
    
    
    
    <category term="interview" scheme="https://ratears.github.io/dev.ratears.life/Categories/interview/"/>
    
    
    <category term="interview" scheme="https://ratears.github.io/dev.ratears.life/Tags/interview/"/>
    
  </entry>
  
</feed>
